{"meta":{"title":"Lijiale","subtitle":"欢迎来到我的博客! 本人江苏大学控制工程研究生,喜欢互联网技术、健身、篮球、弹吉他...","description":"Hexo是一个快速，简单且功能强大的博客框架。您使用Markdown（或其他标记语言）编写帖子，然后Hexo会在几秒钟内生成带有精美主题的静态文件。","author":"Lee AKang","url":"https://lijiale96.github.io","root":"/"},"pages":[{"title":"分类","date":"2020-02-21T13:45:27.000Z","updated":"2020-02-21T14:49:13.885Z","comments":false,"path":"categories/index.html","permalink":"https://lijiale96.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-02-21T13:46:33.000Z","updated":"2020-02-21T14:49:36.289Z","comments":true,"path":"tags/index.html","permalink":"https://lijiale96.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Mybatis(雷神笔记)","slug":"Mybatis(雷神笔记)","date":"2020-11-14T07:40:32.000Z","updated":"2020-11-15T12:55:05.183Z","comments":true,"path":"2020/11/14/Mybatis(雷神笔记)/","link":"","permalink":"https://lijiale96.github.io/2020/11/14/Mybatis(%E9%9B%B7%E7%A5%9E%E7%AC%94%E8%AE%B0)/","excerpt":"b站视频：https://www.bilibili.com/video/BV1zb411V77d?p=47 MyBatis官网：https://mybatis.org/mybatis-3/getting-started.html 因为在今年9月的面试中，Mybatis相关的知识点有很大的盲区。所以重新学了MyBatis，并进行了笔记梳理。","text":"b站视频：https://www.bilibili.com/video/BV1zb411V77d?p=47 MyBatis官网：https://mybatis.org/mybatis-3/getting-started.html 因为在今年9月的面试中，Mybatis相关的知识点有很大的盲区。所以重新学了MyBatis，并进行了笔记梳理。 1、映射文件EmployeeMapperDynamicSQL.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"com.atguigu.crowd.mapper.EmployeeMapperPlus\" &gt; &lt;cache eviction=\"FIFO\" flushInterval=\"6000\" readOnly=\"false\" size=\"1024\" type=\"org.mybatis.caches.ehcache.EhcacheCache\"&gt;&lt;/cache&gt;&lt;!-- eviction：缓存的回收策略 * LRU-最近最少使用，移除最长时间不被使用的对象 * FIFO - 先进先出，按对象进入缓存的顺序移除它们 * SOFT -软引用 移除基于垃圾回收器状态和软引用规则的对象 * WEAK - 弱引用，要积极地移除基于垃圾收集器状态和若引用规则的对象 * 默认的是LRU flushInterval：缓存刷新间隔 缓存多长时间清空一次，默认不清空，设置一个毫秒值 readOnly：是否只读 true：只读 mybatis认为所有从缓存中获取的数据操作都是只读操作，不会修改数据 mybatis为了加快获取速度，直接会将数据在缓存中的引用交给用户。不安全、速度快 false：非只读：mybatis觉得获取的数据可能会被修改 mybatis会利用序列化&amp;反序列的技术克隆一份新的数据给你。安全，速度慢 size：缓存存放多少元素 type=“ ”：指定自定义缓存的全类名 实现Cache接口即可 --&gt;&lt;!-- namespace:名称空间；指定为接口的全类名 id：唯一标识 resultType：返回值类型 #&#123;id&#125;：从传递过来的参数中取出id的值--&gt; &lt;!-- public Employee getEmpById(Integer id);--&gt; &lt;!-- 自定义某个javaBean的封装规则 type：自定义规则的java类型 id：唯一id方便引用--&gt; &lt;resultMap id=\"MyEmp\" type=\"com.atguigu.crowd.entity.Menu\" &gt; &lt;!-- 指定主键列的封装规则--&gt; &lt;!-- id定义主键会底层优化 column：指定哪一列 property：指定对应的javaBean属性 --&gt; &lt;id column=\"id\" property=\"id\" jdbcType=\"INTEGER\" /&gt; &lt;!-- 定义普通封装规则 --&gt; &lt;result column=\"pid\" property=\"pid\" jdbcType=\"INTEGER\" /&gt; &lt;!-- 其他不指定的列会自动封装，我们只要写resultMap就把全部的映射规则都写上--&gt; &lt;result column=\"name\" property=\"name\" jdbcType=\"VARCHAR\" /&gt; &lt;result column=\"url\" property=\"url\" jdbcType=\"VARCHAR\" /&gt; &lt;result column=\"icon\" property=\"icon\" jdbcType=\"VARCHAR\" /&gt; &lt;/resultMap&gt; &lt;!--resultMap：自定义结果集映射规则--&gt; &lt;select id=\"getEmpById\" resultMap=\"MyEmp\"&gt; select * from tb1_employee where id=#&#123;id&#125; &lt;/select&gt; &lt;!-- 场景一： 查询Employee的同时查询员工对应的部门 Employee===Department 一个员工有与之对应的信息 --&gt; &lt;!-- 联合查询:级联属性封装结果集--&gt; &lt;resultMap id=\"MyDifEmp\" type=\"com.atguigu.crowd.entity.Employee\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"last_name\" property=\"lastName\"/&gt; &lt;result column=\"gender\" property=\"gender\"/&gt; &lt;result column=\"did\" property=\"dept.id\"/&gt; &lt;result column=\"dept_name\" property=\"dept.departmentName\"/&gt; &lt;/resultMap&gt; &lt;!-- public EmployeeMapperPlus getEmpAndDept(Integer id);--&gt; &lt;select id=\"getEmpAndDept\" resultMap=\"MyDifEmp\"&gt; select e.id id,e.last_name last_name,e.gender gender,e.d_id d_id from tb1_employee e,tb1_dept d where e.d_id=d.id and e.id=#&#123;id&#125; &lt;/select&gt; &lt;resultMap id=\"MyDifEmp2\" type=\"com.atguigu.crowd.entity.Employee\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"last_name\" property=\"lastName\"/&gt; &lt;result column=\"gender\" property=\"gender\"/&gt; &lt;!-- association可以指定联合的javaBean对象 property=\"dept\":指定哪个属性是联合的对象 javaType：指定这个属性对象的类型【不能省略】 --&gt; &lt;association property=\"dept\" javaType=\"com.atguigu.crowd.entity.Department\"&gt; &lt;id column=\"did\" property=\"id\"/&gt; &lt;result column=\"dept_name\" property=\"departmentName\"/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;!-- public EmployeeMapperPlus getEmpAndDept(Integer id);--&gt; &lt;select id=\"getEmpAndDept\" resultMap=\"MyDifEmp2\"&gt; select e.id id,e.last_name last_name,e.gender gender,e.d_id d_id from tb1_employee e,tb1_dept d where e.d_id=d.id and e.id=#&#123;id&#125; &lt;/select&gt; &lt;!-- 使用association进行分步查询： 1、先按照员工id查询员工信息 2、根据查询员工信息中的d_id值去部门表查出部门信息 3、部门设置到员工中 public Employee getEmpByIdStep(Integer id); --&gt; &lt;!-- id last-name email gender d_id--&gt; &lt;resultMap id=\"MyEmpByStep\" type=\"com.atguigu.crowd.entity.Employee\"&gt; &lt;id column=\"id\" property=\"'id\"/&gt; &lt;result column=\"last_name\" property=\"lastName\"/&gt; &lt;result column=\"email\" property=\"email\"/&gt; &lt;result column=\"gender\" property=\"gender\"/&gt; &lt;!-- 使用association定义关联单个对象的封装规则 select:表明当前属性是调用select指定的方法查出的结果 column：指定将哪一列的值传给这个方法 流程：使用select指定的方法（传入column指定的这列参数的值）查出对象，并封装给property指定的属性 --&gt; &lt;association property=\"dept\" select=\"com.atguigu.mybatis.mapper.DepartmentMapper.getDeptById\" column=\"d_id\"&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=\"getEmpByIdStep\" resultMap=\"getEmpByIdStep\"&gt; select * from tb1_employee where id=#&#123;id&#125; &lt;/select&gt; &lt;!-- 可以使用延迟加载：(懒加载/按需加载) Employee==&gt;Dept: 我们每次查询Employee对象的时候，都将一起查询出来。 部门信息在我们使用的时候再去查询； 分段查询的基础之上加上两个配置： 显示的指定每个我们需要更改的配置的值，即使它是默认的。防止更新带来的问题 &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; 开启时，任一方法的调用都会加载该对象的所有延迟加载属性。 否则，每个延迟加载属性会按需加载（参考 lazyLoadTriggerMethods)。 &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/&gt; --&gt; &lt;!-- =================================association===================================--&gt; &lt;!-- 场景二： 查询部门的时候将部门对应的所有员工信息也查询出来:注释在DepartmentMapper.xml中 public List&lt;Employee&gt; getEmpsByDeptId(Integer deptId); --&gt; &lt;select id=\"getEmpsByDeptId\" resultType=\"com.atguigu.crowd.entity.Employee\"&gt; select * from tb1_employee where d_id=#&#123;deptId&#125; &lt;/select&gt; &lt;!-- &lt;discriminator javaType=\"\"&gt; &lt;case value=\"\"&gt;&lt;/case&gt; &lt;/discriminator&gt; 鉴别器：mybatis可以使用discriminator判断某列的值，然后根据某列的值改变封装行为 封装Employee： 如果查出的是女生，就把部门信息查询出来，否则不查询； 如果是男生，把last_name这一列的值赋给email； --&gt; &lt;resultMap id=\"com.atguigu.crowd.entity.Employee\" type=\"MyEmpDis\"&gt; &lt;id column=\"id\" property=\"'id\"/&gt; &lt;result column=\"last_name\" property=\"lastName\"/&gt; &lt;result column=\"email\" property=\"email\"/&gt; &lt;result column=\"gender\" property=\"gender\"/&gt;&lt;!-- column:指定判定的列名 javaType：列值对应的java类型--&gt; &lt;discriminator javaType=\"String\" column=\"gender\"&gt;&lt;!-- 女生 resultType：指定封装的结果类型,不能缺少--&gt; &lt;case value=\"0\" resultType=\"com.atguigu.crowd.entity.Employee\"&gt; &lt;association property=\"dept\" select=\"com.atguigu.mybatis.mapper.DepartmentMapper.getDeptById\" column=\"d_id\"&gt; &lt;/association&gt; &lt;/case&gt;&lt;!-- 男生 把last_name这一列的值赋给email--&gt; &lt;case value=\"1\" resultType=\"com.atguigu.crowd.entity.Employee\"&gt; &lt;id column=\"id\" property=\"'id\"/&gt; &lt;result column=\"last_name\" property=\"lastName\"/&gt; &lt;result column=\"last_name\" property=\"email\"/&gt; &lt;result column=\"gender\" property=\"gender\"/&gt; &lt;/case&gt; &lt;/discriminator&gt; &lt;/resultMap&gt; &lt;/mapper&gt; DepartmentMapper.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"com.atguigu.crowd.mapper.DepartmentMapper\" &gt; &lt;select id=\"getDeptById\" resultType=\"com.atguigu.crowd.entity.Department\"&gt; select id,dept_name departmentName from tb1_dept where id=#&#123;id&#125;; &lt;/select&gt;&lt;!-- collection嵌套结果集的方式，定义关联的集合类型元素的封装规则--&gt;&lt;!-- private Integer id; private String departmentName; private List&lt;Employee&gt; emps; did dept_name || eid last_name email gender --&gt;&lt;!-- public Department getDeptByIdPlus(Integer id);--&gt;&lt;!-- 嵌套结果集的方式，使用collection标签定义关联的集合类型的属性封装规则--&gt; &lt;resultMap id=\"MyDept\" type=\"com.atguigu.crowd.entity.Department\"&gt; &lt;id column=\"did\" property=\"id\"/&gt; &lt;result column=\"dept_name\" property=\"departmentName\"/&gt;&lt;!-- collection定义关联集合类型的属性的封装规则 ofType；指定集合里面元素的类型--&gt; &lt;collection property=\"emps\" ofType=\"com.atguigu.crowd.entity.Employee\"&gt; &lt;!-- 定义这个集合中元素的封装规则--&gt; &lt;id column=\"eid\" property=\"id\"/&gt; &lt;result column=\"last_name\" property=\"lastName\"/&gt; &lt;result column=\"email\" property=\"email\"/&gt; &lt;result column=\"gender\" property=\"genger\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"getDeptByIdPlus\" resultMap=\"MyDept\"&gt; select d.id did,d.dept_name dept_name e.id eid,e.last_name last_name,e.email email,e.gender gender from tb1_dept d left join tb1_employee e on d.id =e.d_id where d.id=#&#123;id&#125; &lt;/select&gt; &lt;resultMap id=\"MyDeptStep\" type=\"com.atguigu.crowd.entity.Department\"&gt; &lt;id column=\"did\" property=\"id\"/&gt; &lt;id column=\"dept_name\" property=\"departmentName\"/&gt; &lt;collection property=\"emps\" select=\"com.atguigu.crowd.mapper.EmployeeMapperPlus.getEmpsByDeptId\" column=\"id\" fetchType=\"lazy\"&gt;&lt;!-- &lt;discriminator javaType=\"\"&gt;--&gt;&lt;!-- &lt;case value=\"\"&gt;&lt;/case&gt;--&gt;&lt;!-- &lt;/discriminator&gt;--&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;!-- public Department getDeptByIdStep(Integer id);--&gt; &lt;select id=\"getDeptByIdStep\" resultMap=\"MyDeptStep\"&gt; select id,dept_name from tb1_dept where id=#&#123;id&#125; &lt;/select&gt;&lt;!-- 扩展，多列的值传递过去： 将多列的值封装map传递 column=\"&#123;key1=column1,key2=column2&#125;\" fetchType=\"lazy\":表示使用延迟加载 -lazy：延迟 -eager：立即 --&gt;&lt;/mapper&gt; 测试映射文件： 12345678910111213141516171819202122232425262728293031323334353637public class MyBatisTest &#123; private SqlSessionFactory getSqlSessionFactory() throws IOException &#123; String resource =\"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); return new SqlSessionFactoryBuilder().build(inputStream); &#125; @Test public void testInnerParam() throws IOException&#123; SqlSessionFactory sqlSessionFactory =getSqlSessionFactory(); SqlSession openSession =sqlSessionFactory.openSession(); try&#123; EmployeeMapperDynamicSQL mapper = openSession.getMapper(EmployeeMapperDynamicSQL.class); Employee employee2= new Employee(); employee2.setLastname(\"%e%\"); List&lt;Employee&gt; list = mapper.getEmpsTestInnerParameter(new Employee()); for (Employee employee: list) &#123; System.out.println(employee); &#125; &#125;finally &#123; &#125; &#125; @Test public void test05() throws IOException&#123; SqlSessionFactory sqlSessionFactory =getSqlSessionFactory(); SqlSession openSession = sqlSessionFactory.openSession(); try &#123; EmployeeMapperPlus mapper = openSession.getMapper(EmployeeMapperPlus.class); Employee empById=mapper.getEmpById(1); System.out.println(empById); &#125;finally &#123; openSession.close(); &#125; &#125; 2、动态SqlEmployeeMapperDynamicSQL 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"com.atguigu.crowd.mapper.EmployeeMapperDynamicSQL\" &gt;&lt;!-- if:判断 choose （when,otherwise):分支选择：带了break的switch——case 如果带了id就用id查，如果带了lastName就用lastName查；只会进入一个 trim 字符串截取（where(封装查询条件)，set（封装修改条件）） foreach --&gt;&lt;!-- 查询员工，要求，携带了哪个字段查询条件就带上这个字段的值 --&gt;&lt;!-- public List&lt;Employee&gt; getEmpsByConditionIf(Employee employee);--&gt; &lt;select id=\"getEmpsByConditionIf\" resultType=\"com.atguigu.crowd.entity.Employee\"&gt; select * from tb1_employee &lt;where&gt; -- test:判断表达式（OGNL) -- c:if test -- 从参数中取值进行判断 -- -- 遇见特殊符号应该去写转义字符 &lt;!-- \" quotation mark &amp;quot; &amp;#34;--&gt; &lt;!-- ' apostrophe &amp;apos; &amp;#39;--&gt; &lt;!-- &amp; ampersand &amp;amp; &amp;#38;--&gt; &lt;!-- &lt; less-than &amp;lt; &amp;#60; --&gt; &lt;!-- &gt; greater-than &amp;gt; &amp;#62;--&gt; &lt;if test=\"id!=null\"&gt; id=#&#123;id&#125; &lt;/if&gt; &lt;if test=\"lastName!=null &amp;amp;&amp;amp; lastName!=&amp;quot;&amp;quot;\"&gt; and last_name like #&#123;lastName&#125; &lt;/if&gt; &lt;if test=\"email!=null and email.trim()!=&amp;quot;&amp;quot;\"&gt; and email=#&#123;email&#125; &lt;/if&gt; -- ognl会进行字符串与数字的转换判断 “0”==0 &lt;if test=\"gender==0 or gender==1\"&gt; and gender=#&#123;gender&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt;&lt;!-- //查询员工，要求，携带了哪个字段查询条件就带上这个字段的值 public List&lt;Employee&gt; getEmpsByConditionTrim(Employee employee);--&gt; &lt;select id=\"getEmpsByConditionTrim\" resultType=\"com.atguigu.crowd.entity.Employee\"&gt; select * from tb1_employee-- 后面多出的and 或者or where 标签不能解决-- prefix=\"\" :前缀，trim 标签体中是整个字符串拼串后的结果-- prefix给拼串后的整个字符串加一个前缀-- prefixOverrides=\"\":-- 前缀覆盖：去掉整个字符串前面多余的字符-- suffix=\"\"：后缀-- suffix 给拼串后的整个字符串加一个后缀-- suffixOverrides=\"\"-- 后缀覆盖：去掉整个字符串后面多余的字符-- 自定义字符串的截取规则&lt;trim prefix=\"where\" suffixOverrides=\"and\"&gt; &lt;if test=\"id!=null\"&gt; id=#&#123;id&#125; and &lt;/if&gt; &lt;if test=\"lastName!=null &amp;amp;&amp;amp; lastName!=&amp;quot;&amp;quot;\"&gt; last_name like #&#123;lastName&#125; and &lt;/if&gt; &lt;if test=\"email!=null and email.trim()!=&amp;quot;&amp;quot;\"&gt; email=#&#123;email&#125; and &lt;/if&gt; -- ognl会进行字符串与数字的转换判断 “0”==0 &lt;if test=\"gender==0 or gender==1\"&gt; gender=#&#123;gender&#125; &lt;/if&gt;&lt;/trim&gt; &lt;/select&gt;&lt;!-- public List&lt;Employee&gt; getEmpByConditionChoose(Employee employee);--&gt;&lt;select id=\"getEmpByConditionChoose\" resultType=\"com.atguigu.crowd.entity.Employee\"&gt; select * from tb1_employee &lt;where&gt;-- 如果带了id就用id查，如果带了lastName就用lastName查；只会进入一个 &lt;choose&gt; &lt;when test=\"id!=null\"&gt; id=#&#123;id&#125; &lt;/when&gt; &lt;when test=\"lastName!=null\"&gt; lastName like #&#123;lastName&#125; &lt;/when&gt; &lt;when test=\"email!=null\"&gt; email=#&#123;email&#125; &lt;/when&gt; &lt;otherwise&gt; gender = 0 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; &lt;!-- public void updateEmp(Employee employee);--&gt;&lt;update id=\"updateEmp\"&gt; update tb1_employee-- set标签使用 &lt;set&gt; &lt;if test=\"lastName!=null\"&gt; last_Name=#&#123;lastName&#125;, &lt;/if&gt; &lt;if test=\"email!-null\"&gt; email=#&#123;email&#125;, &lt;/if&gt; &lt;if test=\"gender!=null\"&gt; gender=#&#123;gender&#125; &lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125;-- trim标签使用:更新拼串 update tb1_employee&lt;trim prefix=\"set\" suffixOverrides=\",\"&gt; &lt;if test=\"lastName!=null\"&gt; last_Name=#&#123;lastName&#125;, &lt;/if&gt; &lt;if test=\"email!-null\"&gt; email=#&#123;email&#125;, &lt;/if&gt; &lt;if test=\"gender!=null\"&gt; gender=#&#123;gender&#125; &lt;/if&gt;&lt;/trim&gt; where id=#&#123;id&#125;&lt;/update&gt;&lt;!-- public List&lt;Employee&gt; getEmpsByConditionForeach(List&lt;Integer&gt; ids);--&gt;&lt;select id=\"getEmpsByConditionForeach\" resultType=\"com.atguigu.crowd.entity.Employee\"&gt; select * from tb1_employee-- collection:指定要遍历的集合-- list类型的参数会特殊处理封装在map中，map的key就叫list-- item ：将当前遍历出的元素赋值给指定的变量-- separator:每个元素的分隔符-- open:遍历出所有结果拼接一个开始的字符-- close:遍历出所有结果拼接一个结束的的字符-- index：索引。遍历list的时候是 index就是索引，item就是当前值-- 遍历map的时候index表示的就是map的key，item就是map的值-- #&#123;变量名&#125;就取出变量的值也就是当前遍历出的元素&lt;foreach collection=\"ids\" item=\"item_id\" separator=\",\" open=\"where id in(\" close=\")\"&gt; #&#123;item_id&#125;&lt;/foreach&gt;&lt;/select&gt;&lt;!-- 批量保存--&gt;&lt;!-- public void addEmps(@Param(\"emps\") List&lt;Employee&gt; emps);--&gt;&lt;!-- 推荐：MySQL下批量保存 可以foreach遍历 mysql支持values(),(),()语法--&gt;&lt;insert id=\"addEmps\"&gt; insert into tb1_employee (-- 引用外部定义的sql &lt;include refid=\"insertColumn\"&gt; &lt;property name=\"testColumn\" value=\"abc\"/&gt; &lt;/include&gt; ) values &lt;foreach collection=\"emps\" item=\"emp\" separator=\",\"&gt; (#&#123;emp.lastName&#125;,#&#123;emp.email&#125;,#&#123;emp.gender&#125;,#&#123;emp.dept.id&#125;) &lt;/foreach&gt;&lt;/insert&gt;&lt;!-- 这种方式需要数据库连接池属性 allowMultiQueries=true这种分号分割多个sql可以用于其他的批量操作（删除、修改）--&gt; &lt;insert id=\"addEmps\"&gt;&lt;foreach collection=\"emps\" item =\"emp\" separator=\";\"&gt; insert into tb1_employee(last_name,email,gender,d_id) values(#&#123;emp.lastName&#125;,#&#123;emp.email&#125;,#&#123;emp.gender&#125;,#&#123;emp.dept.id&#125;);&lt;/foreach&gt; &lt;/insert&gt;&lt;!-- 两个内置参数： 不只是方法传递过来的可以被用来判断，取值。。。 mybatis默认还有两个内置参数： _parameter：代表整个参数 单个参数：_parameter就是这个参数 多个参数：参数会被封装为一个map：_parameter就是代表这个map _databaseId:如果配置了databaseIdProvider标签。 _databaseId就是代表当前数据库的别名oracle --&gt;&lt;!-- public List&lt;Employee&gt; getEmpsTestInnerParameter(Employee employee);--&gt; &lt;select id=\"getEmpsTestInnerParameter\" resultType=\"com.atguigu.crowd.entity.Employee\"&gt;-- bind:可以将OGNL表达式的值绑定到一个变量中，方便来引用这个变量的值&lt;bind name=\"_lastName\" value=\"'_'+lastName+'%'\"&gt;&lt;/bind&gt; &lt;if test=\"_databaseId=='mysql'\"&gt; select * from tb1_employee &lt;if test=\"_parameter!=null\"&gt; where last_name like #&#123;lastName&#125; &lt;/if&gt; &lt;/if&gt; &lt;if test=\"_databaseId=='oracle'\"&gt; select * from tb1_employee &lt;if test=\"_parameter!=null\"&gt; where last_name=#&#123;_parameter.lastName&#125; &lt;/if&gt; &lt;/if&gt; &lt;/select&gt;&lt;!-- 抽取可重用的sql片段，方便后面可引用 1、sql经常将要查询的列名，或者插入用的列名抽取出来方便引用 2、include来引用已经抽取的 3、include还可以自定义一些property、sql标签内部就能使用自定义的属性 include-property：取值的正确方式$&#123;prop&#125;， #&#123;不能使用这种方式&#125;--&gt; &lt;sql id=\"insertColumn\"&gt;&lt;if test=\"_databaseId=='oracle'\"&gt; employee_id,last_name,email&lt;/if&gt; &lt;if test=\"_databaseId=='mysql'\"&gt; last_name,email,gender,d_id,$&#123;testColumn&#125; &lt;/if&gt; &lt;/sql&gt;&lt;/mapper&gt; 测试动态sql： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class MyBatisTest &#123; private SqlSessionFactory getSqlSessionFactory() throws IOException &#123; String resource =\"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); return new SqlSessionFactoryBuilder().build(inputStream); &#125; @Test public void testBatchSave() throws IOException &#123; SqlSessionFactory sqlSessionFactory =getSqlSessionFactory(); SqlSession openSession = sqlSessionFactory.openSession(); try&#123; EmployeeMapperDynamicSQL mapper = openSession.getMapper(EmployeeMapperDynamicSQL.class); List&lt;Employee&gt; emps =new ArrayList&lt;&gt;(); emps.add(new Employee(null,\"ljl\",\"ljl512@163.com\",\"1\", new Department(1))); emps.add(new Employee(null,\"zyx\",\"zyx827@163.com\",\"0\", new Department(2))); mapper.addEmps(emps); openSession.commit(); &#125;finally &#123; openSession.close(); &#125; &#125; @Test public void testDynamicSQL06() throws IOException&#123; SqlSessionFactory sqlSessionFactory =getSqlSessionFactory(); SqlSession openSession = sqlSessionFactory.openSession(); try &#123; EmployeeMapperDynamicSQL mapper = openSession.getMapper(EmployeeMapperDynamicSQL.class); Employee employee = new Employee(3,\"%e%\",\"ljl512@163.com\",null); List&lt;Employee&gt; emps = mapper.getEmpsByConditionIf(employee); for(Employee emp:emps)&#123; System.out.println(emp); &#125; //查询的时候如果某些条件没带可能sql拼装会有问题 //1、给where后面加上1=1，以后的条件都 and xxx //2、mybatis使用where 标签来将所有的查询条件包括在内.mabatis // 就会将where标签中拼接的sql，多出来的and或者or去掉 // where只会去掉第一个多出的and或者or //测试Trim List&lt;Employee&gt; emps2=mapper.getEmpsByConditionTrim(employee); for (Employee emp:emps2) &#123; System.out.println(emp); &#125; //测试choose List&lt;Employee&gt; list = mapper.getEmpByConditionChoose(employee); for (Employee emp:list) &#123; System.out.println(emp); &#125; //测试set标签 mapper.updateEmp(employee); openSession.commit(); mapper.getEmpsByConditionForeach(Arrays.asList(1,2,3,4)); for (Employee emp:list ) &#123; System.out.println(emp); &#125; &#125;finally &#123; openSession.close(); &#125; &#125; 3、缓存机制12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * 两级缓存： * 一级缓存：（本地缓存） sqlsession级别的缓存、一级缓存是一直开启的，SqlSession级别的一个Map *与数据库同一次会话期间查询到的数据会放在本地缓存中 *以后如果需要获取相同的数据，查询从缓存中拿，没必要再去查询**数据库 *一级缓存失效情况（没有使用到当前一级缓存的情况，效果就是，还需要再向数据库发出查询 * 1、sqlsession不同 * 2、sqlsession相同，查询条件不一样（当前一级缓存中还未有数据） * 3、sqlsession相同，两次查询之间执行了增删改操作(这次增删改改变了这条数据） * 4、sqlsession相同，手动清除了一级缓存（缓存清空） * 二级缓存：（全局缓存）：基于namespace级别的缓存，一个namespace对应一个耳机缓存 *工作机制： * 1、一个会话，查询一条数据，这个数据就会被放在当前会话的一级缓存中 * 2、如果会话关闭；一级缓存的数据会被保存到二级缓存中，新的会话查询信息，就可以参照二级缓存中的内容。 * 3、sqlSession===EmployeeMapper==&gt;Employee * DepartmentMapper==Department * 不同namespace查出的数据会放在自己对应的缓存中（map） * 效果：数据会从二级缓存中获取 * 查出的数据都会默认先放在一级缓存中 * 只有会话提交或者关闭以后，一级缓存的数据才会转移到二级缓存中 * 使用： * 1）开启全局二级缓存配置： &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; * 2）去mapper.xml中配置使用二级缓存：&lt;cache&gt;&lt;/cache&gt; &lt;cache eviction=\"FIFO\" flushInterval=\"6000\" readOnly=\"false\" size=\"1024\" type=\"\"&gt;&lt;/cache&gt; &lt;!-- eviction：缓存的回收策略 * LRU-最近最少使用，移除最长时间不被使用的对象 * FIFO - 先进先出，按对象进入缓存的顺序移除它们 * SOFT -软引用 移除基于垃圾回收器状态和软引用规则的对象 * WEAK - 弱引用，要积极地移除基于垃圾收集器状态和若引用规则的对象 * 默认的是LRU flushInterval：缓存刷新间隔 缓存多长时间清空一次，默认不清空，设置一个毫秒值 readOnly：是否只读 true：只读 mybatis认为所有从缓存中获取的数据操作都是只读操作，不会修改数据 mybatis为了加快获取速度，直接会将数据在缓存中的引用交给用户。不安全、速度快 false：非只读：mybatis觉得获取的数据可能会被修改 mybatis会利用序列化&amp;反序列的技术克隆一份新的数据给你。安全，速度慢 size：缓存存放多少元素 type=\"\"：指定自定义缓存的全类名 实现Cache接口即可 --&gt; * 3） 我们的POJO需要实现序列化接口 implements Serializable *和缓存有关的的设置/属性： * 1）cacheEnabled=true，false：关闭缓存（二级缓存关闭）（一级缓存一直可用的） * 2）每个select标签都有useCache=“true”： * false：不使用缓存（一级缓存依然使用，二级缓存不使用） * 【注意】3）每个增删改标签：flushCache=\"true\":(一级二级都会清除) * 增删改执行完成后就会清楚缓存； * 测试:flushCache=\"true\",一级缓存清空了，二级也会被清除 * 查询标签：flushCache=\"false\"; * 如果fulshCache=true，每次查询之前都会清空缓存，缓存是没有被使用的 * 4）sqlSession.clearCache(),只是清除当前session的一级缓存 * 5）loaclCacheScope：本地缓存作用域：（一级缓存session）：当前会话的所有数据保存在会话缓存中； * Statement：可以禁用一级缓存 * 第三方缓存整合： * 1）导入第三方缓存包即可 * 2）导入第三方缓存整合的适配器，官方 * 3）mapper、xml中使用自定义的缓存 * &lt;cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"&gt;&lt;/cache&gt; */ 测试二级缓存： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class MyBatisTest &#123; private SqlSessionFactory getSqlSessionFactory() throws IOException &#123; String resource =\"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); return new SqlSessionFactoryBuilder().build(inputStream); &#125; public void testSecondLevelCache() throws IOException &#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); SqlSession openSession = sqlSessionFactory.openSession(); SqlSession openSession2 = sqlSessionFactory.openSession(); try &#123; //1、 EmployeeMapperPlus mapper = openSession.getMapper(EmployeeMapperPlus.class); EmployeeMapperPlus mapper2 = openSession2.getMapper(EmployeeMapperPlus.class); Employee emp01 = mapper.getEmpById(1); System.out.println(emp01); openSession.close(); //第二次查询是从二级缓存中拿到的数据，并没有发送新的sql Employee emp02 = mapper2.getEmpById(1); System.out.println(emp02); openSession2.close(); &#125;finally &#123; &#125; &#125; public void testFirstLevelCache() throws IOException&#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); SqlSession openSession = sqlSessionFactory.openSession(); try&#123; EmployeeMapperPlus mapper = openSession.getMapper(EmployeeMapperPlus.class); Employee emp01=mapper.getEmpById(1); System.out.println(emp01);// //xxx// Employee emp02=mapper.getEmpById(1);//一条sql// System.out.println(emp02);// System.out.println(emp01==emp02);//true //1、sqlsession不同，// SqlSession openSession2 = sqlSessionFactory.openSession();// EmployeeMapperPlus mapper2 = openSession2.getMapper(EmployeeMapperPlus.class);// Employee emp02=mapper2.getEmpById(1);// 2、sqlsession相同，查询条件不一样 Employee emp02=mapper.getEmpById(3); System.out.println(emp01); System.out.println(emp02); System.out.println(emp01==emp02);//true// 3、sqlsession相同，两次查询之间执行了增删改操作 mapper.addEmp(new Employee(null,\"testCache\",\"cache\",\"1\")); System.out.println(\"数据增加成功\");// 4、sqlsession相同，手动清除了一级缓存（缓存清空） openSession.clearCache(); &#125;finally &#123; openSession.close(); &#125; &#125;&#125;","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://lijiale96.github.io/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://lijiale96.github.io/tags/MyBatis/"}]},{"title":"SSM","slug":"SSM","date":"2020-05-21T09:40:32.000Z","updated":"2020-05-24T15:00:09.294Z","comments":true,"path":"2020/05/21/SSM/","link":"","permalink":"https://lijiale96.github.io/2020/05/21/SSM/","excerpt":"","text":"一、mybatis（1-75）Day 1:mybatis入门概述环境搭建入门案例自定义mabatis框架（为了了解mybatis的执行细节）Day 2：基本使用单表crud操作多参与返回值dao编写配置的细节；几个标签的使用Day 3：深入与多表连接池事务控制与设计的方法多表查询：一对多，多对一，多对多Day 4：缓存与注解开发加载时机，查询的时机一级缓存，二级缓存注解开发：单表crud，多表查询 二、Spring（76-158）Day1： 框架概述和基于XML的IOC配置Day 2：基于注解的IOC和ioc案例Day 3：aop和基于XML及注解的AOP配置Day 4：jdbc Temlate以及spring事务控制 三、Spring MVC（159-212）Day 1：基本概念入口请求参数的绑定常用注解Day 2：响应数据和结果视图文件上传异常处理Day 3：搭建整合环境spring框架代码的编写spring整合springMVC框架Spring整合mybatis框架 四、oracle（213-245）基本操作 五、maven高级（246-263）Day1 ：基础web工程做数据查询工程拆分与聚合的思想把web工程修改成maven拆分与聚合的形式私服（远程仓库）安装第三方jar包。安装到本地/远程仓库 六、SSM整合（264-360）Day 1：SVN基础Visual SVN、Tortoise SVNIDEA下使用SVNSVN规范AdminLTE介绍与使用SSM综合练习Day 2：数据库与表结构SSM整合产品操作：查询、添加订单操作：所有/分页查询Day 3：订单详情查询权限操作用户操作springSecurity源码分析Day 4：作业角色详情查询，删除操作资源权限详情查询，删除操作Day 5：用户关联角色操作角色关联权限操作方法级权限控制AOP日志","categories":[{"name":"Spring","slug":"Spring","permalink":"https://lijiale96.github.io/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://lijiale96.github.io/tags/Spring/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://lijiale96.github.io/tags/MyBatis/"},{"name":"Spring MVC","slug":"Spring-MVC","permalink":"https://lijiale96.github.io/tags/Spring-MVC/"}]},{"title":"Spring Boot 六","slug":"Spring-Boot 六","date":"2020-05-21T09:40:32.000Z","updated":"2020-05-23T03:59:52.819Z","comments":true,"path":"2020/05/21/Spring-Boot 六/","link":"","permalink":"https://lijiale96.github.io/2020/05/21/Spring-Boot%20%E5%85%AD/","excerpt":"SpringBoot与数据访问1、JDBC1234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 123456spring: datasource: username:root password:520512 uri:jdbc:mysql://192.168.1.106:3306/jdbc driver-class-name: com.mysql.jdbc.Driver 效果：默认是用 hikari.HikariDataSource 作为数据源数据源的相关配置都在DataSourceProperties 里面","text":"SpringBoot与数据访问1、JDBC1234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 123456spring: datasource: username:root password:520512 uri:jdbc:mysql://192.168.1.106:3306/jdbc driver-class-name: com.mysql.jdbc.Driver 效果：默认是用 hikari.HikariDataSource 作为数据源数据源的相关配置都在DataSourceProperties 里面 自动配置原理：\\org\\springframework\\boot\\spring-boot-autoconfigure\\2.3.0.RELEASE\\spring-boot-autoconfigure-2.3.0.RELEASE.jar!\\org\\springframework\\boot\\autoconfigure\\jdbc 1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池spring.datasource.type指定自定义的数据源类型 2、Springboot默认可以支持org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource 3、自定义数据源类型 1234567891011121314151617@Configuration( proxyBeanMethods = false ) @ConditionalOnMissingBean(&#123;DataSource.class&#125;) @ConditionalOnProperty( name = &#123;\"spring.datasource.type\"&#125; ) static class Generic &#123; Generic() &#123; &#125; @Bean DataSource dataSource(DataSourceProperties properties) &#123; //使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且相关属性 return properties.initializeDataSourceBuilder().build(); &#125; &#125; 4、DataSourceInitial 默认只需要将文件命名为： 12345schema-*.sql\\data-*.sql默认规则：schema.sql，schema-all。sql可以使用 schema: - classpath:department.sql 5、操作数据：自动配置了JdbcTemplateConfiguration操作数据库 连接不上的原因：注：mysql -hlocalhost -uroot -pshow variables like’%time_zone’;set global time_zone = ‘+8:00’; 2、整合Druid数据源导入druid数据源 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.atguigu.springboot.config;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.support.http.StatViewServlet;import com.alibaba.druid.support.http.WebStatFilter;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.servlet.ServletRegistration;import javax.sql.DataSource;import java.util.Arrays;import java.util.HashMap;import java.util.Map;@Configurationpublic class DruidConfig &#123;@ConfigurationProperties(prefix = \"spring.datasource\" ) @Bean public DataSource druid()&#123; return new DruidDataSource();&#125;//配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(),\"/druid/*\"); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(\" loginUsername\",\"admin\"); initParams.put(\" loginPassword\",\"123456\"); initParams.put(\" allow\",\"\");//默认允许所有访问 initParams.put(\" deny\",\"192.168.1.106\");//默认允许所有访问 bean.setInitParameters(initParams); return bean; &#125; //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean= new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams =new HashMap&lt;&gt;(); initParams.put(\"exclusions\",\"*.js,*.css,/druid/*\"); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList(\"/*\")); return bean;&#125;&#125; 3、整合MyBatis12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.2&lt;/version&gt; &lt;/dependency&gt; 步骤：1）配置数据源相关属性2）给数据库建表3）创建JavaBean 4）注解版 12345678910111213141516171819//指定这是一个操作数据库的mapper@Mapperpublic interface DepartmentMapper &#123; @Select(\"select * from department where id=#&#123;id&#125;\") public Department getDeptById(Integer id); @Delete(\"deletet from department where id=#&#123;id&#125;\") public int deleteDeptById(Integer id); @Options(useGeneratedKeys = true,keyProperty = \"id\") @Insert(\"insert into department(departmentName) values(#&#123;departmentName&#125;)\") public int insertDept(Department department); @Update(\"upodate department set departmentName=#&#123;departmentName&#125; where id=#&#123;id&#125;\") public int updateDept(Department department);&#125; 问题：自定义MyBatis的配置规则;给容器中添加一个ConfigurationCustomizer 12345678910111213141516@org.springframework.context.annotation.Configurationpublic class MyBatisConfig &#123; @Bean public ConfigurationCustomizer configurationCustomizer() &#123; return new ConfigurationCustomizer() &#123; @Override public void customize(Configuration configuration) &#123; configuration.setMapUnderscoreToCamelCase(true); &#125; &#125;; &#125;&#125; 12使用MapperScan批量扫描所有的Mapper接口@MapperScan(value &#x3D; &quot;com.atguigu.springboot.mapper&quot;) 5）配置文件版 123mybatis: config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置 mapper-locations: classpath:mybatis/mapper/*.xml 指定sql映射文件的位置","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lijiale96.github.io/categories/Spring-Boot/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://lijiale96.github.io/tags/MyBatis/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lijiale96.github.io/tags/Spring-Boot/"},{"name":"JDBC","slug":"JDBC","permalink":"https://lijiale96.github.io/tags/JDBC/"}]},{"title":"Spring Boot 五","slug":"Spring-Boot 五","date":"2020-05-19T09:40:32.000Z","updated":"2020-05-21T06:46:57.072Z","comments":true,"path":"2020/05/19/Spring-Boot 五/","link":"","permalink":"https://lijiale96.github.io/2020/05/19/Spring-Boot%20%E4%BA%94/","excerpt":"Docker1、简介Docker是一个开源的应用容器引擎 Docker支持软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者开源直接使用这个镜像； 运行中的这个镜像称为容器，容器启动是非常快速的 容器完全使用沙箱机制，相互之间不会有任何接口","text":"Docker1、简介Docker是一个开源的应用容器引擎 Docker支持软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者开源直接使用这个镜像； 运行中的这个镜像称为容器，容器启动是非常快速的 容器完全使用沙箱机制，相互之间不会有任何接口 2、核心概念docker主机（Host）：安装Docker程序的机器docker客户端（Client）：连接docker主机进行操作docker仓库（Registry）：用来保存各种打包好的环境镜像docker镜像（Images）：软件打包好的镜像；放在docker仓库中docker容器（Container）：镜像启动后的实例称为一个容器，容器是独立运行的一个或一组应用使用Docker的步骤：1）安装Docker2）去Docker仓库找到这个软件对应的镜像3）使用Docker运行这个镜像，这个镜像就会生成一个Docker容器4）对容器的启动停止就是对软件的启动停止 3、安装Docker1）、VMWare、VirtualBox（安装）； 2）、VirtualBox软件菜单-&gt;管理-&gt;导入虚拟电脑-&gt;选择虚拟机文件centos7-atguigu.ova；–&gt;勾选重新初始化所有网卡的Mac地址（新安装开启bios虚拟设置） 3）、双击启动linux虚拟机;使用 root/ 123456登陆 4）、使用客户端连接linux服务器进行命令操作； 5）、设置虚拟机网络； 桥接网络===选好网卡====接入网线； 6）、设置好网络以后使用命令重启虚拟机的网络 service network restart7）、查看linux的ip地址 ip addr 8）、使用客户端连接linux； 4、在linux虚拟机上安装docker步骤： 1、检查内核版本，必须是3.10及以上uname -r2、安装dockeryum install docker3、输入y确认安装4、启动docker[root@localhost ~]# systemctl start docker[root@localhost ~]# docker -vDocker version 1.12.6, build 3e8e77d/1.12.65、开机启动docker[root@localhost ~]# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.6、停止dockersystemctl stop docker 5、Docker常用命令&amp;操作1）、镜像操作 操作 命令 说明 检索 docker search 关键字 eg：docker search redis 我们经常去docker hub上检索镜像的详细信息，如镜像的TAG。 拉取 docker pull 镜像名:tag :tag是可选的，tag表示标签，多为软件的版本，默认是latest 列表 docker images 查看所有本地镜像 删除 docker rmi image-id 删除指定的本地镜像 镜像仓库地址：https://hub.docker.com/ 2）、容器操作软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）； 步骤： 1、搜索镜像[root@localhost ~]# docker search tomcat2、拉取镜像[root@localhost ~]# docker pull tomcat3、根据镜像启动容器docker run –name mytomcat -d tomcat:latest4、docker ps查看运行中的容器5、 停止运行中的容器docker stop 容器的id6、查看所有的容器docker ps -a7、启动容器docker start 容器id8、删除一个容器 docker rm 容器id9、启动一个做了端口映射的tomcat[root@localhost ~]# docker run -d -p 8888:8080 tomcat-d：后台运行-p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口 10、为了演示简单关闭了linux的防火墙service firewalld status ；查看防火墙状态service firewalld stop：关闭防火墙11、查看容器的日志docker logs container-name/container- 3）mysql123456789101112[root@aubin lijiale]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESebe06e965eec mysql &quot;docker-entrypoint...&quot; 11 seconds ago Exited (1) 8 seconds ago mysql01&#x2F;&#x2F;错误日志[root@aubin lijiale]# docker logs ebe06e965eec2020-05-20 15:11:25+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.20-1debian10 started.2020-05-20 15:11:25+00:00 [Note] [Entrypoint]: Switching to dedicated user &#39;mysql&#39;2020-05-20 15:11:25+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.20-1debian10 started.2020-05-20 15:11:25+00:00 [ERROR] [Entrypoint]: Database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD三个参数必须指定一个 正确启动做了端口映射 12345[root@aubin lijiale]# docker run -p 3306:3306 --name mysql01 -e MYSQL_ROOT_PASSWORD&#x3D;520512 -d mysql2bb309a8953d7f0b35c2de12b3e68c3d87258e729571cb4cd98554e09ab6290a[root@aubin lijiale]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES2bb309a8953d mysql &quot;docker-entrypoint...&quot; 15 seconds ago Up 13 seconds 0.0.0.0:3306-&gt;3306&#x2F;tcp, 33060&#x2F;tcp mysql01 几个其他高级操作 1234567$ docker run --name some-mysql -v &#x2F;my&#x2F;custom:&#x2F;etc&#x2F;mysql&#x2F;conf.d -e MYSQL_ROOT_PASSWORD&#x3D;my-secret-pw -d mysql:tag把主机的my&#x2F;custom文件挂载到mysqldocker容器的&#x2F;etc&#x2F;mysql&#x2F;conf.d文件夹里改mysql配置文件就只需要把mysql配置文件放在$ docker run --name some-mysql -e MYSQL_ROOT_PASSWORD&#x3D;my-secret-pw -d mysql:tag --character-set-server&#x3D;utf8mb4 --collation-server&#x3D;utf8mb4_unicode_ci指定mysql的一些参数 连接多个数据库 123456[root@aubin lijiale]# docker run -p 3307:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD&#x3D;520512 -d mysql --character-set-server&#x3D;utf8mb4 --collation-server&#x3D;utf8mb4_unicode_ci627d62a671190d70a1f4f0570493516b759e4fea3a7d2c74738e2d187bd53431[root@aubin lijiale]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES627d62a67119 mysql &quot;docker-entrypoint...&quot; 9 seconds ago Up 7 seconds 33060&#x2F;tcp, 0.0.0.0:3307-&gt;3306&#x2F;tcp mysql022bb309a8953d mysql &quot;docker-entrypoint...&quot; 11 minutes ago Up 11 minutes 0.0.0.0:3306-&gt;3306&#x2F;tcp, 33060&#x2F;tcp mysql01","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lijiale96.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lijiale96.github.io/tags/Spring-Boot/"},{"name":"Docker","slug":"Docker","permalink":"https://lijiale96.github.io/tags/Docker/"}]},{"title":"Spring Boot 四","slug":"Spring-Boot 四","date":"2020-05-12T09:40:32.000Z","updated":"2020-05-19T09:14:19.283Z","comments":true,"path":"2020/05/12/Spring-Boot 四/","link":"","permalink":"https://lijiale96.github.io/2020/05/12/Spring-Boot%20%E5%9B%9B/","excerpt":"WEB开发1、简介使用SpringBoot：1）创建SpeingBoot应用，选择相应的模块2）SpringBoot已经默认这些场景配置好了，只需要在配置文本中指定少量配置就可以运行起来了3）编写编写了业务代码 自动配置原理？这个场景SpringBoot我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？ 12xxxAutoConfiguration:帮我们个容器中自动配置组件xxxProperties：配置类来封装配置文件的内容","text":"WEB开发1、简介使用SpringBoot：1）创建SpeingBoot应用，选择相应的模块2）SpringBoot已经默认这些场景配置好了，只需要在配置文本中指定少量配置就可以运行起来了3）编写编写了业务代码 自动配置原理？这个场景SpringBoot我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？ 12xxxAutoConfiguration:帮我们个容器中自动配置组件xxxProperties：配置类来封装配置文件的内容 2、SpringBoot对静态资源的映射规则123456@ConfigurationProperties( prefix = \"spring.resources\", ignoreUnknownFields = false)public class ResourceProperties &#123;//可以设置和资源有关的参数，缓存时间 123456789101112131415161718192021222324252627 public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug(\"Default resource handling disabled\"); &#125; else &#123; Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); if (!registry.hasMappingForPattern(\"/webjars/**\")) &#123; this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]&#123;\"/webjars/**\"&#125;).addResourceLocations(new String[]&#123;\"classpath:/META-INF/resources/webjars/\"&#125;).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]&#123;staticPathPattern&#125;).addResourceLocations(WebMvcAutoConfiguration.getResourceLocations(this.resourceProperties.getStaticLocations())).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; &#125; &#125; //配置欢迎页映射 @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) &#123; WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping(new TemplateAvailabilityProviders(applicationContext), applicationContext, this.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); welcomePageHandlerMapping.setInterceptors(this.getInterceptors(mvcConversionService, mvcResourceUrlProvider)); welcomePageHandlerMapping.setCorsConfigurations(this.getCorsConfigurations()); return welcomePageHandlerMapping; &#125;//配置喜欢的图标 1）所有/webjars/,都去classpath：/META-INF/resource/webjars/找资源；webjars：以jar包的方式引入静态资源http://www.webjars.org/ localhost:8080/webjars/jquery/3.5.1/jquery.js 123456&lt;!--引入jquery-webjar--&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; 2）”/**”访问当前项目的任何资源，（静态资源的文件夹） 12\"classpath:/META-INF/resources/\", \"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\"\"/\":当前项目的根路径 localhost：8080/abc=== 去静态资源文件夹里面找abc 3）欢迎页，静态资源文件夹下的所有index.html页面;被”/“映射*localhost：8080/ 找index4）所有的*/favicon.ico 都是在静态资源文件下找 3、模板引擎JSP、Velocity、Freemarker、Thymeleaf SpringBoot推荐的Thymeleaf语法更简单，功能更强大 1、引入thymeleaf；12345678910 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt;切换thymeleaf版本 &lt;properties&gt; &lt;thymeleaf.version&gt;3.0.11.RELEASE&lt;/thymeleaf.version&gt;&lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本--&gt; &lt;thymeleaf-layout-dialect.version&gt;2.4.1&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; 2、Thymeleaf使用&amp;语法12345678@ConfigurationProperties( prefix = \"spring.thymeleaf\")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING; public static final String DEFAULT_PREFIX = \"classpath:/templates/，\"; public static final String DEFAULT_SUFFIX = \".html\"; //只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染； 使用：1、导入thymeleaf的名称空间 1&lt;html lang=\"en\" xmlns:th=\"https://www.thymeleaf.org\"&gt; 2、使用thymeleaf语法 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"https://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;成功!&lt;/h1&gt; &lt;div th:text=\"$&#123;hello&#125;\"&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、语法规则1）th:text：改变当前元素里面的文本内容th:任意html属性；来替换原生属性的值 2）表达式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Simple expressions:Variable Expressions: $&#123;...&#125; #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object.Selection Variable Expressions: *&#123;...&#125; #execInfo : information about the template being processed. #messages : methods for obtaining externalized messages inside variables expressions, in the same way as thewould be obtained using #&#123;…&#125; syntax. #uris : methods for escaping parts of URLs&#x2F;URIs P#conversions : methods for executing the configured conversion service (if any). #dates : methods for java.util.Date objects: formatting, component extraction, etc. #calendars : analogous to #dates , but for java.util.Calendar objects. #numbers : methods for formatting numeric objects. #strings : methods for String objects: contains, startsWith, prepending&#x2F;appending, etc. #objects : methods for objects in general. #bools : methods for boolean evaluation. #arrays : methods for arrays. #lists : methods for lists. #sets : methods for sets. #maps : methods for maps. #aggregates : methods for creating aggregates on arrays or collections. #ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration).Message Expressions: #&#123;...Link URL Expressions: @&#123;...&#125;Fragment Expressions: ~&#123;...&#125;Literals(字面量) Text literals: &#39;one text&#39; , &#39;Another one!&#39; ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations:(文本操作) String concatenation: + Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations:（数学运算） Binary operators: + , - , * , &#x2F; , % Minus sign (unary operator): - Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , not Comparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;&#x3D; , &lt;&#x3D; ( gt , lt , ge , le ) Equality operators: &#x3D;&#x3D; , !&#x3D; ( eq , ne ) Conditional operators:（条件运算） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue) Special tokens:No-Operation: _ 4、SpringMvc自动配置Spring Boot自动配置好了SpringMVC以下是SpringBoot对SpringMVC的默认: Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了ViewResolver(视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？）) ContentnegotiatingViewResolver:组合所有的视图解析器的 如何定制:我们可以自己个容器中添加一个视图解析器；自动的将其组合进来 Support for serving static resources, including support for WebJars (covered later in this document)).静态资源文件夹路径.webjars 自动注册了Automatic registration of Converter, GenericConverter, and Formatter beans. Converter：转换器；public String hello（User user）：类型转换使用Converter Formatter 格式化器；自己添加的格式化器转化器，我们只需要放在容器当中即可 Support for HttpMessageConverters (covered later in this document). HttpMessageConverters：SpringMVC用来转换Http请求和响应的 HttpMessageConverters是容器中确定；获取所有的HttpmessageConverter；自己给容器中添加HttpMessageConverter，只需将自己的组件注册容器中（@Bean，@Component） Automatic registration of MessageCodesResolver (covered later in this document). 定义错误代码生成规则 Static index.html support.静态首页访问 Custom Favicon support (covered later in this document). Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document). 我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；添加到容器12初始化WebDataBinder；请求数据&#x3D;&#x3D;&#x3D;&#x3D;JavaBean； org\\springframework\\boot\\autoconfigure\\web：web的所有自动场景 If you want to keep those Spring Boot MVC customizations and make more MVC customizations (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you want to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, and still keep the Spring Boot MVC customizations, you can declare a bean of type WebMvcRegistrations and use it to provide custom instances of those components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc, or alternatively add your own @Configuration-annotated DelegatingWebMvcConfiguration as described in the Javadoc of @EnableWebMvc. 2、扩展SpringMVC1234567&lt;mvc:view-controller path=\"/hello\" view-name=\"success\" &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/hello\"/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 编写一个配置类（@Configuration），是WebMvcConfigurer（WebMvcConfigurerAdapter）类型；不能标注@EnableWebMvc既保留了所有的自动配置，也能用我们扩展的配置 123456789//使用WebMvcConfigurer可以扩展SpringMVC的功能@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; //浏览器发送/atguigu 请求来到success registry.addViewController(\"/atguigu\").setViewName(\"success\"); &#125;&#125; 原理：1）WebMvcAutoConfiguration是SpringMVC的自动配置类2）在做其他自动配置时会导入 1234567891011121314151617181920212223242526public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration implements ResourceLoaderAware &#123; private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); public DelegatingWebMvcConfiguration() &#123; &#125; @Autowired( required = false ) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); //一个参考实现类，将所有的是WebMvcConfigurer相关配置都来一起调用 //public void addViewControllers(ViewControllerRegistry registry) &#123; // Iterator var2 = this.delegates.iterator(); // while(var2.hasNext()) &#123; //WebMvcConfigurer delegate = (WebMvcConfigurer)var2.next(); // delegate.addViewControllers(registry); &#125; &#125; &#125; &#125; 3）容器中所有的WebMvcConfigurer都会一起起作用4）我们的配置类也会被调用效果：SpringMVC的自动配置和我们扩展配置都会起作用 3、全面接管SpringMVC；SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配；所有的SpringMVC的自动配置全部失效了我们需要在配置类中添加@EnableWebMvc即可 123456789101112131415161718package com.atguigu.springboot.config;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;//使用WebMvcConfigurer可以扩展SpringMVC的功能@EnableWebMvc@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; //浏览器发送/atguigu 请求来到success registry.addViewController(\"/atguigu\").setViewName(\"success\"); &#125;&#125; 原理：为什么@EnableWebMvc即可自动配置就失效了1）@EnableWebMvc的核心 12@Import(&#123;DelegatingWebMvcConfiguration.class&#125;)public @interface EnableWebMvc &#123; 2） 1234@Configuration( proxyBeanMethods = false)public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; 3） 12345678910111213@Configuration( proxyBeanMethods = false)@ConditionalOnWebApplication( type = Type.SERVLET)@ConditionalOnClass(&#123;Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class&#125;)//容器中没有这个组件的时候，自动配置类才生效@ConditionalOnMissingBean(&#123;WebMvcConfigurationSupport.class&#125;)@AutoConfigureOrder(-2147483638)@AutoConfigureAfter(&#123;DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class&#125;)public class WebMvcAutoConfiguration &#123; 4）@EnableWebMvc将WebMvcConfigurationSupport组件导入进来5）导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能 5、如何修改SpringBoot的默认配置模式：1）SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean，@Component）如果有就用用户配置的，如果没有即，才自动配偶，如果有些组件可以有很多个（ViewResolver）将用户配置的和自己默认的组合起来2）在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置3）在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置 6、RestfulCRUD1）默认访问首页 1234567891011121314151617181920212223242526272829303132333435//@EnableWebMvc 全面接管，所有ｓｐｒｉｎｇｍｖｃ自动配置失效 //使用WebMvcConfigurerAdapter 应该已废弃，可用接口 可以来扩展SpringMVC的功能@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; public void addViewControllers(ViewControllerRegistry registry) &#123;// 浏览器发请求 ／atguigu 请求来到success registry.addViewController(\"/atguigu\").setViewName(\"guigu\"); &#125; @Bean public WebMvcConfigurerAdapter webMvcAutoConfigurationAdapter()&#123; WebMvcConfigurerAdapter adapter= new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123;// super.addViewControllers(registry); registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/index.html\").setViewName(\"login\"); registry.addViewController(\"/main.html\").setViewName(\"dashboard\"); &#125; //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123;// super.addInterceptors(registry); //拦截所有请求，排除登录页面 / 登录验证请求 //SpringBoot已经做好了静态资源映射， *.css *.js registry.addInterceptor(new LoginHandlerIntercepter()).addPathPatterns(\"/**\") .excludePathPatterns(\"/index.html\",\"/\",\"/user/login\"); &#125; &#125;; return adapter; &#125; 2）国际化（1）编写国际化配置文件（2）使用resourceBundleMessageSource管理国际化资源文件（3）在页面使用fmt:message取出国际化内容 步骤：（1）编写国际化配置文件，抽取页面需要显示的国际化消息 （2）SpringBoot自动配置好了管理国际化资源文化的组件 123456789101112131415161718192021222324252627282930@Bean @ConfigurationProperties( prefix = \"spring.messages\" ) public MessageSourceProperties messageSourceProperties() &#123; return new MessageSourceProperties(); &#125; @Bean public MessageSource messageSource(MessageSourceProperties properties) &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(properties.getBasename())) &#123; //设置国际化资源文件的基础名（去掉语言国家代码的） messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(properties.getBasename()))); &#125; if (properties.getEncoding() != null) &#123; messageSource.setDefaultEncoding(properties.getEncoding().name()); &#125; messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale()); Duration cacheDuration = properties.getCacheDuration(); if (cacheDuration != null) &#123; messageSource.setCacheMillis(cacheDuration.toMillis()); &#125; messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat()); messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage()); return messageSource; &#125; （3）去页面获取国际化的值 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;meta name=\"description\" content=\"\"&gt; &lt;meta name=\"author\" content=\"\"&gt; &lt;title&gt;Signin Template for Bootstrap login&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href=\"asserts/css/bootstrap.min.css\" th:href=\"@&#123;/webjars/bootstrap/4.5.0/css/bootstrap.css&#125;\" rel=\"stylesheet\"&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href=\"asserts/css/signin.css\" th:href=\"@&#123;/asserts/css/signin.css&#125;\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body class=\"text-center\"&gt; &lt;form class=\"form-signin\" action=\"dashboard.html\" th:action=\"@&#123;user/login&#125;\" method=\"post\"&gt; &lt;img class=\"mb-4\" src=\"asserts/img/bootstrap-solid.svg\" th:src=\"@&#123;/asserts/img/bootstrap-solid.svg&#125;\" alt=\"\" width=\"72\" height=\"72\"&gt; &lt;p style=\"color: red;\" th:text=\"$&#123;msg&#125;\" th:if=\"$&#123;not #strings.isEmpty(msg)&#125;\"&gt;&lt;/p&gt; &lt;h1 class=\"h3 mb-3 font-weight-normal\" th:text=\"#&#123;login.tip&#125;\"&gt;Please sign in&lt;/h1&gt; &lt;label class=\"sr-only\" th:text=\"#&#123;login.username&#125;\"&gt;Username&lt;/label&gt; &lt;input type=\"text\" name=\"username\" class=\"form-control\" placeholder=\"Username\" th:placeholder=\"#&#123;login.username&#125;\" required=\"\" autofocus=\"\"&gt; &lt;label class=\"sr-only\" th:text=\"#&#123;login.password&#125;\"&gt;Password&lt;/label&gt; &lt;input type=\"password\" name=\"password\" class=\"form-control\" placeholder=\"Password\" th:placeholder=\"#&#123;login.password&#125;\" required=\"\"&gt; &lt;div class=\"checkbox mb-3\"&gt; &lt;label&gt; &lt;input type=\"checkbox\" value=\"remember-me\" &gt;[[#&#123;login.remember&#125;]] &lt;/label&gt; &lt;/div&gt; &lt;button class=\"btn btn-lg btn-primary btn-block\" th:text=\"#&#123;login.btn&#125;\" type=\"submit\"&gt;Sign in&lt;/button&gt; &lt;p class=\"mt-5 mb-3 text-muted\"&gt;© 2017-2018&lt;/p&gt; &lt;a class=\"btn btn-sm\" th:href=\"@&#123;/index.html(l='zh_CN')&#125;\"&gt;中文&lt;/a&gt; &lt;a class=\"btn btn-sm\" th:href=\"@&#123;/index.html(l='en_US')&#125;\"&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 效果：根据浏览器语言设置的信息切换了国际化 原理： 国际化locale(区域信息对象)；LocaleResolver（获取区域信息对象） 12345678910111213141516@Bean @ConditionalOnMissingBean @ConditionalOnProperty( prefix = \"spring.mvc\", name = &#123;\"locale\"&#125; ) public LocaleResolver localeResolver() &#123; if (this.mvcProperties.getLocaleResolver() == org.springframework.boot.autoconfigure.web.servlet.WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; else &#123; AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; &#125; &#125; 默认的是根据请求头带来的区域信息获取Locale进行国际化 3）登陆开发期间模板引擎修改以后，要实时生效（1）禁用模板引擎的缓存 12#禁用themleaf缓存 页面修改完成以后ctrl+f9spring.thymeleaf.cache=false （2）页面修改完成以后ctrl+f9；重新编译 登陆错误消息的显示 1&lt;p style=\"color: red;\" th:text=\"$&#123;msg&#125;\" th:if=\"$&#123;not #strings.isEmpty(msg)&#125;\"&gt;&lt;/p&gt; 4）拦截器进行登陆检查 12345678910111213141516171819202122232425262728293031323334353637package com.atguigu.springboot.component;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;//拦截器，登录检查public class LoginHandlerIntercepter implements HandlerInterceptor &#123; //目标方法执行前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Object user = request.getSession().getAttribute(\"loginUser\"); if (user == null) &#123; //未登录，返回登录页面 request.setAttribute(\"msg\",\"没有权限\"); request.getRequestDispatcher(\"/index.html\").forward(request,response); return false; &#125;else &#123; //已登录，放行 return true; &#125; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 5）CRUD-员工列表实验要求：（1）RestfulCRUD满足Rest风格；URI：/资源名称/资源标识 HTTP请求方式区分对资源CRUD操作 普通CRUD（uri） RestfulCRUD 查询 getEmp emp-GET 添加 addEmp?xxx emp–POST 修改 updateEmp?id=xxx&amp;xxx=xx emp/(id)–put 删除 deleteEmp?id=1 emp/(id)—DELETE （2）实验请求架构 请求URI 请求方式 查询所有员工 emps GET 查询某个员工（来到修改页面） emp/1 GET 来添加页面 emp GET 添加员工 emp POST 来到修改页面（查出员工进行信息回显） emp/1 PUT 修改页面 emp PUT 删除员工 emp/1 DELETE （3）员工列表thymeleaf公共页面元素抽取 12345678910111213141、抽取公共片段&lt;div th:fragment=\"copy\"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;2、引入公共片段&lt;div th:insert=\"~&#123;footer :: copy&#125;\"&gt;&lt;/div&gt;~&#123;templatename::selector&#125;：模板名::选择器~&#123;templatename::fragmentname&#125; 模板名::片段名3、默认效果insert的功能片段在div标签中如果使用th:insert等属性进行引入，可以不用写~&#123;&#125;：行内写法可以加上：[[~&#123;&#125;]];[(~&#123;&#125;)]; 三种引入功能片段的th数 th:insert：将公共片段整个插入到声明引入的元素中th:replace：将声明引入的元素替换为公共片段th:include：将引入的片段内容包含近整个标签 1234567891011121314151617181920212223&lt;footer th:fragment=\"copy\"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;引入方式&lt;div th:insert=\"footer :: copy\"&gt;&lt;/div&gt;&lt;div th:replace=\"footer :: copy\"&gt;&lt;/div&gt;&lt;div th:include=\"footer :: copy\"&gt;&lt;/div&gt;效果&lt;div&gt;&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;/div&gt;&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;div&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 引入片段的时候传入参数 6）添加员工 12345678910111213141516171819202122232425262728293031323334353637&lt;form th:action=\"@&#123;/emp&#125;\" method=\"post\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input name=\"lastName\" type=\"text\" class=\"form-control\" placeholder=\"zhangsan\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input name=\"email\" type=\"email\" class=\"form-control\" placeholder=\"zhangsan@atguigu.com\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\"&gt; &lt;label class=\"form-check-label\"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\"&gt; &lt;label class=\"form-check-label\"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;department&lt;/label&gt; &lt;select class=\"form-control\" name=\"department.id\"&gt;&lt;!-- &lt;option&gt;1&lt;/option&gt;--&gt;&lt;!-- &lt;option&gt;2&lt;/option&gt;--&gt;&lt;!-- &lt;option&gt;3&lt;/option&gt;--&gt;&lt;!-- &lt;option&gt;4&lt;/option&gt;--&gt;&lt;!-- &lt;option&gt;5&lt;/option&gt;--&gt; &lt;option th:each=\"dept:$&#123;depts&#125;\" th:value=\"$&#123;dept.id&#125;\" th:text=\"$&#123;dept.departmentName&#125;\"&gt;&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input name=\"birth\" type=\"text\" class=\"form-control\" placeholder=\"1996-05-12\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;添加&lt;/button&gt; &lt;/form&gt; 参考模板 123456789101112131415161718192021222324252627282930&lt;form&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleFormControlInput1\"&gt;Email address&lt;/label&gt; &lt;input type=\"email\" class=\"form-control\" id=\"exampleFormControlInput1\" placeholder=\"name@example.com\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleFormControlSelect1\"&gt;Example select&lt;/label&gt; &lt;select class=\"form-control\" id=\"exampleFormControlSelect1\"&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleFormControlSelect2\"&gt;Example multiple select&lt;/label&gt; &lt;select multiple class=\"form-control\" id=\"exampleFormControlSelect2\"&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleFormControlTextarea1\"&gt;Example textarea&lt;/label&gt; &lt;textarea class=\"form-control\" id=\"exampleFormControlTextarea1\" rows=\"3\"&gt;&lt;/textarea&gt; &lt;/div&gt;&lt;/form&gt; 提交的数据格式不对：生日、日期 日期的格式化 1spring.mvc.date-format=yyyy-MM-dd 7）CRUD-员工修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!--需要区分是员工修改还是添加：--&gt; &lt;form th:action=\"@&#123;/emp&#125;\" method=\"post\"&gt;&lt;!--发送put请求员工数据--&gt;&lt;!--1、SpringMVC配置HiddenHttpMethodFilter；2、页面创建一个post表单3、创建一个input项，name=”_method“;值就是我们指定的前驱方式--&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"put\" th:if=\"$&#123;emp!=null&#125;\"/&gt; &lt;input type=\"hidden\" name=\"id\" th:if=\"$&#123;emp!=null&#125;\" th:value=\"$&#123;emp.id&#125;\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input name=\"lastName\" type=\"text\" class=\"form-control\" placeholder=\"zhangsan\" th:value=\"$&#123;emp!=null&#125;?$&#123;emp.lastName&#125;\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input name=\"email\" type=\"email\" class=\"form-control\" placeholder=\"zhangsan@atguigu.com\" th:values=\"$&#123;emp!=null&#125;?$&#123;emp.email&#125;\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\" th:checked=\"$&#123;emp!=null&#125;?$&#123;emp.gender==1&#125;\"&gt; &lt;label class=\"form-check-label\"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\" th:checked=\"$&#123;emp!=null&#125;?$&#123;emp.gender==0&#125;\"&gt; &lt;label class=\"form-check-label\"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;department&lt;/label&gt; &lt;select class=\"form-control\" name=\"department.id\"&gt;&lt;!-- &lt;option&gt;1&lt;/option&gt;--&gt;&lt;!-- &lt;option&gt;2&lt;/option&gt;--&gt;&lt;!-- &lt;option&gt;3&lt;/option&gt;--&gt;&lt;!-- &lt;option&gt;4&lt;/option&gt;--&gt;&lt;!-- &lt;option&gt;5&lt;/option&gt;--&gt; &lt;option th:selected=\"$&#123;emp!=null&#125;?$&#123;dept.id==emp.department.id&#125;\" th:values=\"$&#123;dept.id&#125;\" th:each=\"dept:$&#123;depts&#125;\" th:value=\"$&#123;dept.id&#125;\" th:text=\"$&#123;dept.departmentName&#125;\"&gt;&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input name=\"birth\" type=\"text\" class=\"form-control\" placeholder=\"1996-05-12\" th:value=\"$&#123;emp!=null&#125;?$&#123;emp.birth&#125;\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\" th:text=\"$&#123;emp!=null&#125;?'修改':'添加'\"&gt;添加&lt;/button&gt; &lt;/form&gt; &lt;/main&gt; &lt;/div&gt; &lt;/div&gt; 7、错误处理机制（1）SpringBoot默认的错误处理机制 1）默认效果： 返回一个默认的错误页面 2）如果是其他客户端，默认响应一个json数据 原理： 可以参照ErrorMvcAutoConfiguration;错误处理的自动配置 给容器中添加了以下组件 1、DefaultErrorAttributes 1帮我们在页面共享信息 2、BasicErrorController ：处理默认/error请求 12345678910111213141516171819202122232425@Controller@RequestMapping(&#123;\"$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;\"&#125;)public class BasicErrorController extends AbstractErrorController &#123; private final ErrorProperties errorProperties; @RequestMapping( produces = &#123;\"text/html\"&#125;//产生html类型的数据;浏览器发送的请求来到这个地方处理 ) public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = this.getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(this.getErrorAttributes(request, this.isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //去哪个页面作为错误页面；包含页面地址和页面内容 ModelAndView modelAndView = this.resolveErrorView(request, response, status, model); return modelAndView != null ? modelAndView : new ModelAndView(\"error\", model); &#125; @RequestMapping //产生json数据，其他客户端来到这里处理 public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = this.getErrorAttributes(request, this.isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = this.getStatus(request); return new ResponseEntity(body, status); &#125; 3、errorPageCustomizer 12@Value(\"$&#123;error.path:/error&#125;\")private String path = \"/error\"; 系统出现错误以后error请求进行处理；web.xml注册的错误页面规则 4、DefaultErrorViewResolverConfiguration 12345678910111213141516171819202122232425262728293031private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; //默认SpringBoot可以去找到一个页面 error/404 String errorViewName = \"error/\" + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders.getProvider(errorViewName, this.applicationContext); //模板引擎可用的情况下返回到errorViewName指定的视图地址 //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return provider != null ? new ModelAndView(errorViewName, model) : this.resolveResource(errorViewName, model); &#125; private ModelAndView resolveResource(String viewName, Map&lt;String, Object&gt; model) &#123; String[] var3 = this.resourceProperties.getStaticLocations(); int var4 = var3.length; for(int var5 = 0; var5 &lt; var4; ++var5) &#123; String location = var3[var5]; try &#123; Resource resource = this.applicationContext.getResource(location); resource = resource.createRelative(viewName + \".html\"); if (resource.exists()) &#123; return new ModelAndView(new DefaultErrorViewResolver.HtmlResourceView(resource), model); &#125; &#125; catch (Exception var8) &#123; &#125; &#125; return null; &#125; 步骤：一旦系统出现4x4或者5xx之类的错误，errorPageCustomizer定制错误响应规则;就会来到error请求；就会被BasicErrorController处理 响应页面：去哪个页面是由DefaultErrorViewResolver 12345678910111213141516 protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) &#123; Iterator var5 = this.errorViewResolvers.iterator();//所有的errorViewResolvers得到ModelAndView ModelAndView modelAndView; do &#123; if (!var5.hasNext()) &#123; return null; &#125; ErrorViewResolver resolver = (ErrorViewResolver)var5.next(); modelAndView = resolver.resolveErrorView(request, status, model); &#125; while(modelAndView == null); return modelAndView; &#125; （2）如果制定错误响应： 1、如何定制错误页面 1）有模板引擎的情况下；error/状态码，将错误页面命名为 错误状态码.html放在模板引起文件夹里面的error文件夹下，发生此状态码的错误就会来到对应的页面 我们可以使用4xx和5xx作为错误页面来匹配指针类型的所有错误，精确优先（优先寻找精确的状态码.html） 页面获取的信息 timeStamp 时间戳 status:状态码 error:错误提示 exception：异常对象 message：异常信息 error：JSR303数据校验的错误都在这里 2）没有模板引擎（模板引擎），静态资源文件夹下找3）以上都没有错误，就是默认来到SpringBoot 2、如何定制错误的json数据1）自定义异常处理 1234567891011 @ControllerAdvicepublic class MyExceptionHandler &#123; @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String, Object&gt; handleException(Exception e)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"code\",\"user.notexist\"); map.put(\"message\",e.getMessage()); return map; &#125;&#125;//没有自适应效果 2）转发到/error进行自适应响应效果处理 12345678910111213@ExceptionHandler(UserNotExistException.class) public String handleException(Exception e, HttpServletRequest request)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //传入我们自己的错误状态码 4xx 5xx /** * Integer statusCode = (Integer)request.getAttribute(\"javax.servlet.error.status_code\"); */ request.setAttribute(\"javax.servlet.error.status_code\",500); map.put(\"code\",\"user.notexist\"); map.put(\"message\",e.getMessage()); //转发到/error return \"forward:/error\"; &#125; 3）将我们的定制数据携带出去出现错误以后，会来到/error请求,会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法） 1、完全来编写一个ErrorController的实现类【或者是编写是AbstractErrorController的子类】，放在容器中 2、页面上能用的数据，或者是json返回能用的数据是通过errorAttributes.getErrorAttributes得到： 容器在DefaultErrorAttributes() 默认进行数据处理的； 自定义 12345678910 //给容器中加入我们自己定义的ErrorAttributes@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes &#123; @Override public Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) &#123; Map&lt;String,Object&gt; map= super.getErrorAttributes(webRequest, includeStackTrace); map.put(\"company\",\"atguigu\"); return map; &#125;&#125; 最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容 8、配置嵌入式Servlet容器SpringBoot默认用的（Tomcat）作为嵌入式的Servlet容器问题： （1）、如何定制和修改Servlet容器的相关配置；1）修改和Server有关的配置(ServerProperties[也是EmbeddedServletContainerCustomizer])； 12345678server.port&#x3D;8081server.servlet.context-path&#x3D;&#x2F;crudserver.tomcat.uri-encoding&#x3D;utf-8&#x2F;&#x2F;通用的Servlet容器设置server.xxx&#x2F;&#x2F;Tomcat的设置server.tomcat.xxx 2）编写一个EmbeddedServletContainerCustomizer:嵌入式的Servlet容器的定制器来修改Servlt容器 12345678910@Beanpublic WebServerFactoryCustomizer webServerFactoryCustomizer()&#123; return new WebServerFactoryCustomizer() &#123; @Override public void customize(WebServerFactory factory) &#123; factory.setPort(8083); &#125; //定制嵌入式的Servlet容器相关的规则 &#125;;&#125; （2）、注册Servlet三大组件（Servlet、Filter、Listener）由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件注册三大组件用以下方式：ServletRegistrationBean 123456//注册三大组件 @Bean public ServletRegistrationBean myServlet()&#123; ServletRegistrationBean registrationBean=new ServletRegistrationBean&lt;&gt;(new MyServlet(),\"/myServlet\"); return registrationBean; &#125; FilterRegistrationBean 1234567@Bean public FilterRegistrationBean myFilter()&#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean&lt;&gt;(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList(\"/hello\",\"/myServlet\")); return registrationBean; &#125; ServletListenerRegistrationBean 123456@Beanpublic ServletListenerRegistrationBean myListener()&#123; ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean=new ServletListenerRegistrationBean&lt;MyListener&gt;(new MyListener()); return registrationBean;&#125; SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DispatycherServlet； 1&#x2F;&#x2F;默认拦截：&#x2F; 所有请求；包静态资源，但是不拦截jsp请求；&#x2F;*会拦截 （3）、SpringBoot能不能支持其他的Servlet容器 Tomcat1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; Jetty（长连接） Undertow（不支持JSP） （4）、嵌入式Servlet容器自动配置原理123456789101112131415161718192021222324@Configuration @ConditionalOnClass(&#123;Server.class, Loader.class, WebAppContext.class&#125;) public static class JettyWebServerFactoryCustomizerConfiguration &#123; public JettyWebServerFactoryCustomizerConfiguration() &#123; &#125; @Bean public JettyWebServerFactoryCustomizer jettyWebServerFactoryCustomizer(Environment environment, ServerProperties serverProperties) &#123; return new JettyWebServerFactoryCustomizer(environment, serverProperties); &#125; &#125; @Configuration @ConditionalOnClass(&#123;Tomcat.class, UpgradeProtocol.class&#125;) public static class TomcatWebServerFactoryCustomizerConfiguration &#123; public TomcatWebServerFactoryCustomizerConfiguration() &#123; &#125; @Bean public TomcatWebServerFactoryCustomizer tomcatWebServerFactoryCustomizer(Environment environment, ServerProperties serverProperties) &#123; return new TomcatWebServerFactoryCustomizer(environment, serverProperties); &#125; &#125; ServerProperties也是定制器 步骤：1）SpringBoot根据导入的依赖情况，给容器中添加相应的TomcatWebServerFactoryCustomizerConfiguration2）容器中某个组件要创建对象就会惊动后置处理器 3）后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法 （5）、嵌入式Servlet容器自动原理什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomact获取嵌入式的Servlet容器工厂：1）SpringBoot应用启动运行run方法2）refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext,否则建AnnotationConfigEmbeddedApplicationContext3）refresh(context)刷新刚才创建好的ioc容器4）onRefresh():web的ioc容器重写了onRefresh方法5）webioc容器会创建嵌入式的servlet容器：createEmbeddServletContainer();6）获取嵌入式的Servlet容器工厂：7）使用容器工厂获取嵌入式的Servlet容器8）嵌入式的servlet容器创建对象并启动Servlet容器先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来IOC容器启动创建嵌入式的SerVlet容器 9、使用外置的Servlet容器嵌入式Servlet容器： 优点：简单、便携； 缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入Servlet容器的创建工厂【EmbeddedWebServerFactoryCustomizerAutoConfiguration】）； 外置的Servlet容器：外面安装Tomcat——应用war包的方式打包；步骤：1）必须创建一个war项目（利用idea）2）将嵌入式的Tomcat指定为provided； 12 3）必须编写一个SpringBootServletInitializer的子类，并调用configure方法 123456789public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; //传入SpringBoot应用的主程序 return application.sources(SpringBoot04WebJspApplication.class); &#125;&#125; 4）启动服务器就可以使用 原理jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器；war包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器； servlet3.08.2.4 Shared libraries/runtimes pluggability 规则：1）服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面的SercletContainerInitializer一个实例2）ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的文件，内容就是servletContainerInitializer的实现类的全类名3）还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣 流程：1）启动Tomcat2）C:\\Users\\A.m2\\repository\\org\\springframework\\spring-web\\5.2.6.RELEASE\\spring-web-5.2.6.RELEASE.jar!\\META-INF\\services\\javax.servlet.ServletContainerInitializer：SpringWeb文件的模块里有个文件：org.springframework.web.SpringServletContainerInitializer3）SpringServletContainerInitializer将@HandlesTypes({WebApplicationInitializer.class})标注的所有这个类型的类都传入到onStartup方法的Set&lt;Class&lt;?&gt;&gt;;为这些WebApplicationInitializer类型的类创建实例4）每一个WebApplicationInitializer都调用自己的onStartup 5）相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法 6）SpringBootServletInitializer执行onStartup的时候会createSpringApplicationBuilder容器7） 123456789101112131415161718192021222324252627282930313233 protected WebApplicationContext createRootApplicationContext(ServletContext servletContext) &#123; SpringApplicationBuilder builder = this.createSpringApplicationBuilder(); builder.main(this.getClass()); ApplicationContext parent = this.getExistingRootWebApplicationContext(servletContext); if (parent != null) &#123; this.logger.info(\"Root context already created (using as parent).\"); servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, (Object)null); builder.initializers(new ApplicationContextInitializer[]&#123;new ParentContextApplicationContextInitializer(parent)&#125;); &#125; builder.initializers(new ApplicationContextInitializer[]&#123;new ServletContextApplicationContextInitializer(servletContext)&#125;); builder.contextClass(AnnotationConfigServletWebServerApplicationContext.class); //调用configure方法，子类重写这个方法，将SpringBoot的主程序传了进来builder = this.configure(builder);//使用builder创建一个spring应用 builder.listeners(new ApplicationListener[]&#123;new SpringBootServletInitializer.WebEnvironmentPropertySourceInitializer(servletContext)&#125;); SpringApplication application = builder.build(); if (application.getAllSources().isEmpty() &amp;&amp; MergedAnnotations.from(this.getClass(), SearchStrategy.TYPE_HIERARCHY).isPresent(Configuration.class)) &#123; application.addPrimarySources(Collections.singleton(this.getClass())); &#125; Assert.state(!application.getAllSources().isEmpty(), \"No SpringApplication sources have been defined. Either override the configure method or add an @Configuration annotation\"); if (this.registerErrorPageFilter) &#123; application.addPrimarySources(Collections.singleton(ErrorPageFilterConfiguration.class)); &#125;application.setRegisterShutdownHook(false); //启动spring应用 return this.run(application); &#125; 7）Spring应用就启动并且创建IOC容器 1234567891011121314151617181920212223242526272829303132333435363738394041public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList(); this.configureHeadlessProperty(); SpringApplicationRunListeners listeners = this.getRunListeners(args); listeners.starting(); Collection exceptionReporters; try &#123; ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); ConfigurableEnvironment environment = this.prepareEnvironment(listeners, applicationArguments); this.configureIgnoreBeanInfo(environment); Banner printedBanner = this.printBanner(environment); context = this.createApplicationContext(); exceptionReporters = this.getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[]&#123;ConfigurableApplicationContext.class&#125;, context); this.prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新IOC容器 this.refreshContext(context); this.afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) &#123; (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), stopWatch); &#125; listeners.started(context); this.callRunners(context, applicationArguments); &#125; catch (Throwable var10) &#123; this.handleRunFailure(context, var10, exceptionReporters, listeners); throw new IllegalStateException(var10); &#125; try &#123; listeners.running(context); return context; &#125; catch (Throwable var9) &#123; this.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)null); throw new IllegalStateException(var9); &#125; &#125; 启动Servlet容器，再启动SpringBoot应用","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lijiale96.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://lijiale96.github.io/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lijiale96.github.io/tags/Spring-Boot/"}]},{"title":"Spring Boot 三","slug":"Spring-Boot-三","date":"2020-05-11T15:40:32.000Z","updated":"2020-05-12T12:44:43.305Z","comments":true,"path":"2020/05/11/Spring-Boot-三/","link":"","permalink":"https://lijiale96.github.io/2020/05/11/Spring-Boot-%E4%B8%89/","excerpt":"日志1、日志框架开发一个大型系统：1、System.out.println(“”):将关键数据打印在控制台；去掉？2、框架来记录系统的一些运行时信息；日志框架；zhanglogging.jar;3、高大上功能？异步模式？自动归档？xxx？zhanglogging-good.jar?4、将以前框架卸下来？换上新的框架，重写修改之前相关的API；zhanglogging-perfect.jar5、JDBC-数据库驱动； 写一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar 给项目中导入具体的日志实现就行了。我们之前的日志框架都是实现的抽象层","text":"日志1、日志框架开发一个大型系统：1、System.out.println(“”):将关键数据打印在控制台；去掉？2、框架来记录系统的一些运行时信息；日志框架；zhanglogging.jar;3、高大上功能？异步模式？自动归档？xxx？zhanglogging-good.jar?4、将以前框架卸下来？换上新的框架，重写修改之前相关的API；zhanglogging-perfect.jar5、JDBC-数据库驱动； 写一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar 给项目中导入具体的日志实现就行了。我们之前的日志框架都是实现的抽象层 日志门面 日志实现 JCL、SLF4j、jboss-logging Log4、 JUL、Log4j2、Logback 日志门面：SLF4j日志实现：Logback springBoot：底层是Spring框架，Spring框架默认是用jCL；SpringBoot选用SLF4j和logback 2、SLF4j使用1、如何在系统中使用SLF4j以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层面方法;给系统里面导入slf4j的jar和logback实现jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(\"Hello World\"); &#125;&#125; 每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架的配置文件 2、遗留问题a(slf4j+logback):Spring(commons-logging\\Hibernate(jboss-logging)、MyBatis)统一日志记录，即使是别的框架和我一起统一使用上slf4j进行输出？ 如何让系统中所有的日志都统一到slf4j：1、将系统中其他日志框架先排除出去2、用中间包来替换原有的日志框架3、我们导入slf4j其他的实现 3、SpringBoot日志关系1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; SpringBoot使用它来做日志功能 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; 总结：1）SpringBoot底层也是使用slf4j+logback的方式进行日志记录2）SpringBoot也把其他日志都替换成了slf4j3）中间替换包 4）如果我们引入其他框架？一定要把这个框架的默认日志依赖移除掉？Spring框架用的是commons-logging：spring5已经用slf4j SpringBoot能自动适配所有日志，而且底层使用slf4j+logback的方式记录日志，引入其他的框架的时候，只需要把这个框架依赖的日志框架排除掉 4、日志使用1、默认配置Spring默认帮我们配置好了日志 1234567891011121314151617181920212223242526272829package com.atguigu.springboot;import org.junit.jupiter.api.Test;import org.junit.runner.RunWith;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestclass SpringBoot03LoggingApplicationTests &#123; //记录器 Logger logger = LoggerFactory.getLogger(getClass()); @Test void contextLoads() &#123; //日志的级别 //由低到高 //可以调整输出的日志级别，这个级别以后高级别生效 logger.trace(\"这是trace日志\"); logger.debug(\"这是debug日志\"); //springBoot默认给我们使用的是info级别的,你要指定级别的就用SpringBoot默认规定的级别：root级别 logger.info(\"这是info日志\"); logger.warn(\"这是warn日志\"); logger.error(\"这是error日志\"); &#125;&#125; 123456789101112131415logging.level.com.atguigu&#x3D;trace#Logging.path&#x3D;# 不指定路径当前项目下生成springboot.log日志# 可以指定完整的路径#logging.file.name&#x3D;G：&#x2F;springboot.log# 在当前磁盘的根路径下创建spring文件夹和里面的Log文件，使用spring.Log作为默认文件#logging.file.name&#x3D;springboot.log#logging.file.path&#x3D;&#x2F;spring&#x2F;log#在控制台输出的日志格式logging.pattern.console&#x3D;%d&#123;yyyy-MM-dd &#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n#指定文件中日志输出的格式logging.pattern.file&#x3D;%d&#123;yyyy-MM-dd &#125; &#x3D;&#x3D;&#x3D; [%thread] &#x3D;&#x3D;&#x3D; %-5level &#x3D;&#x3D;&#x3D; %logger&#123;50&#125; &#x3D;&#x3D;&#x3D;&#x3D; %msg%n 2、指定配置给类路径下放上每个日志框架自己的配置文件即可：SpringBoot就不使用默认配置的 logback.xml:直接就被日志框架识别logback-spring.xml:日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能 1234&lt;springProfile name&#x3D;&quot;staging&quot;&gt; &lt;!-- configuration to be enabled when the &quot;staging&quot; profile is active --&gt; 可以指定某段配置只在某个环境下生效&lt;&#x2F;springProfile&gt; 否则报错 5、切换日志框架可以按照slf4j的日志适配图，进行相关的切换；slf4j+log4j的方式： 12345678910111213141516 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt;&lt;groupId&gt;org.slf4j&lt;/groupId&gt;&lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/dependency&gt; 切换为log4j2 12345678910111213141516171819202122 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;!-- &lt;exclusions&gt;--&gt;&lt;!-- &lt;exclusion&gt;--&gt;&lt;!-- &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;--&gt;&lt;!-- &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;--&gt;&lt;!-- &lt;/exclusion&gt;--&gt;&lt;!-- &lt;/exclusions&gt;--&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;/dependency&gt;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lijiale96.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://lijiale96.github.io/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lijiale96.github.io/tags/Spring-Boot/"}]},{"title":"Redis笔记2","slug":"Redis笔记2","date":"2020-05-10T08:39:53.000Z","updated":"2020-05-10T14:08:21.639Z","comments":true,"path":"2020/05/10/Redis笔记2/","link":"","permalink":"https://lijiale96.github.io/2020/05/10/Redis%E7%AC%94%E8%AE%B02/","excerpt":"1、在你的项目中，哪些数据是数据库和redis缓存双写一份的？如何保证双鞋一致性？如果不是严格要求“缓存和数据库”必须保证一致性的话，最好不要做这个方案：即 读请求和写请求串行化，串到一个内存队列里面去。串行化可以保证一定不会出现不一致的情况，但会导致系统吞吐量大幅度降低。解决这个问题的最经典的模式，就是Cache Aside Pattern。Cache Aside Pattern： （1）读的时候先读缓存，如果缓存不存在的话就读数据库，取出数据库后更新缓存；如果存在的话直接读取缓存的信息。 （2）写的时候，先更新数据库，再删除缓存。说到这个问题，又会出现很多问题： （1）为什么是删除缓存，而不是更新缓存？ （2）为什么是先更新数据库，再删除缓存？不是先删除缓存，再更新数据库？","text":"1、在你的项目中，哪些数据是数据库和redis缓存双写一份的？如何保证双鞋一致性？如果不是严格要求“缓存和数据库”必须保证一致性的话，最好不要做这个方案：即 读请求和写请求串行化，串到一个内存队列里面去。串行化可以保证一定不会出现不一致的情况，但会导致系统吞吐量大幅度降低。解决这个问题的最经典的模式，就是Cache Aside Pattern。Cache Aside Pattern： （1）读的时候先读缓存，如果缓存不存在的话就读数据库，取出数据库后更新缓存；如果存在的话直接读取缓存的信息。 （2）写的时候，先更新数据库，再删除缓存。说到这个问题，又会出现很多问题： （1）为什么是删除缓存，而不是更新缓存？ （2）为什么是先更新数据库，再删除缓存？不是先删除缓存，再更新数据库？ 写的时候为什么是删除缓存不是更新缓存？原因很简单，很多时候，在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值。 比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值的。 另外更新缓存的代价有时候是很高的。是不是说，每次修改数据库的时候，都一定要将其对应的缓存更新一份？也许有的场景是这样，但是对于比较复杂的缓存数据计算的场景，就不是这样了。如果你频繁修改一个缓存涉及的多个表，缓存也频繁更新。但是问题在于，这个缓存到底会不会被频繁访问到？ 举个栗子，一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有大量的冷数据。实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。用到缓存才去算缓存。 其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。像 mybatis，hibernate，都有懒加载思想。查询一个部门，部门带了一个员工的 list，没有必要说每次查询部门，都里面的 1000 个员工的数据也同时查出来啊。80% 的情况，查这个部门，就只是要访问这个部门的信息就可以了。先查部门，同时要访问里面的员工，那么这个时候只有在你要访问里面的员工的时候，才会去数据库里面查询 1000 个员工。 2、系统上线，redis缓存系统是如何部署的？面试官心理分析看看你了解不了解你们公司的 redis 生产集群的部署架构，如果你不了解，那么确实你就很失职了，你的 redis 是主从架构？集群架构？用了哪种集群方案？有没有做高可用保证？有没有开启持久化机制确保可以进行数据恢复？线上 redis 给几个 G 的内存？设置了哪些参数？压测后你们 redis 集群承载多少 QPS？ 兄弟，这些你必须是门儿清的，否则你确实是没好好思考过。 面试题剖析redis cluster，10 台机器，5 台机器部署了 redis 主实例，另外 5 台机器部署了 redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰qps可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求/s。 机器是什么配置？32G 内存+ 8 核 CPU + 1T 磁盘，但是分配给 redis 进程的是10g内存，一般线上生产环境，redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。 5 台机器对外提供读写，一共有 50g 内存。 因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，redis 从实例会自动变成主实例继续提供读写服务。 你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。 其实大型的公司，会有基础架构的 team 负责缓存集群的运维。 3、系统上线，redis缓存给了多大的总内存？命中率有多高？抗住了多少QPS？数据流回源会有多少QPS？QPS(query per second 每秒查询数)4、热Key大Value问题，某个key出现了热点缓存导致缓存集群中的某个机器负载过高？如何发现并解决？5、超大Value打满网卡的问题如何规避这样的问题？6、你过往的工作经历中，算法出现过缓存集群事故？说说细节并说说高可用保障的方案7、平时如何监控缓存集群的QPS和容量8、缓存集群如何扩容？Redis集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在N个节点中，每个节点存储总数据的1/N 9、说下redis的集群原理和选举机制 Redis集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在N个节点中，每个节点存储总数据的1/N Redis集群通过分区（partition）来提供一定程度的可用性（availability）：即使集群中又一部分节点失效或者无法进行通讯，集群也可以继续处理命令请求 10、key寻址算法都有哪些hash 算法来了一个 key，首先计算 hash 值，然后对节点数取模。然后打在不同的 master 节点上。一旦某一个 master 节点宕机，所有请求过来，都会基于最新的剩余 master 节点数去取模，尝试去取数据。这会导致大部分的请求过来，全部无法拿到有效的缓存，导致大量的流量涌入数据库。 一致性hash 算法一致性 hash 算法将整个 hash 值空间组织成一个虚拟的圆环，整个空间按顺时针方向组织，下一步将各个 master 节点（使用服务器的 ip 或主机名）进行 hash。这样就能确定每个节点在其哈希环上的位置。 来了一个 key，首先计算 hash 值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，遇到的第一个 master 节点就是 key 所在位置。 在一致性哈希算法中，如果一个节点挂了，受影响的数据仅仅是此节点到环空间前一个节点（沿着逆时针方向行走遇到的第一个节点）之间的数据，其它不受影响。增加一个节点也同理。 燃鹅，一致性哈希算法在节点太少时，容易因为节点分布不均匀而造成缓存热点的问题。为了解决这种热点问题，一致性 hash 算法引入了虚拟节点机制，即对每一个节点计算多个 hash，每个计算结果位置都放置一个虚拟节点。这样就实现了数据的均匀分布，负载均衡。 redis cluster 的 hash slot 算法redis cluster 有固定的 16384 个 hash slot，对每个 key 计算 CRC16 值，然后对 16384 取模，可以获取 key 对应的 hash slot。 redis cluster 中每个 master 都会持有部分 slot，比如有 3 个 master，那么可能每个 master 持有 5000 多个 hash slot。hash slot 让 node 的增加和移除很简单，增加一个 master，就将其他 master 的 hash slot 移动部分过去，减少一个 master，就将它的 hash slot 移动到其他 master 上去。移动 hash slot 的成本是非常低的。客户端的 api，可以对指定的数据，让他们走同一个 hash slot，通过 hash tag 来实现。 任何一台机器宕机，另外两个节点，不影响的。因为 key 找的是 hash slot，不是机器。 11、redis线程模型现场画个图说说redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，将产生事件的 socket 压入内存队列中，事件分派器根据 socket 上的事件类型来选择对应的事件处理器进行处理。 文件事件处理器的结构包含 4 个部分： 多个 socketIO 多路复用程序文件事件分派器事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将产生事件的 socket 放入队列中排队，事件分派器每次从队列中取出一个 socket，根据 socket 的事件类型交给对应的事件处理器进行处理。 来看客户端与 redis 的一次通信过程： 要明白，通信是通过 socket 来完成的，不懂的同学可以先去看一看 socket 网络编程。 首先，redis 服务端进程初始化的时候，会将 server socket 的 AE_READABLE 事件与连接应答处理器关联。 客户端 socket01 向 redis 进程的 server socket 请求建立连接，此时 server socket 会产生一个 AE_READABLE 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该 socket 压入队列中。文件事件分派器从队列中获取 socket，交给连接应答处理器。连接应答处理器会创建一个能与客户端通信的 socket01，并将该 socket01 的 AE_READABLE事件与命令请求处理器关联。 假设此时客户端发送了一个 set key value 请求，此时 redis 中的 socket01 会产生 AE_READABLE 事件，IO 多路复用程序将 socket01 压入队列，此时事件分派器从队列中获取到 socket01 产生的 AE_READABLE 事件，由于前面 socket01 的 AE_READABLE 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 socket01 的 key value 并在自己内存中完成 key value 的设置。操作完成后，它会将 socket01 的 AE_WRITABLE 事件与命令回复处理器关联。 如果此时客户端准备好接收返回结果了，那么 redis 中的 socket01 会产生一个 AE_WRITABLE 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 ok，之后解除 socket01 的 AE_WRITABLE 事件与命令回复处理器的关联。 12、redis内存模型现场画个图说说13、redis的底层数据结构了解多少？面试官心理分析除非是面试官感觉看你简历，是工作 3 年以内的比较初级的同学，可能对技术没有很深入的研究，面试官才会问这类问题。否则，在宝贵的面试时间里，面试官实在不想多问。 其实问这个问题，主要有两个原因： 看看你到底有没有全面的了解 redis 有哪些功能，一般怎么来用，啥场景用什么，就怕你别就会最简单的 KV 操作；看看你在实际项目里都怎么玩儿过 redis。要是你回答的不好，没说出几种数据类型，也没说什么场景，你完了，面试官对你印象肯定不好，觉得你平时就是做个简单的 set 和 get。 面试题剖析redis 主要有以下几种数据类型： stringhashlistsetsorted set string这是最简单的类型，就是普通的 set 和 get，做简单的 KV 缓存。 1set college szuCopy to clipboardErrorCopied hash这个是类似 map 的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在 redis 里，然后每次读写缓存的时候，可以就操作 hash 里的某个字段。 123456789hset person name bingohset person age 20hset person id 1hget person nameCopy to clipboardErrorCopiedperson &#x3D; &#123; &quot;name&quot;: &quot;bingo&quot;, &quot;age&quot;: 20, &quot;id&quot;: 1&#125;Copy to clipboardErrorCopied listlist 是有序列表，这个可以玩儿出很多花样。 比如可以通过 list 存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的东西。 比如可以通过 lrange 命令，读取某个闭区间内的元素，可以基于 list 实现分页查询，这个是很棒的一个功能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走。 12345678910# 0开始位置，-1结束位置，结束位置为-1时，表示列表的最后一个位置，即查看所有。lrange mylist 0 -1Copy to clipboardErrorCopied比如可以搞个简单的消息队列，从 list 头怼进去，从 list 尾巴那里弄出来。lpush mylist 1lpush mylist 2lpush mylist 3 4 5rpop mylistCopy to clipboardErrorCopied setset 是无序集合，自动去重。 直接基于 set 将系统里需要去重的数据扔进去，自动就给去重了，如果你需要对一些数据进行快速的全局去重，你当然也可以基于 jvm 内存里的 HashSet 进行去重，但是如果你的某个系统部署在多台机器上呢？得基于 redis 进行全局的 set 去重。 可以基于 set 玩儿交集、并集、差集的操作，比如交集吧，可以把两个人的粉丝列表整一个交集，看看俩人的共同好友是谁？对吧。 把两个大 V 的粉丝都放在两个 set 中，对两个 set 做交集。 1234567891011121314151617181920212223242526272829303132#-------操作一个set-------# 添加元素sadd mySet 1# 查看全部元素smembers mySet# 判断是否包含某个值sismember mySet 3# 删除某个/些元素srem mySet 1srem mySet 2 4# 查看元素个数scard mySet# 随机删除一个元素spop mySet#-------操作多个set-------# 将一个set的元素移动到另外一个setsmove yourSet mySet 2# 求两set的交集sinter yourSet mySet# 求两set的并集sunion yourSet mySet# 求在yourSet中而不在mySet中的元素sdiff yourSet mySetCopy to clipboardErrorCopied sorted setsorted set 是排序的 set，去重但可以排序，写进去的时候给一个分数，自动根据分数排序。 12345678910zadd board 85 zhangsanzadd board 72 lisizadd board 96 wangwuzadd board 63 zhaoliu# 获取排名前三的用户（默认是升序，所以需要 rev 改为降序）zrevrange board 0 3# 获取某用户的排名zrank board zhaoliuCopy to clipboardErrorCopied 14、redis的单线程特性有什么优缺点 纯内存操作。 核心是基于非阻塞的 IO 多路复用机制。 C 语言实现，一般来说，C 语言实现的程序“距离”操作系统更近，执行速度相对会更快。 单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题。 15、怎么解决缓存击穿问题？缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。 不同场景下的解决方式可如下： 若缓存的数据是基本不会发生更新的，则可尝试将该热点数据设置为永不过期。 若缓存的数据更新不频繁，且缓存刷新的整个流程耗时较少的情况下，则可以采用基于 redis、zookeeper 等分布式中间件的分布式互斥锁，或者本地互斥锁以保证仅少量的请求能请求数据库并重新构建缓存，其余线程则在锁释放后能访问到新缓存。 若缓存的数据更新频繁或者缓存刷新的流程耗时较长的情况下，可以利用定时线程在缓存过期前主动的重新构建缓存或者延后缓存的过期时间，以保证所有的请求能一直访问到对应的缓存。 16、了解什么是 redis 的雪崩、穿透和击穿？redis 崩溃之后会怎么样？系统该如何应对这种情况？如何处理 redis 的穿透？面试官心理分析其实这是问到缓存必问的，因为缓存雪崩和穿透，是缓存最大的两个问题，要么不出现，一旦出现就是致命性的问题，所以面试官一定会问你。 面试题剖析缓存雪崩对于系统 A，假设每天高峰期每秒 5000 个请求，本来缓存在高峰期可以扛住每秒 4000 个请求，但是缓存机器意外发生了全盘宕机。缓存挂了，此时 1 秒 5000 个请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了。此时，如果没有采用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。 这就是缓存雪崩。 大约在 3 年前，国内比较知名的一个互联网公司，曾因为缓存事故，导致雪崩，后台系统全部崩溃，事故从当天下午持续到晚上凌晨 3~4 点，公司损失了几千万。 缓存雪崩的事前事中事后的解决方案如下： 事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。事中：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死。事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。 用户发送一个请求，系统 A 收到请求后，先查本地 ehcache 缓存，如果没查到再查 redis。如果 ehcache 和 redis 都没有，再查数据库，将数据库中的结果，写入 ehcache 和 redis 中。 限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？走降级！可以返回一些默认的值，或者友情提示，或者空白的值。 好处： 数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过。只要数据库不死，就是说，对用户来说，2/5 的请求都是可以被处理的。只要有 2/5 的请求可以被处理，就意味着你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来一次。 缓存穿透对于系统A，假设一秒 5000 个请求，结果其中 4000 个请求是黑客发出的恶意攻击。 黑客发出的那 4000 个攻击，缓存中查不到，每次你去数据库里查，也查不到。 举个栗子。数据库 id 是从 1 开始的，结果黑客发过来的请求 id 全部都是负数。这样的话，缓存中不会有，请求每次都“视缓存于无物”，直接查询数据库。这种恶意攻击场景的缓存穿透就会直接把数据库给打死。 解决方式很简单，每次系统 A 从数据库中只要没查到，就写一个空值到缓存里去，比如 set -999 UNKNOWN。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。 缓存击穿缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。 不同场景下的解决方式可如下： 若缓存的数据是基本不会发生更新的，则可尝试将该热点数据设置为永不过期。若缓存的数据更新不频繁，且缓存刷新的整个流程耗时较少的情况下，则可以采用基于 redis、zookeeper 等分布式中间件的分布式互斥锁，或者本地互斥锁以保证仅少量的请求能请求数据库并重新构建缓存，其余线程则在锁释放后能访问到新缓存。若缓存的数据更新频繁或者缓存刷新的流程耗时较长的情况下，可以利用定时线程在缓存过期前主动的重新构建缓存或者延后缓存的过期时间，以保证所有的请求能一直访问到对应的缓存。 17、redis 的持久化有哪几种方式？不同的持久化机制都有什么优缺点？持久化机制具体底层是如何实现的？Redis持久化–RDB 是什么？ 在指定的时间间隔内将内存的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里 备份如何执行？原理是redis会单独创建（fork）一个与当前进程一模一样的子进程来进行持久化，这个子进程的所有数据（变量。环境变量，程序程序计数器等）都和原进程一模一样，会先将数据写入到一个临时文件中，待持久化结束了，再用这个临时文件替换上次持久化好的文件，整个过程中，主进程不进行任何的io操作，这就确保了极高的性能如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感（允许丢失一些数据），那RDB的方式要比AOF方式更加的高效。RDB缺点是最后一次持久化的数据可能丢失 1.这个持久化文件在哪里dump.rdb 2.他什么时候fork子进程，或者什么时候触发rdb持久化机制（1）满足保存策略（写时复制：需要写的时候复制） save 900 1 save 300 10 save 60 10000（2）正常关闭shutdown时，如果没有开启aof，会触发配置文件中默认的快照配置 手动保存（一般不用）执行命令save或者bgsavesave是只管保存，其他不管，全部阻塞bgsave：redis会在后台异步进行快照操作，同时可以响应客户端的请求 执行flushall命令 但是里面是空的，无意义 RDB优点 节省磁盘空间 恢复速度快 RDB缺点 虽然Redis在fork时使用了写时拷贝技术，但是如果数据庞大时还是比较消耗性能 在备份周期在一定间隔时间做一次备份，所以如果Redis意外Down掉的话，就会丢失最后一次快照的所有修改 Redis持久化–AOF 是什么？以日志的形式记录每个写操作原理是将Reids的操作日志以追加的方式写入文件，读操作（get）是不记录的，只许追加文件但不可以改写文件，Redis启动之初会读取该文件重新构建数据，Redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作 AOF文件故障备份 AOF的备份机制和性能虽然和RDB不同 AOF和RDB同时开启，系统默认读取AOF的数据 AOF文件故障恢复 AOF文件的保存路径，同RDB路径一致 如遇到AOF文件损坏，可通过redis-check-aof –fix appendonly.aof 1.这个持久化文件在哪里 2.触发机制（根据配置文件配置项） AOF同步频率设置：no（把不主动进行同步）：表示等操作系统进行数据缓存同步到磁盘（快，持久化没保证）always（始终同步）：同步持久化，每次发生数据变更时，立即记录到磁盘（慢，安全）everysec（每秒同步）：表示每秒同步一次（默认值,很快，但可能会丢失一秒以内的数据） 3.aof重写机制（Rewrite）文件追加方式，为了避免文件会越来越大，新增重写当AOF文件增长到一定大小的时候Redis能够调用AOF文件内容压缩 bgrewriteaof对日志文件进行重写 。 如何实现重写？先写临时文件再rename，遍历新进程的内存数据。重写aof的操作，没有读取旧的aof文件，而是都记录哪些数据，用命令的方式（满足条件的就行）重写一个新的aof文件，和快照类似。 何时重写 当AOF文件大小的增长率大于该配置项时自动开启重写（这里指超过原大小的100%）。auto-aof-rewrite-percentage 100 当AOF文件增长到一定大小的时候Redis能够调用 bgrewriteaof对日志文件进行重写 。当AOF文件大小大于该配置项时自动开启重写 auto-aof-rewrite-min-size 64mb AOF优点 备份机制更稳健，丢失数据效率更低 可读的日志文件，通过AOF操作稳健。可以处理误操作 AOF缺点 比起RDB占用更多的磁盘空间 恢复备份速度要慢 每次读写都同步的话，有一定的性能压力 存在个别Bug，造成恢复不能 用哪个好 两个都用 对数据不敏感，单独使用RDB 不建议单独使用AOF，出现Bug 只是做纯内存，可以都不用 18、redis 的过期策略都有哪些？内存淘汰机制都有哪些？手写一下 LRU 代码实现？面试官心理分析如果你连这个问题都不知道，上来就懵了，回答不出来，那线上你写代码的时候，想当然的认为写进 redis 的数据就一定会存在，后面导致系统各种 bug，谁来负责？ 常见的有两个问题： 往 redis 写入的数据怎么没了？可能有同学会遇到，在生产环境的 redis 经常会丢掉一些数据，写进去了，过一会儿可能就没了。我的天，同学，你问这个问题就说明 redis 你就没用对啊。redis 是缓存，你给当存储了是吧？ 啥叫缓存？用内存当缓存。内存是无限的吗，内存是很宝贵而且是有限的，磁盘是廉价而且是大量的。可能一台机器就几十个 G 的内存，但是可以有几个 T 的硬盘空间。redis 主要是基于内存来进行高性能、高并发的读写操作的。 那既然内存是有限的，比如 redis 就只能用 10G，你要是往里面写了 20G 的数据，会咋办？当然会干掉 10G 的数据，然后就保留 10G 的数据了。那干掉哪些数据？保留哪些数据？当然是干掉不常用的数据，保留常用的数据了。 数据明明过期了，怎么还占用着内存？这是由 redis 的过期策略来决定。 面试题剖析redis 过期策略redis 过期策略是：定期删除+惰性删除。 所谓定期删除，指的是 redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。 假设 redis 里放了 10w 个 key，都设置了过期时间，你每隔几百毫秒，就检查 10w 个 key，那 redis 基本上就死了，cpu 负载会很高的，消耗在你的检查过期 key 上了。注意，这里可不是每隔 100ms 就遍历所有的设置过期时间的 key，那样就是一场性能上的灾难。实际上 redis 是每隔 100ms 随机抽取一些 key 来检查和删除的。 但是问题是，定期删除可能会导致很多过期 key 到了时间并没有被删除掉，那咋整呢？所以就是惰性删除了。这就是说，在你获取某个 key 的时候，redis 会检查一下 ，这个 key 如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。 获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西。 但是实际上这还是有问题的，如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 redis 内存块耗尽了，咋整？ 答案是：走内存淘汰机制。 内存淘汰机制redis 内存淘汰机制有以下几个： noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适）。volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。手写一个 LRU 算法你可以现场手写最原始的 LRU 算法，那个代码量太大了，似乎不太现实。 不求自己纯手工从底层开始打造出自己的 LRU，但是起码要知道如何利用已有的 JDK 数据结构实现一个 Java 版的 LRU。 1234567891011121314151617181920class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123; private final int CACHE_SIZE; /** * 传递进来最多能缓存多少数据 * * @param cacheSize 缓存大小 */ public LRUCache(int cacheSize) &#123; // true 表示让 linkedHashMap 按照访问顺序来进行排序，最近访问的放在头部，最老访问的放在尾部。 super((int) Math.ceil(cacheSize / 0.75) + 1, 0.75f, true); CACHE_SIZE = cacheSize; &#125; @Override protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123; // 当 map中的数据量大于指定的缓存个数的时候，就自动删除最老的数据。 return size() &gt; CACHE_SIZE; &#125;&#125;Copy to clipboardErrorCopied 19、如何保证 redis 的高并发和高可用？redis 的主从复制原理能介绍一下么？redis 的哨兵原理能介绍一下么？面试官心理分析其实问这个问题，主要是考考你，redis 单机能承载多高并发？如果单机扛不住如何扩容扛更多的并发？redis 会不会挂？既然 redis 会挂那怎么保证 redis 是高可用的？ 其实针对的都是项目中你肯定要考虑的一些问题，如果你没考虑过，那确实你对生产系统中的问题思考太少。 面试题剖析如果你用 redis 缓存技术的话，肯定要考虑如何用 redis 来加多台机器，保证 redis 是高并发的，还有就是如何让 redis 保证自己不是挂掉以后就直接死掉了，即 redis 高可用。 由于此节内容较多，因此，会分为两个小节进行讲解。 redis 主从架构redis 基于哨兵实现高可用redis 实现高并发主要依靠主从架构，一主多从，一般来说，很多项目其实就足够了，单主用来写入数据，单机几万 QPS，多从用来查询数据，多个从实例可以提供每秒 10w 的 QPS。 如果想要在实现高并发的同时，容纳大量的数据，那么就需要 redis 集群，使用 redis 集群之后，可以提供每秒几十万的读写并发。 redis 高可用，如果是做主从架构部署，那么加上哨兵就可以了，就可以实现，任何一个实例宕机，可以进行主备切换。","categories":[{"name":"Redis","slug":"Redis","permalink":"https://lijiale96.github.io/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://lijiale96.github.io/tags/Redis/"},{"name":"session","slug":"session","permalink":"https://lijiale96.github.io/tags/session/"},{"name":"cookie","slug":"cookie","permalink":"https://lijiale96.github.io/tags/cookie/"}]},{"title":"大厂面试题2","slug":"大厂面试题2","date":"2020-04-27T13:16:36.000Z","updated":"2020-05-19T07:34:58.338Z","comments":true,"path":"2020/04/27/大厂面试题2/","link":"","permalink":"https://lijiale96.github.io/2020/04/27/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%982/","excerpt":"JVM+GC解析复习JVM内存结构线程共享，GC：方法区、堆线程私有：Java栈、本地方栈、程序计数器 GC的作用域方法区、堆 常见的垃圾回收算法1.引用计数法（不用）一个地方就加1，引用失效减1缺点： 维护引用计数器 较难处理循坏引用 2.复制算法（年轻代）复制-清空-互换：复制之后又交换，谁空谁是to 没有碎片 浪费空间 3、标记清除（老生代）先标记要回收的对象，统一回收这些对象 节约内存空间 效率不高，产生内存碎片 4、标记整理（老生代）先标记，后压缩 没有内存碎片，利用bump 需要移动对象的成本","text":"JVM+GC解析复习JVM内存结构线程共享，GC：方法区、堆线程私有：Java栈、本地方栈、程序计数器 GC的作用域方法区、堆 常见的垃圾回收算法1.引用计数法（不用）一个地方就加1，引用失效减1缺点： 维护引用计数器 较难处理循坏引用 2.复制算法（年轻代）复制-清空-互换：复制之后又交换，谁空谁是to 没有碎片 浪费空间 3、标记清除（老生代）先标记要回收的对象，统一回收这些对象 节约内存空间 效率不高，产生内存碎片 4、标记整理（老生代）先标记，后压缩 没有内存碎片，利用bump 需要移动对象的成本 题目11.JVM垃圾回收的时候如何确定垃圾？是否知道什么是GCRoots什么是垃圾已经不再使用的空间就是垃圾person pl =null; 垃圾回收，如何判断一个对象是否可以被回收？1、引用计数法 2、枚举根节点做可达性分析（根搜索路径）一些系列名为GC Roots的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到GCRoots没有任何引用链相连的话，则证明此对象时不可用的。 Java可以作为GC Roots的对象 虚拟机栈（栈的局部变量区，局部变量表）引用的对象 方法区类静态属性引用对象 方法区常量引用的对象 本地方法栈（Native方法）引用的对象 1234567891011121314151617181920212223package JVMGC;/** * Java可以作为GC Roots的对象 * - 虚拟机栈（栈的局部变量区，局部变量表）引用的对象 * - 方法区类静态属性引用对象 * - 方法区常量引用的对象 * - 本地方法栈（Native方法）引用的对象:线程中 start方法 */public class GCRootsDemo &#123; private byte[] byteArray = new byte[100*1024*1024]; //private static GCRootDemo2 t2; //private static final GCRootDemo3 t3 = new GCRootDemo3(8); public static void main(String[] args) &#123; m1(); &#125; public static void m1()&#123; GCRootsDemo t1 = new GCRootsDemo(); System.gc(); System.out.println(\"第一次GC完成\"); &#125;&#125; 2、你说你做过JVM调优和参数设置，请问如何盘点查看JVM系统默认值 Xms 为jvm启动时分配的内存，比如-Xms200m，表示分配200M Xmx 为jvm运行过程中分配的最大内存，比如-Xms500m，表示jvm进程最多只能够占用500M内存 Xss 为jvm启动的每个线程分配的内存大小，默认JDK1.4中是256K，JDK1.5+中是1M JVM参数类型 标配参数（-version -help ） x参数（了解） Xint 解释执行 Xcomp 第一次使用就编译成本地代码 Xmixed 混合模式 xx参数 1、Boolean类型:公式：-XX：+/-属性值+：开启-：关闭 case：是否打印GC收集细节？-XX:+PrintGCDetails-XX:-PrintGCDetails 是否使用串行垃圾回收器？-XX:+UseSerialGC-XX:-UseSerialGC 2、KV设值类型公式：-XX：属性key=属性值value case：-XX:MetaspaceSize=128m-XX:MaxTenuringThreshold=15(young区到养老区) 3、jinfo举例，如何查看当前运行程序的配置 第一种：jinfo -flags 配置项 进程号 1) jinfo -flag InitialHeapSize 进程编号2) jinfo -flags 进程号3) jinfo -flag UseSerialGC 进程号 jinfo -flag MaxHeapSize 进程号 4、题外话1）两个经典参数：-Xms和-Xmx 2）这个你如何解释-Xms等价于-XX:InitialHeapSize-Xmx等价于-XX:MaxHeapSize 注：如何查看一个正在运行的java程序，它的某个jvm参数是否开启？具体值是多少？jps:查看进程编号 jinfo：查看某一个参数具体运行过程当中它的初始值 盘点家底查看JVM默认值第二种： 1) -XX:+PrintFlagsInitial:主要查看初始默认 java -XX:+PrintFlagsInitial 2) -XX:+PrintFlagsFinal：主要查看修改更新（ =表示初始的 :=表示人为修改以后的） java -XX:+PrintFlagsFinal -version3) PrintFlagsFinal举例：运行java命令的同时打印出参数 java XX:+PrintFlagsFinal -Xss128k java类名字 4) -XX:+PrintCommandLineFlags 看垃圾回收器的版本 （并行GC） 3、你平时工作用过的JVM常用基本配置参数有哪些？常用参数：1）-Xms：初始大小内存，默认为物理内存1/64，-XX：InitialHeapSize2）-Xmx：最大分配内存，默认为物理内存1/4 -XX:MaxHeapSize3）-Xss：设置单个线程的栈的大小，以欧版默认512k~1024k -XX:ThreadStackSize4）-Xmn：设置年轻代大小5）-XX：MetaspaceSize：设置元空间大小 本地内存限制-Xms10m -Xmx10m -XX:MetaspaceSize=1024m -XX:+PrintFlagsFinal 6）经典配置-Xms128m -Xmx4096m -XX:MetaspaceSize=512m -XX:+PrintCommandLineFlags-XX:+PrintGCDetails -XX:+UseSerialGC（串行） 7）-XX:+PrintGCDetails输出详细GC收集日志信息-XX:+PrintGCDetails GC 123 GC前堆 GC后堆 堆大小[PSYoungGen: 1837K-&gt;488K(2560K)] 1837K-&gt;656K(9728K), 0.0630527 secs] GC前新生代 GC后 新生代大小 FullGC(老年代，628-&gt;610 抗不住，爆错) 12[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 628K-&gt;610K(7168K)] 628K-&gt;610K(9728K), [Metaspace: 3285K-&gt;3285K(1056768K)], 0.0391850 secs] [Times: user=0.01 sys=0.00, real=0.04 secs] Heap 8）-XX:SurvivorRatio（设置eden区的比例占多少）设置新生代中eden和S0/S1空间的比例默认-XX：SurvivorRatio=8,Eden；S0：S1=8:1:1假如-XX：SurvivorRatio=4,Eden；S0：S1=4:1:1 9）-XX:NewRatio（设置年轻代与老年代在堆结构的比例占多少）设置新生代中eden和S0/S1空间的比例默认-XX：NewRatio=2,新生代占1，老年代占2假如-XX：NewRatio=4,新生代占1，老年代占4 10）-XX:MaxTenuringThreshold 设置垃圾最大年龄(15) 4、强引用、软应用、弱引用、虚引用分别是多少？1）强引用就算是出现了OOM也不会读该对象进行回收造成内存泄漏 1234567891011package JVMGC;public class StrongReferenceDemo &#123; public static void main(String[] args) &#123; Object obj1=new Object();//强引用 Object obj2=obj1;//obj2引用赋值 obj1=null; //置空 System.gc(); System.out.println(obj2); &#125;&#125; obj2不会回收 2）软引用strong text降低OOM概率内存充足，不会被回收内存不足，会被回收 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package JVMGC;import java.lang.ref.SoftReference;public class SoftReferenceDemo &#123; public static void main(String[] args) &#123;// softRef_Memory_Enough(); softRef_Memory_NotEnough(); &#125; public static void softRef_Memory_Enough()&#123; Object o1=new Object(); SoftReference&lt;Object&gt; softReference = new SoftReference&lt;&gt;(o1); System.out.println(o1); System.out.println(softReference.get()); o1=null; System.gc(); System.out.println(o1); System.out.println(softReference.get()); &#125; /** * JVM配置，故意产生大对象并配置小的内存，让它内存不够用导致OOM，看软引用的回收情况 * -Xms 5m -Xmx5m -XX:+PrintGCDetails * */ public static void softRef_Memory_NotEnough()&#123; Object o1=new Object(); SoftReference&lt;Object&gt; softReference = new SoftReference&lt;&gt;(o1); System.out.println(o1); System.out.println(softReference.get()); o1=null; System.gc(); try&#123; byte[] bytes = new byte[30*1024*1024]; &#125;catch(Throwable e)&#123; e.printStackTrace(); &#125;finally &#123; System.out.println(o1); System.out.println(softReference.get()); &#125; &#125;&#125; 3）弱引用(1) 对于弱引用，只要GC，不管JVM，都会回收该对象的占用的内存 123456789101112131415161718package JVMGC;import java.lang.ref.WeakReference;public class WeakReferenceDemo &#123; public static void main(String[] args) &#123; Object o1= new Object(); WeakReference&lt;Object&gt; weakReference = new WeakReference&lt;&gt;(o1); System.out.println(o1); System.out.println(weakReference.get()); o1=null; System.gc(); System.out.println(\"==============\"); System.out.println(o1); System.out.println(weakReference.get()); &#125;&#125; (2) 使用场景假如有一个应用需要大量的本地图片 如果每次读取图片从硬盘读取会严重影响性能 如果一次性全部加载到内存中又可能造成内存溢出 此时用软引用设计思路：用一个HashMap来保存图片的路径和相应的图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效的避免了OOM问题 Map&lt;String,SoftReference&gt; imageCache= new HashMap&lt;String,SoftReference&gt;(); (3) WeakHashMap 123456789101112131415161718192021222324252627282930313233343536373839404142package JVMGC;import java.util.HashMap;public class WeakHashMap &#123; public static void main(String[] args) &#123; myHashMap(); System.out.println(\"==========\"); myWeakHashMap(); &#125; private static void myWeakHashMap() &#123; java.util.WeakHashMap&lt;Integer,String&gt; map = new java.util.WeakHashMap&lt;&gt;(); Integer key = new Integer(2); String value=\"HashMap\"; map.put(key,value); System.out.println(map); key =null; System.out.println(map); System.gc(); System.out.println(map+\"\\t\"+map.size()); &#125; private static void myHashMap() &#123; HashMap&lt;Integer,String&gt; map = new HashMap&lt;&gt;(); Integer key = new Integer(1); String value=\"HashMap\"; map.put(key,value); System.out.println(map); key =null; System.out.println(map); System.gc(); System.out.println(map+\"\\t\"+map.size()); &#125;&#125; 4）虚引用形同虚设如果一个持有虚引用，都和前面不同，虚引用并不会决定对象的生命周期和没有任何引用一样，在任何时候都可能被垃圾回收器回收。引用队列RefereneQueue联合使用 finalize()清除之前做清理工作 通知机制 123456789101112131415161718192021222324package JVMGC;import java.lang.ref.PhantomReference;import java.lang.ref.ReferenceQueue;public class PhantomReferenceDemo &#123; public static void main(String[] args) throws InterruptedException &#123; Object o1 = new Object(); ReferenceQueue&lt;Object&gt; referenceQueue = new ReferenceQueue&lt;&gt;(); PhantomReference&lt;Object&gt; phantomReference = new PhantomReference&lt;&gt;(o1, referenceQueue); System.out.println(o1); System.out.println(phantomReference.get()); System.out.println(referenceQueue.poll()); System.out.println(\"============\"); o1 = null; System.gc(); Thread.sleep(500); System.out.println(o1); System.out.println(phantomReference.get()); System.out.println(referenceQueue.poll()); &#125;&#125; 5、请谈谈你对OOM的认识1）java.lang.StackOverflowError深度方法调用，出不来 12345678910111213package JVMGC;public class StackOverflowErrorDemo &#123; public static void main(String[] args) &#123; stackOverflowError(); &#125; private static void stackOverflowError()&#123; stackOverflowError(); &#125;&#125; 2）java.lang.OutOfMemoryError:Java heap space对象太多，堆爆了 3）java.lang.OutOfMemoryError:GC overhead limit exceededGC回收时间过长会抛出OutOfMemoryError，过长的定义：超过98%的时间用来做GC，并且回收了不到2%的内存迫使GC再次执行，恶性循环 -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5mjava.lang.OutOfMemoryError: GC overhead limit exceeded 4）java.lang.OutOfMemoryError:Direct buffer memoryJVM堆内存ByteBuffer.allocate（capability）第一种方式是分配JVM堆内存，属于GC管辖范围，由于需要拷贝所以速度比较慢 ByteBuffer.allocteDirect(capability)第二种方式是分配os本地内存，不属于GC管辖范围，由于不需要内存拷贝所以速度相对较快 但如果不断分配本地内存，堆内存很少使用，那么JVM就不需要执行GC，DirectByteBuffer对象们就不会被回收，这时候堆内存充足，但本地内存可能已经使用光了，再次尝试本地内存就会出现OutofMemoryError，那程序就直接崩溃了 1234567891011121314151617181920212223242526272829303132package JVMGC;import com.sun.org.apache.xpath.internal.compiler.PsuedoNames;import java.nio.ByteBuffer;/** * Exception in thread \"main\" java.lang.OutOfMemoryError: Direct buffer memory * * 导致原因： * 写NIO程序经常使用ByteBuffer来读取或者写入数据，这是一种基于通信（channel）与缓冲区（buffer）的I/O方式 * 它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作 * 提高性能，避免了Java堆和native堆来恢复这些数据 * * ByteBuffer.allocate（capability）第一种方式是分配JVM堆内存，属于GC管辖范围，由于需要拷贝所以速度比较慢 * * ByteBuffer.allocteDirect(capability)第二种方式是分配os本地内存，不属于GC管辖范围，由于不需要内存拷贝所以速度相对较快 * * 但如果不断分配本地内存，堆内存很少使用，那么JVM就不需要执行GC，DirectByteBuffer对象们就不会被回收，这时候堆内存充足，但本地内存可能已经使用光了，再次尝试本地内存就会出现OutofMemoryError，那程序就直接崩溃了 */public class DirectBufferMemoryDEmo &#123; public static void main(String[] args) &#123; System.out.println(\"配置的maxDirectMemory：\"+(sun.misc.VM.maxDirectMemory()/(double) 1024/1024)+\"MB\"); try&#123; Thread.sleep(3000); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; ByteBuffer bb = ByteBuffer.allocateDirect(6*1024*1024); &#125;&#125; 5）java.lang.OutOfMemoryError:unable to create new native thread该native thread异常与对应的平台有关 导致原因：（1）应用创建太多了线程，一个应用进程创建多个线程，超过系统承载极限（2）你的服务器并不允许你的应用程序创建这么多线程，linux系统默认允许单个进程可以创建线程数是1024个 你的应用创建超过这个数量，就会报java.lang.OutOfMemoryError:unable to create new native thread 解决方案：1.想办法降低你应用程序创建线程的数量，分析应用是否真的需要创建这么多线程，如果不是，改代码将线程数降到最低 2.对于有的应用，确实需要创建很多的线程，远超过linux系统默认的1024个线程的限制，可以通过修改linux服务器配置，扩大linux默认限制 1234567891011121314151617package JVMGC;public class UnabletoCreatenewnativethread &#123; public static void main(String[] args) &#123; for (int i=1;;i++)&#123; System.out.println(\"********* i= \"+i); new Thread(()-&gt;&#123; try&#123; Thread.sleep(Integer.MAX_VALUE); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;,\"\"+i).start(); &#125; &#125;&#125; 6）java.lang.OutOfMemoryError:MetaspaceJava8 以后 使用Metaspace来替代永久化 Metaspace是方法区在HotSpot中的实现，它与持久化最大的区别在于：Metaspace的native memory 永久代存放了以下信息：虚拟机加载的类信息常量池静态变量即时编译后的代码 模拟Metaspace空间溢出，我们不断生成类往元空间灌，类占据的空间总是会超过Metaspace指定的空间大小的 6.GC垃圾回收算法和垃圾收集器的关系？分别是什么情你谈谈（重要）1、GC算法（引用计数、复制、标记清除、标记整理）是内存回收的方法论，垃圾收集器就是算法落地实现 目前为止还没有完美的收集器出现 4种主要垃圾收集器1）串行垃圾回收器（Serial）为单线程环境设计且只使用一个线程进行垃圾回收，会暂停所有的用户线程。所以不适合服务器环境 2）并行垃圾回收器（Parallel）多个垃圾收集线程并行工作，此时线程用户是暂停的，适用于科学计算等弱交互 3）并发垃圾回收器（CMS）用户线程和垃圾收集线程同时执行（不一定并行，可能交替执行），不需要停顿用户线程 互联网公司多用它，适用对响应时间有要求的场景 4）G1垃圾回收器将堆内存分割成不同块 7. 怎么查看服务器默认的垃圾收集器是哪个？生产上如何配置垃圾收集器的？谈谈你对垃圾收集器的理解（重要）1）怎么查看默认收集器是哪个java -XX:+PrintCommandLineFlags -version-XX:InitialHeapSize=66134784 -XX:MaxHeapSize=1058156544 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC 2）默认的垃圾收集器有哪些java的gc回收的类型主要有几种？(SerialOldGC没有了)UseSerialGC,UseParallelGC,UseConcMarkSweepGC,UseParNewGC,UseParallelOldGC,UseG1GC 3）垃圾收集器（1）部分参数预先说明：DefNew- Default New Generation Tenured- Old ParNew- Parallel New Generation PSYoungGen- Parallel Scavenge ParOldGen - Parallel Old Generation （2）Server/Client模式分别是什么意思 64位 只有server模式 （3）新生代 串行GC(Serial)/(Serial Copying) 最古老、最稳定，简单高效，STW, 没有线程交互，Serial垃圾收集器依然是java虚拟机运行在Client模式下默认的新生代垃圾收集器 -XX:+UseSerialGC 并行GC(ParNew) 新生代多一点 老年代不变 老年代的CMS GC -XX:+UseParNewGC -XX:ParallelGCThreads 限制线程数量Using the ParNew young collector with the Serial old collector is deprecated and will likely be removed in a future release 并行回收GCParallel Scavenge收集器类似ParNew 是一个新生代垃圾收集器，也是一个并行的多线程的垃圾收集器，使用复制算法，俗称吞吐量优先收集器一句话：串行收集器在新生代和老年代的并行化 关注：可控制的吞吐量（Thoughput=运行用户代码时间/(运行用户代码时间+垃圾收集时间)，程序运行100分钟，垃圾收集时间1分钟，吞吐量就是99%）高吞吐量意味着高效利用CPU得时间，多用于在后台运算而不需要太多交互的任务 自适应调节也是ParallelScavenge收集器与ParNew收集器的一个区别 -XX:+UseParallelGC 或-XX:+UseParallelOLDGC(可互相激活)使用Parallel Scanvenge收集器开启后：新生代使用复制算法，老年代使用标记-整理算法 -XX:ParallelGCThreads=N,表示启动多少个GC线程CPU&gt;8 N=5/8CPU&lt;8 N=实际个数 （4）老年代 串行GC（Serial Old）/(Serial MSC)是Serial垃圾收集器老年代版本，同样是单线程收集器，使用标记-整理算法 并行GC（Parallel Old)/(Parallel MSC) XX:+UseParaqllelOldGC 并发标记清除GC（CMS）Concurrent Mark Sweep 是一种以获取最短回收停顿时间为目标的收集器CMS非常适合堆内存大、CPU核数多的服务器应用，也是G1出现之前大型应用的首选收集器 并发收集低停顿，并发指的是与用户线程一起执行 -XX:+UseConcMarkSweepGC 开启后，自动将-XX:+UseParNewGC打开，并且Serial Old 将作为CMS出错的后备收集器 4步过程： 初始标记STW标记GC Root 可以直达的对象，耗时短 并发标记和用户线程一起工作，不需要暂停工作线程Concurrent 重新标记可能有些对象因为用户程序继续运行而导致标记产生变动不需要清除STW 并发清除和用户线程一起Concurrent 代码如下： 123456789101112131415161718192021-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseConcMarkSweepGC \"[GC (CMS Initial Mark) [1 CMS-initial-mark: 4282K(6848K)] 5725K(9920K), 0.0021662 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [CMS-concurrent-mark-start]一：[GC (CMS Initial Mark) [1 CMS-initial-mark: 4968K(6848K)] 4968K(9920K), 0.0001367 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [CMS-concurrent-mark-start]二：[CMS-concurrent-mark: 0.001/0.001 secs] [Times: user=0.03 sys=0.00, real=0.00 secs] [CMS-concurrent-preclean-start][CMS-concurrent-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap三：[GC (CMS Final Remark) [YG occupancy: 109 K (3072 K)][Rescan (parallel) , 0.0009088 secs][weak refs processing, 0.0000102 secs][class unloading, 0.0003722 secs][scrub symbol table, 0.0012503 secs][scrub string table, 0.0002591 secs][1 CMS-remark: 4968K(6848K)] 5078K(9920K), 0.0029199 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 四：[CMS-concurrent-sweep-start][CMS-concurrent-sweep: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [CMS-concurrent-reset-start][CMS-concurrent-reset: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] java.lang.OutOfMemoryError: Java heap space 优点：并发收集低停顿缺点： 并发执行，对CPU资源压力大（因为用户线程和收集同时进行，CMS必须要在老年代堆内存用尽之前完成垃圾回收，否则CMS回收失败） 采用的标记清除算法会导致大量碎片 （5）垃圾收集器配置代码总结 底层代码 实际代码 1.-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseSerialGC（DefNew+Tenured） 2.-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseParNewGC（DefNew+Tenured） 3.-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseParallelGC(PSYoungGen+ParOldGen) 4.4.1 -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseParallelOldGC(PSYoungGen+ParOldGen) 4.2-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags不加就是默认UseParallelGC(PSYoungGen+ParOldGen) 5.-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseConcMarkSweepGC(par new generation + concurrent) 6.-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseG1GC -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseSerialOldGC(Java8优化没有了) 4）如何选择垃圾收集器 单CPU或小内存，单机程序 -XX:+UseSerialGC 多CPU，需要大吞吐量，如后台计算型应用 -XX:+UseParallelGC -XX:+UseParallelOldGC 多CPU，追求低停顿时间，需快速响应如互联网应用 -XX:+UseConcMarkSweepGC 8.G1垃圾收集器（重要）1) 以前收集的特点 年轻代和老年代都是各自独立且连续的内存块 年轻代收集使用单Eden+S0+S1进行复制算法 老年代收集必须扫描整个老年代区域 都是以尽可能少的而快速地执行GC为设计原则 2）G1是什么面向服务端应用，多处理器和大容量内存环境，高吞吐量的同时，满足垃圾收集暂停时间的要求：像CMS一样，与应用程序线程并发执行整理空闲空间更快需要更多的时间来预测GC停顿时间不希望牺牲大量的吞吐性能不需要更大的Java Heap G1收集器设计目标就是取代CMS收集器： 不会产生内存碎片 STW可控，G1在停顿时间上添加了预测机制，用户指定期望停顿时间 G1特点：内存划分多个独立的子区域，小范围区分新生代和老年代物理上不隔离，逻辑上分代，运行在不同代之间前后切换 3）底层原理Region 区域化垃圾收集器：最大好处是化整为零，避免全内存扫描，只需要按照区域来进行扫描即可避免全内存的GC操作，按需在年轻代和老年代之间切换 回收步骤：（小区域收集+形成连续的内存块，避免内存碎片） Eden数据移动Survivor区，若不够，Eden区会晋升到Old区 Survivor区数据移动到新的Survivor区，部分数据晋升到Old区 最后Eden区收拾干净，GC结束，用户的应用程序继续执行 4步过程： 初始标记 并发标记 最终标记 筛选标记12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576[GC pause (G1 Humongous Allocation) (young) (initial-mark), 0.0018191 secs] [Parallel Time: 1.6 ms, GC Workers: 4] [GC Worker Start (ms): Min: 239.6, Avg: 239.7, Max: 239.8, Diff: 0.2] [Ext Root Scanning (ms): Min: 0.4, Avg: 0.6, Max: 0.9, Diff: 0.5, Sum: 2.6] [Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0] [Processed Buffers: Min: 0, Avg: 0.0, Max: 0, Diff: 0, Sum: 0] [Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0] [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0] [Object Copy (ms): Min: 0.6, Avg: 0.8, Max: 0.8, Diff: 0.2, Sum: 3.0] [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0] [Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 4] [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.0, Sum: 0.1] [GC Worker Total (ms): Min: 1.3, Avg: 1.4, Max: 1.5, Diff: 0.2, Sum: 5.8] [GC Worker End (ms): Min: 241.1, Avg: 241.1, Max: 241.1, Diff: 0.0] [Code Root Fixup: 0.0 ms] [Code Root Purge: 0.0 ms] [Clear CT: 0.0 ms] [Other: 0.2 ms] [Choose CSet: 0.0 ms] [Ref Proc: 0.1 ms] [Ref Enq: 0.0 ms] [Redirty Cards: 0.0 ms] [Humongous Register: 0.0 ms] [Humongous Reclaim: 0.0 ms] [Free CSet: 0.0 ms] [Eden: 2048.0K(6144.0K)-&gt;0.0B(4096.0K) Survivors: 0.0B-&gt;1024.0K Heap: 2048.0K(10.0M)-&gt;744.1K(10.0M)] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC concurrent-root-region-scan-start][GC concurrent-root-region-scan-end, 0.0029527 secs][GC concurrent-mark-start][GC concurrent-mark-end, 0.0002335 secs][GC remark [Finalize Marking, 0.0001060 secs] [GC ref-proc, 0.0001802 secs] [Unloading, 0.0007542 secs], 0.0011648 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC pause (G1 Humongous Allocation) (young), 0.0015677 secs] [Parallel Time: 1.3 ms, GC Workers: 4] [GC Worker Start (ms): Min: 248.7, Avg: 248.9, Max: 248.9, Diff: 0.3] [Ext Root Scanning (ms): Min: 0.2, Avg: 0.3, Max: 0.5, Diff: 0.3, Sum: 1.1] [Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0] [Processed Buffers: Min: 0, Avg: 0.0, Max: 0, Diff: 0, Sum: 0] [Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0] [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0] [Object Copy (ms): Min: 0.8, Avg: 0.8, Max: 0.8, Diff: 0.0, Sum: 3.2] [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0] [Termination Attempts: Min: 1, Avg: 1.5, Max: 2, Diff: 1, Sum: 6] [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0] [GC Worker Total (ms): Min: 1.0, Avg: 1.1, Max: 1.3, Diff: 0.3, Sum: 4.4] [GC Worker End (ms): Min: 250.0, Avg: 250.0, Max: 250.0, Diff: 0.0] [Code Root Fixup: 0.0 ms] [Code Root Purge: 0.0 ms] [Clear CT: 0.1 ms] [Other: 0.2 ms] [Choose CSet: 0.0 ms] [Ref Proc: 0.1 ms] [Ref Enq: 0.0 ms] [Redirty Cards: 0.0 ms] [Humongous Register: 0.0 ms] [Humongous Reclaim: 0.0 ms] [Free CSet: 0.0 ms] [Eden: 1024.0K(4096.0K)-&gt;0.0B(3072.0K) Survivors: 1024.0K-&gt;1024.0K Heap: 826.0K(10.0M)-&gt;1190.2K(10.0M)] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Allocation Failure) 1190K-&gt;642K(10M), 0.0045317 secs] [Eden: 0.0B(3072.0K)-&gt;0.0B(4096.0K) Survivors: 1024.0K-&gt;0.0B Heap: 1190.2K(10.0M)-&gt;642.9K(10.0M)], [Metaspace: 3480K-&gt;3480K(1056768K)] [Times: user=0.02 sys=0.00, real=0.01 secs] [Full GC (Allocation Failure) 642K-&gt;624K(10M), 0.0041016 secs] [Eden: 0.0B(4096.0K)-&gt;0.0B(4096.0K) Survivors: 0.0B-&gt;0.0B Heap: 642.9K(10.0M)-&gt;624.4K(10.0M)], [Metaspace: 3480K-&gt;3480K(1056768K)] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC cleanup, 0.0000148 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC concurrent-mark-abort]Heap garbage-first heap total 10240K, used 624K [0x00000000ff600000, 0x00000000ff700050, 0x0000000100000000) region size 1024K, 1 young (1024K), 0 survivors (0K) Metaspace used 3523K, capacity 4502K, committed 4864K, reserved 1056768K class space used 391K, capacity 394K, committed 512K, reserved 1048576KException in thread \"main\" java.lang.OutOfMemoryError: Java heap space at JVMGC.helloGc.main(helloGc.java:6) 4）常用配置参数（了解） XX:+UseG1GC XX:+G1HeapRegionSize=n:设置的G1区域的大小。值是2的幂，范围是1MB到32MB。目标是根据最小的java堆大小划分出约2048个区域 XX:MaxGCPauseMilllis=n:最大GC停顿时间毫秒，这是个软目标，JVM将尽可能不小于这个时间 三步归纳：开始G1+设置最大内存+设置最大停顿时间-XX:+UseG1GC -Xmx 32g -XX:MaxGCPauseMillis=100 5）和CMS相比的优势 G1不会产生内存碎片 可以精确控制停顿。该收集器把整个堆（新生代、老年代）划分出多个固定大小的区域，每次根据允许停顿时间去收集垃圾最多的区域 6）SpringBoot优化 idea MAVEN 进行clean package 要求微服务启动时，同时配置JVMGC调优参数3.1 内3.2 外 公式：java -server jvm各种参数 -jar 第一步上面jar/war包名字 9.生产环境服务器变慢，诊断思路和性能评估1) 整机: top （uptime：系统性能命令精简版）重点：load average：系统的负载均衡 1分钟 5 分钟 15分钟 相加除3 高于60% 系统压力负载重CPUMEM：内存 2) CPU: vmstat查看CPU：vmstat - 2 3： 每个2秒采样一次，共采样3次 procs r：运行和等待CPU时间片的进程数 b：等待资源的进程数，等待磁盘的I/O，网络I/O CPU us：用户进程消耗的CPU时间百分比 sy：内核进程消耗的CPU时间百分比 us+sy大于80%，CPU不足 id：处于空闲的CPU时间百分比，越高越好 wa：系统等待IO的CPU时间的百分比 st：来自于一个虚拟机偷取的CPU时间百分比 查看额外：查看所有CPU核信息：mpstat -P ALL 2每个进程使用cpu的用量分解信息 ：pidstat -u | -p 进程编号查看进程编号：ps -ef|grep java 3) 内存：free free free -g free -m（首选） 查看额外：pidstat -p 进程号 -r 采样间隔秒 在20% - 70% 之间够用内存 4) 硬盘：df df df -h ：代表用人看的懂方式 5) 磁盘IO：iostat 磁盘I/O性能评估：iostat -xdk 2 3rkB/s：每秒读取数据量kBwkB/s：每秒写入数据量kBsvctm I/O 请求的平均服务时间，单位毫秒await I/O 请求的平均等待时间，毫秒，值越小，性能越好util:一秒中百分之几的时间用于I/O操作。接近100%，表示磁盘带宽跑满，需要优化程序或者增加磁盘 查看额外:pidstat -d 采样间隔秒数 -p 进程号 6) 网络IO：ifstat 10、假如生产环境出现CPU占用过高，请谈谈你的分析思路和定位 结合Linux和JDK命令一块分析 案例步骤1）先用top命令找出CPU占比最高的2）ps -ef 或者jps进一步定位，得知是一个怎样的一个后台程序给我们惹事ps -ef|grep java|grep -v grep 3）定位到具体线程或者代码ps -mp 进程 -o THREAD,tid,time -m 显示所有的线程-p pid 进程使用CPU的时间-o 该参数后是用户自定义格式 4）将需要的线程ID转换为16进制格式（英文小写格式） 5）jstack 进程ID | grep tid（16进制格式英文小写格式） -A60(前60行) 11、对于JDK自带的jvm监控和性能分析工具用过哪些，一般怎么用？ jps： jinfo 查看JVM的参数 查看java系统属性 jmap可以用来查看内存信息堆的对象统计 堆信息 堆内存dump jstatjstat命令可以查看堆内存各部分的使用量，以及加载类的数量。命令格式：jstat [-命令选项] [vmid] [间隔时间/毫秒] [查询次数] jstackjstack用于生成java虚拟机当前时刻的线程快照。 12、JVM字节码指令接触过吗？","categories":[{"name":"面试","slug":"面试","permalink":"https://lijiale96.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://lijiale96.github.io/tags/JVM/"},{"name":"GC","slug":"GC","permalink":"https://lijiale96.github.io/tags/GC/"},{"name":"Linux","slug":"Linux","permalink":"https://lijiale96.github.io/tags/Linux/"}]},{"title":"数据库笔记1","slug":"数据库笔记1","date":"2020-04-25T15:33:36.000Z","updated":"2020-04-29T14:55:45.158Z","comments":true,"path":"2020/04/25/数据库笔记1/","link":"","permalink":"https://lijiale96.github.io/2020/04/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B01/","excerpt":"第一章 初识数据库前言 数据库技术：如何科学地组织和存储数据，如何高效地获取和处理数据 关系的概念一个关系就是一张二维表，一个没有重复行、重复列的二维表元组：二维表每一行属性：二维表每一列域：属性的取值范围关键字：唯一的标识，不能重复 关系的特点关系必须规范化，属性不可再分割在同一关系中不允许出现相同的属性名在同一关系中元组的顺序可以任意在同一关系中属性的顺序可以任意 关系运算选择：找出满足给定条件的元组组成新的关系投影：从关系模式中指定若干属性组成新的关系连接：从两个关系的笛卡尔积中选取属性间满足一定条件的元组，组成新的关系 完整性约束（1）实体完整性：主属性值（主关系键的值）不能取空值（2）参照完整性：主键与外键的关系（3）域完整性：限制了某些属性中出现的值，把属性限制在一个优先的集合中 6、DML（data manipulation language）是数据操纵语言：它们是SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言。 DDL（data definition language）是数据定义语言：DDL比DML要多，主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用。DCL（DataControlLanguage）是数据库控制语言：是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。 1.1 数据库的好处1.持久化数据到本地2.可以实现结构化查询，方便管理 1.2 数据库相关概念文件柜：DB，数据库，Database 保存一组有组织的数据的容器定义：长期存储在计算机内的、有组织的、可共享的数据集合 管理：SQL，Structured Query Language 结构化查询语言，用于和DBMS通信的语言 管家：DBMS，数据库管理系统，又称为数据库软件，用于管理DB中的数据定义：位于应用程序与存储数据的之间的一层数据管理软件用途：科学地组织和存储数据、高效地获取和维护数据优点：相互关联、较少数据冗余、程序与数据相互独立、数据安全可靠正确、并发使用一致性 1.3 数据库存储数据的特点1、将数据放到表中2、一个数据库可以有多个表，每个表中都有一个名字，用来标识直接。表名具有唯一性3、表具有一些特性，这些特性定义了数据在表中如何存储，类似java中的“类”的设计4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成，每一列类似java的属性5、表中的数据是按行存储的，每一行类似于java中的对象DBMS分为两类： 基于共享文件系统 基于客户机","text":"第一章 初识数据库前言 数据库技术：如何科学地组织和存储数据，如何高效地获取和处理数据 关系的概念一个关系就是一张二维表，一个没有重复行、重复列的二维表元组：二维表每一行属性：二维表每一列域：属性的取值范围关键字：唯一的标识，不能重复 关系的特点关系必须规范化，属性不可再分割在同一关系中不允许出现相同的属性名在同一关系中元组的顺序可以任意在同一关系中属性的顺序可以任意 关系运算选择：找出满足给定条件的元组组成新的关系投影：从关系模式中指定若干属性组成新的关系连接：从两个关系的笛卡尔积中选取属性间满足一定条件的元组，组成新的关系 完整性约束（1）实体完整性：主属性值（主关系键的值）不能取空值（2）参照完整性：主键与外键的关系（3）域完整性：限制了某些属性中出现的值，把属性限制在一个优先的集合中 6、DML（data manipulation language）是数据操纵语言：它们是SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言。 DDL（data definition language）是数据定义语言：DDL比DML要多，主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用。DCL（DataControlLanguage）是数据库控制语言：是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。 1.1 数据库的好处1.持久化数据到本地2.可以实现结构化查询，方便管理 1.2 数据库相关概念文件柜：DB，数据库，Database 保存一组有组织的数据的容器定义：长期存储在计算机内的、有组织的、可共享的数据集合 管理：SQL，Structured Query Language 结构化查询语言，用于和DBMS通信的语言 管家：DBMS，数据库管理系统，又称为数据库软件，用于管理DB中的数据定义：位于应用程序与存储数据的之间的一层数据管理软件用途：科学地组织和存储数据、高效地获取和维护数据优点：相互关联、较少数据冗余、程序与数据相互独立、数据安全可靠正确、并发使用一致性 1.3 数据库存储数据的特点1、将数据放到表中2、一个数据库可以有多个表，每个表中都有一个名字，用来标识直接。表名具有唯一性3、表具有一些特性，这些特性定义了数据在表中如何存储，类似java中的“类”的设计4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成，每一列类似java的属性5、表中的数据是按行存储的，每一行类似于java中的对象DBMS分为两类： 基于共享文件系统 基于客户机 MySQL产品的介绍和安装MySQL常见命令 查看当前所有的数据库show databases； 打开指定的库use 库名 查看当前库的所有表show tables 查看其它库的所有表show tables from 库名 创建表create table 表名{列名 列类型列名 列类型。。。} 查看表结构desc 表名; 查看服务器的版本方式一：登录到mysql服务器select version();方式二：没有登录到mysql服务器mysql –versionmysql –V MySQL的语法规范 不区分大小写，但是建议关键字大写，表名、列名小写 每条命令最好用分号结尾 每条命令根据需要，可以进行缩进，或换行 注释 单行注释：#注释文字 单行注释：–注释文字 多行注释：/* 注释文字 */ MySQL优点体积小，速度快，成本低实体完整性、域完整性及参数完整性分别在行、列、表上实施 第二章 数据库建表原则和方式实体完整性 对关系中的记录唯一性 定义表中的所有行能唯一的标识 表中主属性（字段）不能为null且不能有相同值 一般用主键、唯一索引、unique关键字来实现 实体完整性——主键约束 primary key 表中的一个或多个字段，它的值用于唯一地标识表中的某一条记录 指定主键 任何两行都不具有相同的主键值。就是说这列的值都是互不相同的。 每个行都必须具有一个主键值。主键列不允许设置为NULL。 主键列的值不建议进行修改和更新。12345678910111213141516171819202122232425262728293031CREATE TABLE student( sno INT, sname varCHAR(10), age INT, sex VARCHAR(5) );SELECT * FROM student;CREATE TABLE teacher(id int(6),tname VARCHAR(20),address VARCHAR(50),sal DOUBLE(10,2),birthday date);create TABLE t_user(id int primary key,tname VARCHAR(10));alter table t_user drop PRIMARY KEY;ALTER table t_user add CONSTRAINT PK_ID PRIMARY KEY(id);alter TABLE t_user ADD PRIMARY KEY (id); 实体完整性——唯一约束 唯一约束不允许出现重复的值，但是可以为个null 同一个表可以有多个唯一约束，多个列组合的约束 如果不给唯一约束名称，就默认和列名相同 MySQL会给唯一约束的列上默认创建一个唯一索引123456789101112create table temp(id int not null,tname VARCHAR(25),CONSTRAINT UN_TEMP UNIQUE(id,tname));ALTER table temp drop index UN_TEMP;alter table temp add unique(tname,id);alter table temp add unique(tname);alter table temp add unique(UN_TEMP);alter table temp modify tname VARCHAR(25) unique;alter table temp add unique(tname,id); 课后作业创建一张表temp，添加主键、唯一、非空约束 12345CREATE table temp(id int not null,ts int PRIMARY KEY,CONSTRAINT UN_TEMP UNIQUE(id)) 域完整性 限制数据类型，缺省值，规则，约束，是否可以为空 域完整性可以确保不会输入无效的值 域完整性——默认约束添加默认约束 12345CREATE table tt_user(user_id INT(10) DEFAULT 3);ALTER TABLE tt_user MODIFY user_id INT(10) DEFAULT 2;ALTER TABLE tt_user MODIFY user_id INT(10); 域完整性——非空约束1stu_name VARCHAR(30) not null, 域完整性——check约束MySQL不支持check约束，但没有错误 参照完整性 指表与表之间的数据参照引用 使用外键约束实现 参照完整性——外键约束 当主表的记录被从表参照时，主表的记录将不允许删除 如果删除数据，需要先删除从表中依赖该记录的数据12345678910111213141516CREATE TABLE class(cla_id INT(6) PRIMARY KEY,cla_name VARCHAR(30) NOT NULL UNIQUE);CREATE TABLE students(stU_id int(10) PRIMARY KEY,stu_name VARCHAR(30) not null,stu_score INT(10) DEFAULT 60,cla_id INT(10),CONSTRAINT FK_CLAID FOREIGN key (cla_id) REFERENCES class(cla_id));ALTER TABLE students ADD CONSTRAINT FK_CLAID FOREIGN KEY(CLA_ID) REFERENCEs CLASS(cla_id);ALTER TABLE students drop foreign key FK_CLAID; 课后作业 创建两个表（如订单表，商品表），加入主键、默认值、外键约束 加入几条记录试试123456789101112create table orders(oid int (10) primary key,cname VARCHAR(30) not null,oprice DECIMAL(5,2) DEFAULT 0.00,DNUM INT(10) NOT null unique);create table commodity(DNUM INT(10) NOT null unique,cname VARCHAR(30) not null,CONSTRAINT FK_DNUM FOREIGN KEY (DNUM) references orders(DNUM)); 第三章 使用标准SQL增删改查DML INSERT123456789insert into class(cla_id,cla_name)values (804,'C++');insert into class(cla_id,cla_name)values (803,'控制工程'),(802,'电气工程'); insert into student values(14,'阿康',24,'男'); DML DELETE12select * from student;delete from student where sname='ak'; 课后作业 尝试删除班级表中的一班 注意外键的影响（先删约束）1234567select * from class; insert into class values(1,'一班'), (2,'二班'), (3,'三班'), (4,'四班'); delete from class where cla_name='一班'; DML UPDATEupdate对表的数据进行修改 123456789101112update student set age=18; update student set age= age+10; update student set sno=11,sex='女'; update student set age=10 where sname='李四'; 课后作业 给班级表添加一班、二班、三班 给学生表添加一班、二班、三班的学生各两条 修改二班的学生为一班 注意外键的作用1234567891011121314151617181920212223242526272829303132CREATE TABLE class(cla_id INT(6) PRIMARY KEY,cla_name VARCHAR(30) NOT NULL UNIQUE);CREATE TABLE students(stU_id int(10) PRIMARY KEY,stu_name VARCHAR(30) not null,stu_score INT(10) DEFAULT 60,cla_id INT(10),CONSTRAINT FK_CLAID FOREIGN key (cla_id) REFERENCES class(cla_id));SELECT * from class;select * from students;insert into studentsvalues(27,'lijiale',70,1),(20,'lijiahuan',null,1),(29,'xujie',50,1);insert into studentsvalues(7,'wanghuanan',80,2),(6,'lihaibin',80,2);insert into studentsvalues(4,'zhangyuxin',80,3),(5,'wangchjaunjian',80,3); update students set cla_id=1 where cla_id=2; 补充：1234567create table t1(sno int primary key AUTO_INCREMENT, -- 自增长tname VARCHAR(6))insert into t1(tname)values('li') 第四章 标准SQL数据查询基础DQL 数据查询语言查询所有数据，部分数据，可以分组查询，可以排序 12345select 列，列... from 表名where 条件group byhavingorder by DQL-带where条件12345select * from teacher where sal&gt;2000;select * from teacher where address !='济南';select * from teacher where sal&gt;1000 and address='北京';select * from teacher where sal&gt;4000 or address='上海';select * from teacher where sal&gt;400 and (address='济南' or address='新疆'); DQL-空值和常量列空值is null 和is not null 123select * from teacher where address is not null;select * from teacher where address = 'null'; 空字符串的查询，连空格都不要 1select * from teacher where address=''; 常量列1select tname,'优秀' from teacher; 单引号代表字符，不加代表数字 1select tname,11 from teacher; 小结 MySQL中空值和空字符串有所不同 空值的条件判断语法比较特别is null 和 is not null DQL-使用别名查询表头改成汉字 1select tname as 名字,sal as 薪水 from teacher as 老师; 课后作业使用别名查询student表年龄大于18并且是男性的学生信息 1select * from (select sname, age as 年龄,sex as 性别 from student as 学生)学生 where 年龄&gt;18 and 性别='男'; DQL-行数限定和排序查询第几行到第几行 123select * from teacher limit 5; --前5行select * from teacher limit 1,5; --从第2行开始查询5行select * from teacher limit 2,3; --从第3行开始 MySQL的排序order by 放在最后 ASC:升序，DESC：降序 1select * from teacher order by sal desc; 课后作业 生日降序 1select * from teacher order by birthday desc; 每位教师上涨10000工资 123update teacher set sal= sal+10000;select * from teacher;select tname,sal+1000 as 上涨 from teacher; 每位教师全年的工资总额 123update teacher set sal=sal*12; select * from teacher;select tname,sal*12 as 全年工资 from teacher; 工作地点不在济南老师信息 1select * from (select id,tname,address as 工作地点,sal,birthday from teacher as 教师)教师 where 工作地点 !='济南'; 常用函数字符串函数 length 可以返回字符串的字节长度 char_length 可以返回字符串的字符长度 一个汉字（字符）占3个字节 123select tname,length(tname) from teacher;select tname,char_length(tname) from teacher; mid 可以从某个位置获取某个长度的字符（不是字节）李家乐的家 1select tname,mid(tname,2,1) from teacher; 课后作业 查询表中名字是3个字的信息一个汉字（字符）占3个字节 查询表中的姓12345select * from teacher where char_length(tname)=3;select tname,mid(tname,1,1) as 姓 from teacher;select distinct mid(tname,1,1) as 姓 from teacher; -- 去重 数学函数 round 四舍五入 123select round(23.45678,2);select round(23.45678); least 求取最小的数字 greatest 求取最大的数字 123select least(1,2,3,4,5,6,7);select greatest(10,12,0.232,0.1,23324); 课后作业1234select(45.8793,3);select least(45,34,45,43,322); select greatest(45,34,45,43,322); 日期时间函数 now 当前日期时间 current_date 当前日期 current_time 当前时间 to_days 日期化为总天数 dayofyear 该年已过天数 week 当前时日 第几周 12345 select TO_DAYS('2020-04-25');SELECT dayofyear(now()); select week(now()); 控制流函数 if 三个参数 第一个为空 输出第三个 123select if(0,'李家乐','张雨昕');select if(null,'李家乐','张雨昕');select if('你','李家乐','张雨昕'); 否则第二个 1select if(1,'李家乐','张雨昕');--只能是数字，如果是字符输出第三个 if null 两个参数 第一个为空，输出第二个， 1select ifnull(null,'张雨昕'); 否则输出第一个 区别 if 12345678910111213 select ifnull(1,'张雨昕'); select ifnull(0,'张雨昕'); select ifnull('你','张雨昕') ``` # 第五章 模糊，聚合函数、分组查询## like 语言- 查询名字带‘李’和‘乐’的信息```sqlselect * from teacher where tname like '%李%' and tname like '%乐%';select * from teacher where tname like '%李%乐%'; 查询姓名带‘明’字老师的信息 1select * from teacher where tname like '%明%'; 查询姓名以‘明’结尾的老师的信息 1select * from teacher where tname like '%明'; 查询姓李、地址为null的老师的信息 1select * from teacher where address='null' and (tname like '李%'); _:表示任意单个字符%：表示任意0个或多个字符 查询姓名两个字的老师 1select * from teacher where tname like '__'; 查询姓名三个字的老师 1select * from teacher where tname like '___'; 查询李姓 两个字的老师 1select * from teacher where tname like '李_'; 查询李姓 两个及两个以上的老师 1select * from teacher where tname like '李_%'; 课后作业 查询地址以 北 开头的两个字的老师 查询姓名第三个字是洋的老师123select * from teacher where (address like '北%') and (tname like '__');select * from teacher where tname like '__乐%'; IN和NOT IN 语法 查询 地址在北京或者济南的老师123select * from teacher where address='北京' or address = '杭州';select *from teacher where address in('北京','杭州'); 查询 地址不在北京或者济南的老师不等于: != 或 &lt;&gt;123select * from teacher where address&lt;&gt;'北京' and address &lt;&gt;'杭州';select *from teacher where address not in('北京','杭州'); 聚合函数 是一组值执行计算并返回单一结果的函数 一张表本身就是一个组 count 可以统计总记录数 12select count(*) from teacher;select count(1) from teacher; 查询地址在济南的老师有多少个 1select count(1) from teacher where address='济南'; min 可以统计最小值 1select min(sal) from teacher; max 可以统计最大值 1select max(sal),min(sal) from teacher; avg 平均值 1select avg(sal) from teacher; sum 总和 1select sum(sal) from teacher; 课后作业 查询工资等于3000的老师的总数 查询地址在济南的老师的平均工资、最高工资、最低工资 123select sum(sal=144120.00)from teacher;select avg(sal),max(sal),min(sal) from teacher where address='上海'; 注： 1where sal = max(sal) 是错误的 子查询- 一行一列 查询工资最高的老师信息 1select * from teacher where sal = (select max(sal) from teacher); 查询跟张明老师在同一个地址的老师信息 1234select * from teacher where address in(select address from teacher where tname='张明')and tname !='张明'; 课后作业 查询工资大于平均工资的老师信息 查询工资和张明老师一样的老师的信息，不包括张明 1234567select * from teacher where sal&gt;(select avg(sal) from teacher);select * from teacherwhere sal in(select sal from teacher where tname= '李家乐') and tname !='李家乐'; 分组查询group by 可以对一张表自定义的分成若干组，这样就可以分组统计数据 1select ... from ... where ... group by 字段1[,字段2，字段3] 统计各部门的平均工资 123select deptno,avg(sal) as '平均工资' from teacher group by deptno;select deptno,address,avg(sal) as '平均工资' from teacher group by deptno,address; 求各部门教师的总工资数目、平均工资、最低工资、最高工资 123select deptno,sum(sal) as '总工资',count(*) as '总人数',avg(sal) as '平均工资', min(sal) as '最低工资',max(sal) as '最高工资'from teachergroup by deptno having 查询平均工资大于30000的部门号，升序 1234select avg(sal),deptno from teacher group by deptnohaving avg(sal)&gt;30000order by avg(sal) 查询各部门济南人的平均工资，降序 12345select deptno,avg(sal)from teacherwhere address = '济南'group by deptnoorder by avg(sal) desc; 第六章 连表查询连接查询内连接 inner join12345select * from teacher t,dept dwhere t.deptno = d.idselect * from teacher tinner join dept d on t.deptno =d .id 右连接 right join假如教师表没有4号部门的老师也想展示4号部门的信息左边有的空，部门想展示在右边 恰与左连接相反，返回右表中的所有行，如果右表中行在左表中没有匹配行，则结果中左表中的列返回空值。 12select * from teacher tright join dept d on t.deptno =d .id 左连接 left join概念：返回左表中的所有行，如果左表中行在右表中没有匹配行，则结果中右表中的列返回空值。 12select * from dept d left join teacher t on t.deptno =d .id 全连接12345select * from teacher tright join dept d on t.deptno =d .idunionselect * from dept d left join teacher t on t.deptno =d .id 课后作业 给学生添加班级字段 新建班级表 使用内连接外链接等作相似的查询123456789101112131415161718192021222324252627282930313233343536373839404142434445-- 给学生添加班级字段-- 新建班级表-- 使用内连接外链接等作相似的查询alter table student add class int default 0;create table class1(cid int (10) primary key,name varchar(30) not null)ALTER TABLE class1 MODIFY name varchar(40) DEFAULT null;insert into class1 values(1,'一班'),(2,'二班'),(3,'三班'),(4,'四班');insert into class1 values(5,null),(6,null);delete from student;select * from class1select * from studentinsert into student values(1,'李家乐',24,'男',1),(2,'李家欢',24,'男',2),(3,'李家成',24,'男',3),(4,'李家昕',24,'女',4),(5,'李家婷',24,'女',1),(6,'李家俞',24,'女',3);insert into student values(7,'李家琦',24,'男',null),(8,'李家合',24,'男',null),(9,'李家宽',24,'男',null);select * from student sinner join class1 c on s.class =c.cidselect * from student sright join class1 c on s.class =c.cidunionselect * from student sleft join class1 c on s.class =c.cid 笛卡尔积 连接查询都有on来跟随连接条件 如果没有on，会产生笛卡尔积的错误12select * from dept d inner join teacher t 第七章 数据库综合案例1、题目一 求个部门老师的平均工资 老师平均工资大于3000的学校 sql查询老师信息 查询部门名称12345select avg(sal) from teacher;select * from teacherwhere sal&gt;(select avg(sal) from teacher);select * from teacher;select address from teacher; 2、题目二ID 新闻编号， 整数型 自增字段 Title 新闻标题 ， 字符串型(varchar) Content 新闻内容，Text型 Hits 点击次数， 整数类型 AddDateTime 添加时间 ，字符串（YYYY-MM-DD) 1）查询最新10条新闻，只列出新闻标题和添加时间 1SELECT TOP 10 Title, AddDateTime FROM News ORDER BY AddDateTime DESC 说明：如果新闻增加时是按时间发生的先后顺序添加的话，也可以按ID来排序（因为ID为自增字段，ID越大的应越新），即： 1SELECT TOP 10 Title, AddDateTime FROM News ORDER BY ID DESC （2）查询最热门的8条新闻的标题和点击次数 查询语句为： 1SELECT TOP 8 Title, Hits FROM News ORDER BY Hits DESC 3、题目三SQL 查询 7天内 发表文章 数量 最多的10个用户 条件栏目id=2表名U_Article表列:文章id 用户名称 添加日期 栏目id 表内列内容的解释:文章id为 数字用户名称为 中文添加日期格式为 2011/4/17 0:43:10栏目id为 数字 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172SQL 查询 100天内 发表文章 数量 最多的2个用户 条件栏目id=2表名U_Article表列:文章id 用户名称 添加日期 栏目id 表内列内容的解释:文章id为 数字用户名称为 中文添加日期格式为 2011/4/17 0:43:10栏目id为 数字create table U_Article( id int(10), UserName varchar(30), AddTime date, LanMu_Id int(10))select * from U_Article;insert into U_Article values(1,'aa','2020-04-22',1),(2,'aa','2020-03-12',2),(3,'bb','2020-04-21',3),(4,'cc','2020-04-21',3),(5,'bb','2020-04-23',1),(6,'aa','2020-02-23',2),(7,'cc','2020-01-14',4),(8,'dd','2020-01-23',5),(9,'dd','2020-02-11',6),(10,'cc','2020-01-20',3),(12,'bb','2020-01-12',2),(13,'cc','2020-02-23',1),(14,'aa','2020-03-21',4),(15,'bb','2020-02-05',5),(16,'aa','2020-02-01',2),(17,'dd','2020-01-11',2),(18,'cc','2020-03-11',3),(19,'bb','2020-02-21',2),(29,'bb','2020-02-21',2),(39,'bb','2020-02-21',2),(49,'bb','2020-02-21',2),(59,'bb','2020-02-21',2),(69,'bb','2020-02-21',2),(79,'bb','2020-02-21',2),(20,'aa','2020-04-11',2); update student set age=10 where sname='李四'; update U_Article set id =1 where UserName ='aa' update U_Article set id =2 where UserName ='bb' update U_Article set id =3 where UserName ='cc' SELECT *FROM (SELECT COUNT(Id) AS diancms, UserName,idFROM U_ArticleWHERE (DATEDIFF(CURRENT_DATE, AddTime) &lt;= 100) and LanMu_Id=1GROUP BY Id, UserName) DianCMSTableORDER BY diancms DESClimit 2 select * from U_Article where UserName ='aa' and (DATEDIFF(CURRENT_DATE, AddTime) &lt;= 100) and LanMu_Id=1 4、题目四 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273-- 统计最近10天登陆最频繁的10个用户，排序并打印出这10个用户各登陆多少次create table web( client_id int(10) primary key, user_name varchar(30), login_timestamp date)alter client_idselect * from web;insert into web values(1,'aa','2020-04-22'),(2,'aa','2020-03-12'),(3,'bb','2020-04-21'),(4,'cc','2020-04-21'),(5,'bb','2020-04-23'),(6,'aa','2020-02-23'),(7,'cc','2020-01-14'),(8,'dd','2020-01-23'),(9,'dd','2020-02-11'),(10,'cc','2020-01-20'),(12,'bb','2020-01-12'),(13,'cc','2020-02-23'),(14,'aa','2020-03-21'),(15,'bb','2020-02-05'),(16,'aa','2020-02-01'),(17,'dd','2020-01-11'),(18,'cc','2020-03-11'),(19,'bb','2020-02-21'),(20,'aa','2020-04-19');insert into web values(21,'aa','2020-04-18'),(22,'aa','2020-04-17'),(23,'aa','2020-04-16'),(24,'aa','2020-04-15'),(25,'aa','2020-04-14'),(26,'aa','2020-04-13'),(27,'aa','2020-04-13'),(28,'aa','2020-04-11'),(29,'aa','2020-04-21'),(30,'aa','2020-04-11'),(31,'aa','2020-04-21'),(32,'aa','2020-04-11'),(33,'aa','2020-04-01'),(34,'aa','2020-04-21'),(35,'aa','2020-04-11'),(36,'aa','2020-04-01'); update web set client_id =1 where user_name ='aa'; update web set client_id =2 where user_name ='bb'; update web set client_id =3 where user_name ='cc'; update web set client_id =4 where user_name ='dd' ;select * from (select client_id as id, user_name as 用户,count(*) as 登录次数from web as 网站where (datediff(CURRENT_DATE,login_timestamp)&lt;=10)group by client_id,user_name) 网站 order by 登录次数 desclimit 10","categories":[{"name":"数据库","slug":"数据库","permalink":"https://lijiale96.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://lijiale96.github.io/tags/MySQL/"},{"name":"dml","slug":"dml","permalink":"https://lijiale96.github.io/tags/dml/"},{"name":"dql","slug":"dql","permalink":"https://lijiale96.github.io/tags/dql/"},{"name":"模糊查询聚合","slug":"模糊查询聚合","permalink":"https://lijiale96.github.io/tags/%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%E8%81%9A%E5%90%88/"},{"name":"分组和连接","slug":"分组和连接","permalink":"https://lijiale96.github.io/tags/%E5%88%86%E7%BB%84%E5%92%8C%E8%BF%9E%E6%8E%A5/"}]},{"title":"大厂面试题1","slug":"大厂面试题1","date":"2020-04-15T05:33:36.000Z","updated":"2020-05-08T02:59:54.486Z","comments":true,"path":"2020/04/15/大厂面试题1/","link":"","permalink":"https://lijiale96.github.io/2020/04/15/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%981/","excerpt":"JUC多线程及高并发1.请你谈谈对volatile的理解概念 JVM（java虚拟机） JMM（java内存模型）抽象概念，并不存在 主内存 工作内存 硬盘&lt;内存&lt;CPU 缓存cache","text":"JUC多线程及高并发1.请你谈谈对volatile的理解概念 JVM（java虚拟机） JMM（java内存模型）抽象概念，并不存在 主内存 工作内存 硬盘&lt;内存&lt;CPU 缓存cache 1.volatile是java虚拟机提供的轻量级的同步机制（乞丐版的synchronized） 1 保证可见性 2 不保证原子性 3 禁止指令重排对Volatile变量进行写操作 写操作后加入store屏障指令对Volatile变量进行读操作，读操作前加入load屏障指令 2.JMM你谈谈2.1 可见性2.2 原子性（volatile不支持）2.3 代码演示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import java.util.concurrent.TimeUnit;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.atomic.AtomicInteger;/** * 1 验证volatile的可见性 * 1.1 假如 int number = 0 ；number变量之前根本没有添加volatile关键字修饰，没有可见性 * 1.2 添加了volatile，可以解决可见性问题 * * 2 验证volatile不保证原子性 * 2.1 原子性值得是什么意思？ * 不可分割，完整性，也即某个线程正在做某个具体业务时，中间不可以被加塞或者会被分割 * 要么同时成功，要么同时失败 * * 2.2 是否可以保证原子性的 * * 2.3 why？ * 时间太快，在putfield时， 后面的线程写覆盖前面的线程 * * 2.4 如何解决原子性 * * 加sync * * 使用我们的juc下的AtomicInteger----&gt; CAS */public class VolatileDemo &#123; public static void main(String[] args) &#123;// seeOkByVolatile(); MyData myData = new MyData(); for (int i=1;i&lt;=20;i++) &#123; new Thread(()-&gt;&#123; for (int j=1;j&lt;1000;j++)&#123; myData.addPlusPlus(); myData.addMyAtomic(); &#125; &#125;,String.valueOf(i)).start(); &#125; while (Thread.activeCount()&gt;2)&#123; Thread.yield(); &#125; System.out.println(Thread.currentThread().getName()+\"\\t int type,finally number value: \"+myData.number); System.out.println(Thread.currentThread().getName()+\"\\t AtomicInteger type,finally number value: \"+myData.atomicInteger); &#125; //volatile 可以保证可见性，及时通知其它线程，主物理内存的值已经被修改 private static void seeOkByVolatile() &#123; MyData myData = new MyData(); new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+\"\\t come in\"); //暂停一会线程 try&#123; TimeUnit.SECONDS.sleep(3);&#125; catch (InterruptedException e)&#123;e.printStackTrace();&#125; myData.addT060(); System.out.println(Thread.currentThread().getName()+\"\\t updated number value: \"+myData.number); &#125;,\"AAA\").start(); while(myData.number==0)&#123; &#125; System.out.println(Thread.currentThread().getName()+\"\\t mission is over,main get number value\"+ myData.number); &#125;&#125;class MyData&#123;//MyData.java===》 MyData.class ===》JVM字节码 volatile int number=0; public void addT060()&#123; this.number=60; &#125; //number前面加了volatile，不保证原子性 public void addPlusPlus()&#123; number++; &#125; AtomicInteger atomicInteger = new AtomicInteger(); public void addMyAtomic()&#123; atomicInteger.getAndIncrement(); &#125;&#125; 2.4 有序性单线程不考虑取决于数据依懒性多线程环境中线程交替执行，由于编译器优化重拍的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测 2.5 线程安全性获得保证 工作内存与主内存同步延迟现象导致的可见性问题 可以使用synchronized或volatile关键字解决，他们都可以使一个线程修改后的变量立即对其他线程可见 对于指令重排导致的可见性问题和有序性问题 可以利用volatile关键字解决，因为volatile的另外一个作用就是禁止重排序优化 单例模式懒汉 1234567891011121314151617181920212223242526272829303132public class SingletonDemo &#123; private static SingletonDemo instance = null; private SingletonDemo()&#123; System.out.println(Thread.currentThread().getName()+\"\\t 我是构造方法SingletonDemo()\"); &#125; public static synchronized SingletonDemo getInstance()&#123; if (instance == null)&#123; instance= new SingletonDemo(); &#125; return instance; &#125; public static void main(String[] args) &#123;// System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());// System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());// System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());//// System.out.println();// System.out.println();// System.out.println(); //并发多线程 for(int i=1;i&lt;=10;i++)&#123; new Thread(()-&gt;&#123; SingletonDemo.getInstance(); &#125;,String.valueOf(i)).start(); &#125; &#125; &#125; DCL（双端检测）不一定线程安全，原因是有指令重排序的存在，加入volatile可以禁止指令重排 123456789101112131415161718192021222324252627282930313233343536373839public class SingletonDemo &#123; private static volatile SingletonDemo instance = null; private SingletonDemo()&#123; System.out.println(Thread.currentThread().getName()+\"\\t 我是构造方法SingletonDemo()\"); &#125; //DCL (Double Check Lock双端检锁机制 public static SingletonDemo getInstance()&#123; if (instance == null)&#123; synchronized (SingletonDemo.class) &#123; if (instance==null)&#123; instance= new SingletonDemo(); &#125; &#125; &#125; return instance; &#125; public static void main(String[] args) &#123;// System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());// System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());// System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());//// System.out.println();// System.out.println();// System.out.println(); //并发多线程 for(int i=1;i&lt;=10;i++)&#123; new Thread(()-&gt;&#123; SingletonDemo.getInstance(); &#125;,String.valueOf(i)).start(); &#125; &#125; &#125; 2.CAS你知道吗？2.1 比较并交换12345678910111213141516import java.util.concurrent.atomic.AtomicInteger;/** * 1 CAS是什么？ ==&gt;compareAndSet * 比较并交换 */public class CASDemo &#123; public static void main(String[] args) &#123; AtomicInteger atomicInteger = new AtomicInteger(5); //main do System.out.println(atomicInteger.compareAndSet(5, 2019)+\"\\t current data: \"+atomicInteger.get()); System.out.println(atomicInteger.compareAndSet(5, 1024)+\"\\t current data: \"+atomicInteger.get()); &#125;&#125; 2.2 CAS底层原理？如果知道，谈谈你对Unsafe的理解1、atomicInteger.getAndIncrement 2、Unsafe 123456789101112// setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(\"value\")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; private volatile int value; 1）、unsafe是CAS的核心类，由于java方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。Unsafe类存在于sun.misc包中注:Unsafe类的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务 2）、变量valueOffset，表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址来获取数据的 12345678/** * Atomically increments by one the current value. * * @return the previous value */ public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1); &#125; 3）、value用volatile修饰，保证了多线程之间的内存可见性 CAS，Compare and Swap，是一条CPU并发原语完全依赖于硬件原语执行必须是连续的，在执行过程中不允许被中断，不会造成数据不一致问题，并发安全 12345678public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5; &#125; var1 对象本身var2 该对象值的引用地址var4 需要变动的数量var5 是用var1 var2找出的主内存的真实的值用当前值和var5比较：相同，更新var5+var4，返回true不同，继续取值并比较，直到更新完成 3、CAS是什么1）unsafe假设线程A和线程B两个线程同时执行getAndInt操作（分别跑在不同CPU）（1）AtomicIntger里面的value原始值为3，即主内存中AtomicInteger的value为3，根据JMM模型，线程A和线程B各自持有一份值为3的value副本分别到各自的工作内存（2）线程A通过getIntVolatile（var1，var2）拿到value值3，这时线程A被挂起（3）线程BgetIntVolatile（var1，var2）方法获取到value值3，此时刚好线程B没有被挂起并执行compareAndSwapInt方法比较内存值也为3，成功修改内存值为4，线程B打完收工（4）这时线程A恢复，执行compareAndSwapInt方法比较，发现自己手里的值数字3和主内存的4不一致，说明该值已经被其他线程抢先一步修改过了，那线程A本次修改失败，只能重新读取重新来一遍（5）线程A重新获取value，因为变量是volatile，所以其它线程对它的修改，线程A总是能够看到，线程A继续执行compareAndSwap进行替换，直到成功 Unsafe+CAS（自旋） 2）底层原理 3）小结比较当前工作内存中的值和主内存的值，如果相同则执行规定操作否则继续比较直到主内存和工作内存的值一致为止 CAS应用CAS有3个操作数，内存值V，旧的预期值A，要修改的更新值B当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则说明都不做 2.3 CAS缺点1、 循环时间长开销大（自旋，子程序）getAndAddInt 有dowhile2、只能保证一个共享变量的原子操作3、ABA问题 3.原子类的AtomicInteger的ABA问题谈谈？原子更新引用知道吗？1、ABA问题怎么产生的时间差尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的 2、原子引用123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.concurrent.atomic.AtomicReference;public class AtomicReferenceDemo &#123; public static void main(String[] args) &#123; User z3 = new User(\"z3\",22); User li4=new User(\"li4\",25); AtomicReference&lt;User&gt; atomicReference = new AtomicReference&lt;&gt;(); atomicReference.set(z3); System.out.println(atomicReference.compareAndSet(z3,li4)+\"\\t\"+atomicReference.get().toString()); System.out.println(atomicReference.compareAndSet(z3,li4)+\"\\t\"+atomicReference.get().toString()); &#125;&#125;class User&#123; String userName; int age; public String getUserName() &#123; return userName; &#125; public int getAge() &#123; return age; &#125; public User(String userName, int age) &#123; this.userName = userName; this.age = age; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"userName='\" + userName + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 3、时间戳原子引用修改版本号（类似时间戳） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicReference;import java.util.concurrent.atomic.AtomicStampedReference;public class ABADemo &#123; static AtomicReference&lt;Integer&gt; atomicReference = new AtomicReference&lt;&gt;(100); static AtomicStampedReference&lt;Integer&gt; atomicStampedReference = new AtomicStampedReference&lt;&gt;(100,1); public static void main(String[] args) &#123; System.out.println(\"============ABA问题====================\"); new Thread(()-&gt;&#123; atomicReference.compareAndSet(100,101);//狸猫换太子 atomicReference.compareAndSet(101,100); &#125;,\"t1\").start(); new Thread(()-&gt;&#123; //暂停1秒钟t2线程，保证上面的t1线程完成了一次ABA操作 try&#123; TimeUnit.SECONDS.sleep(1); &#125;catch (InterruptedException e)&#123;e.printStackTrace();&#125; System.out.println(atomicReference.compareAndSet(100,2019)+\"\\t\"+atomicReference.get()); &#125;,\"t2\").start(); try&#123; TimeUnit.SECONDS.sleep(2); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.println(\"==============以下是ABA问题的解决===================\"); new Thread(()-&gt;&#123; int stamp = atomicStampedReference.getStamp(); System.out.println(Thread.currentThread().getName()+\"\\t第1次版本号：\"+stamp); //暂停1秒钟t3线程 try&#123;TimeUnit.SECONDS.sleep(1);&#125;catch (InterruptedException e)&#123;e.printStackTrace();&#125; atomicStampedReference.compareAndSet(100,101,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1); System.out.println(Thread.currentThread().getName()+\"\\t第2次版本号：\"+atomicStampedReference.getStamp()); atomicStampedReference.compareAndSet(101,100,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1); System.out.println(Thread.currentThread().getName()+\"\\t第3次版本号：\"+atomicStampedReference.getStamp()); &#125;,\"t3\").start(); new Thread(()-&gt;&#123; int stamp = atomicStampedReference.getStamp(); System.out.println(Thread.currentThread().getName()+\"\\t第1次版本号：\"+stamp); //暂停3秒钟t4线程,保证上面的t3线程完成了一次ABA操作 try&#123; TimeUnit.SECONDS.sleep(3); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; boolean result = atomicStampedReference.compareAndSet(100,2019,stamp,stamp+1); System.out.println(Thread.currentThread().getName()+\"\\t修改成功否：\"+result+\"\\t当前最新实际版本号：\"+atomicStampedReference.getStamp()); System.out.println(Thread.currentThread().getName()+\"\\t当前实际最新值: \"+atomicStampedReference.getReference()); &#125;,\"t4\").start(); &#125;&#125; 4、我们知道ArrayList是线程不安全，请编码写一个不安全的案例并给出解决方案方案1* 1 故障现象 * java.util.ConcurrentModificationException * * 2 导致原因 * * * 3 解决方案 * 3.1 List&lt;String&gt; list= new Vector&lt;&gt;();//加锁，安全，并发性下降 * 3.2 List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;()); * * 4 优化建议方案2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.util.*;import java.util.concurrent.CopyOnWriteArrayList;/** * 集合类不安全的问题 * ArrayList */public class ContainerNotSafeDemo &#123; public static void main(String[] args) &#123;// List&lt;String&gt; list= new ArrayList&lt;&gt;();//不安全，并发性提高// List&lt;String&gt; list= new Vector&lt;&gt;();//加锁，安全，并发性下降// List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;()); List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();// Collection;//接口// Collections;//接口的辅助类// list.add(\"a\");// list.add(\"b\");// list.add(\"c\");// for (String element :list)&#123;// System.out.println(element);// &#125; for(int i=1;i&lt;=30;i++)&#123; new Thread(()-&gt;&#123; list.add(UUID.randomUUID().toString().substring(0,8)); System.out.println(list); &#125;,String.valueOf(i)).start(); &#125; //java.util.ConcurrentModificationException /** * 1 故障现象 * java.util.ConcurrentModificationException * * 2 导致原因 * 并发争抢修改导致，参考我们的花名册的签名情况 * 一个人在写入，另外一个同学过来抢夺，导致数据不一致异常，并发修改异常 * * 3 解决方案 * 3.1 List&lt;String&gt; list= new Vector&lt;&gt;();//加锁，安全，并发性下降 * 3.2 List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;()); * 3.3 List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); * * 4 优化建议 */ /** * 写时复制 * CopyOnWrite容器即写时复制的容器。添加时，先copy，复制一个newElements，然后往里面添加元素，之后，指向新的容器setArray(newElements)。好处：并发的读，不需要加锁 * 因为当前容器不会添加任何元素 * 读写分离思想，读和写不同的容器 * public boolean add(E e) &#123; * final ReentrantLock lock = this.lock; * lock.lock(); * try &#123; * Object[] elements = getArray(); * int len = elements.length; * Object[] newElements = Arrays.copyOf(elements, len + 1); * newElements[len] = e; * setArray(newElements); * return true; * &#125; finally &#123; * lock.unlock(); * &#125; * &#125; */ &#125;&#125; 补充：HashSet底层原理：12345678910111213// Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object(); /** * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has * default initial capacity (16) and load factor (0.75). */ public HashSet() &#123; map = new HashMap&lt;&gt;(); &#125; public boolean add(E e) &#123; return map.put(e, PRESENT)==null; &#125; key是e，value是present（static final） 5、公平锁/非公平锁/可重入锁/递归锁、自旋锁谈谈你的理解？请手写一个自旋锁1、公平锁和非公平锁是什么公平锁 是指多个线程按照申请锁的顺序来获取锁，类似排队打饭，先来后到 非公平锁 是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。在高并发情况下，有可能会造成优先级反转或饥饿现象（排了一天都没等到） 123public ReentrantLock() &#123; sync = new NonfairSync();&#125; 两者区别公平锁：FIFO 非公平锁：插队，尝试失败，再类似公平锁 题外话Java ReentrantLock而言通过构造函数指定该锁是否公平锁，默认是非公平锁。非公平锁优点在于吞吐量比公平锁大 对于Synchronized而言，也是一种非公平锁 2、可重入锁（递归锁）是什么ReentrantLock同一线程外层函数获得锁之后，内层递归函数仍然获取该锁的代码在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁即，线程可以进入任何一个它已经拥有的锁所同步着的代码块。（主人进大门，厕所不会上锁） ReentrantLock/Sychronized就是一个典型的可重入锁可重入锁最大的作用是避免死锁ReentrantLockDemo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import org.omg.CORBA.PUBLIC_MEMBER;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class ReenterLockDemo &#123; public static void main(String[] args) &#123; Phone phone =new Phone(); new Thread(()-&gt;&#123; try &#123; phone.sendSMS(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;,\"t1\").start(); new Thread(()-&gt;&#123; try &#123; phone.sendSMS(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;,\"t2\").start(); Thread t3 = new Thread(phone,\"t3\"); Thread t4 = new Thread(phone,\"t4\"); try&#123; TimeUnit.SECONDS.sleep(1); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.println(); System.out.println(); System.out.println(); System.out.println(); t3.start(); t4.start(); &#125;&#125;/** * t1 invoked sendSMS() 在同一个线程在外层方法获取锁的时候 * t1 #####invoked sendEmail() 在进入内层方法会自动获取锁 * t2 invoked sendSMS() * t2 #####invoked sendEmail() * */class Phone implements Runnable&#123; public synchronized void sendSMS() throws Exception&#123; System.out.println(Thread.currentThread().getName()+\"\\t invoked sendSMS()\"); sendEmail(); &#125; public synchronized void sendEmail() throws Exception&#123; System.out.println(Thread.currentThread().getName()+\"\\t #####invoked sendEmail()\"); &#125; Lock lock = new ReentrantLock(); @Override public void run() &#123; get(); &#125; public void get() &#123; lock.lock();// lock.lock(); try&#123; System.out.println(Thread.currentThread().getName()+\"\\t invoked get()\"); set(); &#125;finally &#123; lock.unlock();// lock.unlock(); &#125; &#125; public void set() &#123; lock.lock(); try&#123; System.out.println(Thread.currentThread().getName()+\"\\t #####invoked set()\"); &#125;finally &#123; lock.unlock(); &#125; &#125;&#125; 3、自旋锁（spinlock）是指尝试获取锁的线程不会立即阻塞，而是采用循坏的方式去尝试取锁，这样的好处是减少线程上下文切换的消耗，缺点是循坏会消耗CPU 手写一个自旋锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger;import java.util.concurrent.atomic.AtomicReference;public class SpinLockDemo &#123; AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;&gt;(); public void myLock()&#123; Thread thread = Thread.currentThread(); System.out.println(Thread.currentThread().getName()+\"\\t come in \"); while(!atomicReference.compareAndSet(null,thread))&#123; &#125; &#125; public void myUnlock()&#123; Thread thread =Thread.currentThread(); atomicReference.compareAndSet(thread,null); System.out.println(Thread.currentThread().getName()+\"\\t invoked myUnLock()\"); &#125; public static void main(String[] args) &#123; SpinLockDemo spinLockDemo = new SpinLockDemo(); new Thread(()-&gt;&#123; spinLockDemo.myLock(); try&#123; TimeUnit.SECONDS.sleep(5); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; spinLockDemo.myUnlock(); &#125;,\"AA\").start(); try&#123;TimeUnit.SECONDS.sleep(1);&#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; new Thread(()-&gt;&#123; spinLockDemo.myLock(); try&#123;TimeUnit.SECONDS.sleep(1);&#125;catch (InterruptedException e)&#123; e.printStackTrace();&#125; spinLockDemo.myUnlock(); &#125;,\"BB\").start(); &#125;&#125; 4、独占锁（写锁）/共享锁（读锁）、互斥锁独占锁：该锁一次只能被一个线程所持有。对ReentrantLock和Synchronized而言都是独占锁 共享锁：指该锁可被多个线程所持有 对ReentrantReadWriteLock其读锁是共享锁，其写锁是独占锁 多个线程同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行。 读读共存读写不共存写写不共存 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import java.util.HashMap;import java.util.Map;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;import java.util.concurrent.locks.ReentrantReadWriteLock;/** * 多个线程同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行。 * * 读读共存 * 读写不共存 * 写写不共存 * * 写操作：原子+独占,整个过程必须是一个完整的统一体，中间不许被分割，被打断 */public class ReadWriteLockDemo &#123; public static void main(String[] args) &#123; MyCache myCache = new MyCache(); for (int i = 1; i &lt;= 5; i++) &#123; final int tempInt =i; new Thread(() -&gt; &#123; myCache.put(tempInt+\"\",tempInt+\"\"); &#125;,String.valueOf(i)).start(); &#125; for (int i = 1; i &lt;= 5; i++) &#123; final int tempInt =i; new Thread(() -&gt; &#123; myCache.get(tempInt+\"\"); &#125;,String.valueOf(i)).start(); &#125; &#125;&#125;class MyCache&#123;//资源类 private volatile Map&lt;String,Object&gt;map = new HashMap&lt;&gt;(); private ReentrantReadWriteLock rwlock=new ReentrantReadWriteLock(); public void put(String key,Object value)&#123; rwlock.writeLock().lock(); try&#123; System.out.println(Thread.currentThread().getName()+\"\\t 正在写入：\"+key); try&#123; TimeUnit.SECONDS.sleep(3); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; map.put(key,value); System.out.println(Thread.currentThread().getName()+\"\\t 写入完成：\"); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; rwlock.writeLock().unlock(); &#125; &#125; public void get(String key)&#123; rwlock.readLock().lock(); try&#123; System.out.println(Thread.currentThread().getName()+\"\\t 正在读取：\"+key); try&#123; TimeUnit.SECONDS.sleep(3); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; Object result = map.get(key); System.out.println(Thread.currentThread().getName()+\"\\t 读取完成：\"+result); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; rwlock.readLock().unlock(); &#125; &#125;&#125; 6.CountDownLatch/CycliCBarrier/Semaphore 使用过吗1、CountDownLatch让一些线程阻塞直到另一些线程完成一系列操作后才被唤醒CountDownLatcH主要有两个方法await 阻塞countDown 计数器减1，直至0，await线程被唤醒，继续执行 1234567891011121314151617181920212223242526272829303132import java.util.concurrent.CountDownLatch;public class CountDownLatchDemo &#123; public static void main(String[] args) throws Exception&#123; CountDownLatch countDownLatch = new CountDownLatch(6); for (int i=1;i&lt;=6;i++)&#123; new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+\"国，被灭\"); countDownLatch.countDown(); &#125;,CountryEnum.forEach_CountryEnum(i).getRetMessage()).start(); &#125; countDownLatch.await(); System.out.println(Thread.currentThread().getName()+\"\\t**********秦帝国一统六国\"); System.out.println(); System.out.println(CountryEnum.One); System.out.println(CountryEnum.One.getRetCode()); System.out.println(CountryEnum.One.getRetMessage()); &#125; private static void closeDoor() throws InterruptedException &#123; CountDownLatch countDownLatch = new CountDownLatch(6); for (int i=1;i&lt;=6;i++)&#123; new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+\"\\t 上完自习，离开教室\"); countDownLatch.countDown(); &#125;,String.valueOf(i)).start(); &#125; countDownLatch.await(); System.out.println(Thread.currentThread().getName()+\"\\t**********班长最后关门走人\"); &#125;&#125; 枚举：(mysql数据库） 123456789101112131415161718192021222324252627282930public enum CountryEnum &#123; One(1,&quot;齐&quot;),Two(2,&quot;楚&quot;),THREE(3,&quot;燕&quot;),FOUR(4,&quot;赵&quot;),FIVE(5,&quot;魏&quot;),SIX(6,&quot;韩&quot;); private Integer retCode; private String retMessage; public Integer getRetCode() &#123; return retCode; &#125; public String getRetMessage() &#123; return retMessage; &#125; CountryEnum(Integer retCode, String retMessage) &#123; this.retCode &#x3D; retCode; this.retMessage &#x3D; retMessage; &#125; public static CountryEnum forEach_CountryEnum(int index)&#123; CountryEnum[] myArray&#x3D;CountryEnum.values(); for (CountryEnum element : myArray) &#123; if (index&#x3D;&#x3D;element.getRetCode())&#123; return element; &#125; &#125; return null; &#125;&#125; 2、CyclicBarrier递增 12345678910111213141516171819202122232425import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;public class CyclicBarrierDemo &#123; public static void main(String[] args) &#123; CyclicBarrier cyclicBarrier = new CyclicBarrier(7,()-&gt;&#123; System.out.println(\"*********召唤神龙\"); &#125;); for (int i=1;i&lt;=7;i++) &#123; final int tempInt =i; new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+\"\\t收集到第：\"+tempInt+\"龙珠\"); try&#123; cyclicBarrier.await(); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125;catch (BrokenBarrierException e)&#123; e.printStackTrace(); &#125; &#125;,String.valueOf(i)).start(); &#125; &#125;&#125; 3、Semaphore信号量主要有两个目的：一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制多对多，抢车位 12345678910111213141516171819202122232425262728import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;public class SemaphoreDemo &#123; public static void main(String[] args) &#123; Semaphore semaphore = new Semaphore(3); for (int i=1;i&lt;=6;i++)&#123; new Thread(()-&gt;&#123; try&#123; semaphore.acquire(); System.out.println(Thread.currentThread().getName()+\"\\t抢到车位\"); //暂停一会儿线程 try&#123; TimeUnit.SECONDS.sleep(3); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\"\\t停车3秒后离开车位\"); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125;finally &#123; semaphore.release(); &#125; &#125;,String.valueOf(i)).start(); &#125; &#125;&#125; 7、阻塞队列你知道吗？队列+阻塞队列先进先出 当阻塞队列空，获取元素会被阻塞 当阻塞队列满，添加元素会被阻塞 生产者消费者模式、MQ消息中间件原理 为什么用？有什么好处？在某些情况下 挂起线程（阻塞），满足条件，被挂起的线程又会被唤醒 不用关心什么时候阻塞什么时候唤醒，BlockingQueue一手包办 BlockingQueue的核心方法 ArrayBlockingQueue:由数组结构组成的有界阻塞队列 LinkedBlockingQueue：由链表结构组成的有界（但大小默认值为Integer.MAX_VAULUE）阻塞队列 priorityBlockingQueue：支持优先级排序的无界阻塞队列 DelayQueue：使用优先级队列实现的延迟无界阻塞队列 SynchronousQueue：不存储元素的阻塞队列，也即单个元素队列 每一个put必须要等待一个take操作，否则不能继续添加元素 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.concurrent.BlockingQueue;import java.util.concurrent.SynchronousQueue;import java.util.concurrent.TimeUnit;public class SynchronousQueueDemo &#123; public static void main(String[] args) throws InterruptedException&#123; BlockingQueue&lt;String&gt; blockingQueue = new SynchronousQueue&lt;&gt;(); new Thread(()-&gt;&#123; try &#123; System.out.println(Thread.currentThread().getName()+\"\\t put 1\"); blockingQueue.put(\"1\"); System.out.println(Thread.currentThread().getName()+\"\\t put 2\"); blockingQueue.put(\"2\"); System.out.println(Thread.currentThread().getName()+\"\\t put 3\"); blockingQueue.put(\"3\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;,\"AAA\").start(); new Thread(()-&gt;&#123; try &#123; try&#123; TimeUnit.SECONDS.sleep(5); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\"\\t\"+blockingQueue.take()); try&#123; TimeUnit.SECONDS.sleep(5); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\"\\t\"+blockingQueue.take()); try&#123; TimeUnit.SECONDS.sleep(5); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\"\\t\"+blockingQueue.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;,\"BBB\").start(); &#125;&#125; LinkedTransferQueue：由链表结构组成的无界阻塞队列 LinkedBlockingDeque：由链表结构组成的双向阻塞队列 架构梳理+种类分析用在哪里 生产者消费者模式 传统版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import com.sun.org.apache.bcel.internal.generic.NEW;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class ShareData&#123; private int number =0; private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); public void increment() throws Exception &#123; //1 判断 lock.lock(); try &#123; while (number != 0) &#123; //等待，不能生产,多线程为while condition.await(); &#125; //2 干活 number++; System.out.println(Thread.currentThread().getName() + \"\\t\" + number); //通知唤醒 condition.signalAll(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void decrement() throws Exception &#123; //1 判断 lock.lock(); try &#123; while (number == 0) &#123; //等待，不能生产 condition.await(); &#125; //2 干活 number--; System.out.println(Thread.currentThread().getName() + \"\\t\" + number); //通知唤醒 condition.signalAll(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; /** * 题目：一个初始值为0的变量，两个线程对其交替操作，一个加1一个减1，来5轮 * * 1 线程 操作(方法) 资源类 * 2 判断 干活 通知 * 3 防止虚假唤醒机制 * */public class ProdConsumer_TraditionDemo &#123; public static void main(String[] args) &#123; ShareData shareData =new ShareData(); new Thread(()-&gt;&#123; for (int i=1;i&lt;=5;i++)&#123; try &#123; shareData.increment(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;,\"AA\").start(); new Thread(()-&gt;&#123; for (int i=1;i&lt;=5;i++)&#123; try &#123; shareData.decrement(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;,\"BB\").start(); new Thread(()-&gt;&#123; for (int i=1;i&lt;=5;i++)&#123; try &#123; shareData.increment(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;,\"CC\").start(); new Thread(()-&gt;&#123; for (int i=1;i&lt;=5;i++)&#123; try &#123; shareData.decrement(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;,\"DD\").start(); &#125;&#125; 阻塞队列版为什么需要BlockingQueue？我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，一手包办1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger;/** * volatile /CAS/AtomicInteger/BlockQueue/线程交互/原子引用 */public class ProConsumer_BlockQueueDemo &#123; public static void main(String[] args) throws Exception &#123; MyResource myResource = new MyResource(new ArrayBlockingQueue&lt;&gt;(10)); new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+\"\\t 生产线程启动\"); try &#123; myResource.myProd(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;,\"prod\").start(); new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+\"\\t 消费线程启动\"); System.out.println(); System.out.println(); try &#123; myResource.myConsumer(); System.out.println(); System.out.println(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;,\"Consumer\").start(); try&#123; TimeUnit.SECONDS.sleep(5); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.println(); System.out.println(); System.out.println(); System.out.println(\"5秒钟时间到，大老板main线程叫停，活动结束\"); myResource.stop(); &#125;&#125;class MyResource&#123; private volatile boolean FLAG = true;//默认开启，进行生产+消费 private AtomicInteger atomicInteger = new AtomicInteger(); BlockingQueue&lt;String&gt; blockingQueue =null; public MyResource(BlockingQueue&lt;String&gt; blockingQueue)&#123; this.blockingQueue=blockingQueue; System.out.println(blockingQueue.getClass().getName()); &#125; public void myProd()throws Exception&#123; String data = null; boolean retValue; while(FLAG)&#123; data = atomicInteger.incrementAndGet()+\"\"; retValue=blockingQueue.offer(data,2L, TimeUnit.SECONDS); if (retValue)&#123; System.out.println(Thread.currentThread().getName()+\"\\t 插入队列\"+data+\"成功\"); &#125;else&#123; System.out.println(Thread.currentThread().getName()+\"\\t 插入队列\"+data +\"失败\"); &#125; TimeUnit.SECONDS.sleep(1); &#125; System.out.println(Thread.currentThread().getName()+\"\\t 大老板叫停了，表示FLAG=false,生产动作结束\"); &#125; public void myConsumer() throws Exception &#123; String result =null; while(FLAG)&#123; result = blockingQueue.poll(2L,TimeUnit.SECONDS); if (null==result || result.equalsIgnoreCase(\"\"))&#123; FLAG =false; System.out.println(Thread.currentThread().getName()+\"\\t 超过2秒钟没有取到蛋糕，消费退出\"); System.out.println(); System.out.println(); return; &#125; System.out.println(Thread.currentThread().getName()+\"\\t消费队列蛋糕\"+result+\"成功\"); &#125; &#125; public void stop() throws Exception&#123; this.FLAG =false; &#125;&#125; Callable 接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;import java.util.concurrent.TimeUnit;public class CallableDemo &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(new MYThread2());// FutureTask&lt;Integer&gt; futureTask2 = new FutureTask&lt;&gt;(new MYThread2()); new Thread(futureTask,\"AA\").start(); new Thread(futureTask,\"BB\").start();// int result02=futureTask.get(); System.out.println(Thread.currentThread().getName()+\"*************\"); int result01=100;// while(!futureTask.isDone())&#123;//// &#125; int result02=futureTask.get();//要求获得callable线程的计算结果，如果没有计算完成就要去强求，会导致阻塞，值得计算完成 System.out.println(\"********result:\"+(result01+result02)); &#125;&#125;//class MyThread implements Runnable&#123;//// @Override// public void run() &#123;//// &#125;//&#125;class MYThread2 implements Callable&lt;Integer&gt;&#123; @Override public Integer call() throws Exception &#123; System.out.println(\"*********come in Callable\"); try&#123; TimeUnit.SECONDS.sleep(3); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; return 1024; &#125;&#125; 线程池 消息中间件 补充： Synchronized和Lock的区别，用新的Lock有什么好处123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134import sun.security.provider.SHA;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 1 原始构成 * Synchronized 是关键字属于JVM层面 * monitorenter（底层是通过monitor对象来完成，其实wait/notify等方法也依赖于monitor对象只有在同步块或方法中才能调用wait/notify等方法） * monitoexit * Lock是具体类（java.util.concurrent.Locks.Lock）是api层面的锁 * * 2 使用方法 * synchronized 不需要用户去手动释放锁，当synchronized代码执行完后系统会自动让线程释放对锁的占用（不会死锁） * ReentrantLock 则需要用户去手动释放锁若没有主动释放锁，就有可能导致出现死锁现象 * 需要Lock（）和unLock（）方法配合try/finally语句块来完成。 * * 3 等待释放可中断 * synchronized 不可中断，除非抛出异常正常运行完成 * ReetrantlOCK 可中断， 1、设置超时方法 tryLock（long timeout，TimeUnit unit） * 2、lockInterruptibly（）放代码块中，调用interrupt()方法可中断 * 4 加锁是否公平 * synchronized 非公平锁 * ReentrantLock 两者都可以，默认非公平锁，构造方法可以传入boolean值，true为公平锁，false为非公平锁 * * 5 锁绑定多个条件condition * synchronized没有 * ReentrantLock 用来实现分组唤醒需要唤醒的线程们，可以精确唤醒，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程 *//** * 题目：多线程之间按顺序调用 实现A-》B-》C 三个线程启动，要求如下 * AA打印5次，BB打印次，CC打印15次 * 紧接着 * AA打印着5次，BB打印10次，CC打印15次 * 。。。。 * 10轮 * */class ShareResource&#123; private int number =1; //A:1,B；2 C;3 private Lock lock=new ReentrantLock(); private Condition c1 = lock.newCondition(); private Condition c2 = lock.newCondition(); private Condition c3 = lock.newCondition(); public void print5()&#123; lock.lock(); try&#123; //1 判断 while(number!=1)&#123; c1.await(); &#125; //2 干活 for (int i=0;i&lt;5;i++)&#123; System.out.println(Thread.currentThread().getName()+\"\\t\"+i); &#125; //3 通知 number=2; c2.signal(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; public void print10()&#123; lock.lock(); try&#123; //1 判断 while(number!=2)&#123; c2.await(); &#125; //2 干活 for (int i=0;i&lt;10;i++)&#123; System.out.println(Thread.currentThread().getName()+\"\\t\"+i); &#125; //3 通知 number=3; c3.signal(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; public void print15()&#123; lock.lock(); try&#123; //1 判断 while(number!=3)&#123; c3.await(); &#125; //2 干活 for (int i=0;i&lt;15;i++)&#123; System.out.println(Thread.currentThread().getName()+\"\\t\"+i); &#125; //3 通知 number=1; c1.signal(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125;&#125;public class SyncAndReentrantLockDemo &#123; public static void main(String[] args) &#123;// synchronized (new Object()) &#123; ShareResource shareResource = new ShareResource(); new Thread(()-&gt;&#123; for (int i=1;i&lt;=10;i++)&#123; shareResource.print5(); &#125; &#125;,\"A\").start(); new Thread(()-&gt;&#123; for (int i=1;i&lt;=10;i++)&#123; shareResource.print10(); &#125; &#125;,\"B\").start(); new Thread(()-&gt;&#123; for (int i=1;i&lt;=10;i++)&#123; shareResource.print15(); &#125; &#125;,\"C\").start(); &#125;&#125; 8、线程池用过吗？ThreadPoolExecutor谈谈你的了解？为什么用线程池，优势控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量的线程排队等候，等其他线程执行完毕后，再从队列中取出任务来执行 线程复用，控制最大并发数，管理线程 降低资源消耗 提高响应速度 提高线程的可管理性 线程池如何使用？架构说明Executor 、Executors、ExecutorService、ThreadPoolExecutor 编码实现 了解 Executors.newScheduledThreadPool() java8 新出 Excutors.newWorksStealingPool(int) 重点 Executors.newFixedThreadPool(int) 定长线程池 1234567*/ public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory); &#125; Executors.newSingleThreadExcutor() 单线程化 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; Executors.newCachedThreadPool() 可缓存线程池 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; ThreadPoolExcutor Executors.newFixedThreadPool(int) 定长线程池 1234567*/ public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory); &#125; Executors.newSingleThreadExcutor() 单线程化 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; Executors.newCachedThreadPool() 可缓存线程池 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 线程池的几个重要参数介绍123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial * parameters. * * @param corePoolSize the number of threads to keep in the pool, even * if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param maximumPoolSize the maximum number of threads to allow in the * pool * @param keepAliveTime when the number of threads is greater than * the core, this is the maximum time that excess idle threads * will wait for new tasks before terminating. * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument * @param workQueue the queue to use for holding tasks before they are * executed. This queue will hold only the &#123;@code Runnable&#125; * tasks submitted by the &#123;@code execute&#125; method. * @param threadFactory the factory to use when the executor * creates a new thread * @param handler the handler to use when execution is blocked * because the thread bounds and queue capacities are reached * @throws IllegalArgumentException if one of the following holds:&lt;br&gt; * &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt; * &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt; corePoolSize&#125; * @throws NullPointerException if &#123;@code workQueue&#125; * or &#123;@code threadFactory&#125; or &#123;@code handler&#125; is null */ public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; corePoolSize:线程池中的常驻核心线程数 把到达的任务放到缓存队列中 maximumPoolSize：线程池能够容纳同时执行的最大线程数，此值必须大于等于1 keepAliveTime：多余的空闲线程的存活时间 unit ：keepAliveTime的单位 workQueue：任务队列，被提交但尚未被执行的任务 threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程一般用默认的即可 handler：拒绝策略，表示当队列满了并且工作 说说线程池的底层工作原理以下重要：1、在创建了线程池后，等待提交过来的任务请求2、当调用execute（）方法添加了一个请求任务时，线程池会做如下判断： 2.1 如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务 2.2 如果正在运行的线程数量大于或者等于corePoolSize，那么将这个任务放入队列 2.3 如果这时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么创建非核心线程立刻运行这个任务； 2.4 如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行3、当一个线程完成任务时，它会从队列中取下一个任务来执行4、当一个线程无事可做超过一定的时间（keepAliveTime）时，线程池会判断 如果当前运行的线程数大于corePoolSize，那么这个线程就会被停掉 所以线程池的所有任务完成后它最终会收缩到corePoolSize的大小 9、线程池用过吗？生产上你如何设置合理参数线程池的拒绝策略你谈谈是什么等待队列满了，max线程也达到了，无法继续新的服务 拒绝策略 AbortPolicy（默认）：直接抛出 异常阻止系统正常运行 CallerRunsPolicy：调用者运行 一种调节机制，不会抛弃任务，也不会抛弃异常，而是将某些任务回退到调用者，降低新的任务流量 DiscardOldestPolicy：抛弃等待队列中的等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务 DiscardPolicy：直接丢弃任务，不予任何处理也不抛出异常 内置拒绝策略均实现了RejectedExecutionHandler接口单一的/固定数的/可变的三种创建线程池的方法，你用哪个多？一个都不用不允许Exectuors,通过ThreadPoolExecutor的方式线程资源必须提供线程池提供，不允许在应用中自行显示创建线程1）newFixedThreadPool和newSingleThreadExcutor因为会堆积大量的请求，导致OOM2）newCachedThreadPool创建大量的线程，导致OOM 你在工作中是如何使用线程池的，是否自定义过线程池使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.util.Timer;import java.util.concurrent.*;/** * 第4种获得/使用java多线程的方式，线程池 */public class MyThreadPoolDemo &#123; public static void main(String[] args) &#123;// threadPoolInit();// new ThreadPoolExecutor.CallerRunsPolicy()); ExecutorService threadPool = new ThreadPoolExecutor( 2, 5, 1L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;(3), Executors.defaultThreadFactory(),// new ThreadPoolExecutor.AbortPolicy());// new ThreadPoolExecutor.DiscardOldestPolicy()); new ThreadPoolExecutor.DiscardPolicy()); try&#123; for (int i=1;i&lt;=10;i++)&#123; threadPool.execute(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+\"\\t 办理事务\"); &#125;); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; threadPool.shutdown(); &#125; &#125; private static void threadPoolInit() &#123; ExecutorService threadPool = Executors.newFixedThreadPool(5);//一池5个处理线程// ExecutorService threadPool = Executors.newSingleThreadExecutor();//一池1个处理线程// ExecutorService threadPool = Executors.newCachedThreadPool();//一池1个处理线程 try &#123; //模拟10个用户来办理业务，每个用户是一个来自外部的请求线程 for (int i=1;i&lt;10;i++)&#123; threadPool.execute(() -&gt; &#123; System.out.println(Thread.currentThread().getName()+\"\\t 办理业务\"); &#125;); try&#123; TimeUnit.MILLISECONDS.sleep(200); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; threadPool.shutdown(); &#125; &#125;&#125; 合理配置 CPU密集型 需要大量的运算，没有阻塞，CPU一直全速运行 多核CPU 配置尽可能少的线程数量：CPU核数+1个线程的线程池 IO密集型 并不是一直执行任务，应配置尽可能多的线程，如CPU核数*2 需要大量IO ，即大量的阻塞，需要多配置线程数：CPU核数/（1-阻塞系数） 阻塞系数在0.8~0.9之间 10、死锁编码及定位分析是什么 产生死锁的原因：争夺资源造成互相等待的现象： 系统资源不足、进程运行推进的顺序不合适、资源分配不当 代码(手写)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package thread;import java.util.concurrent.TimeUnit;/** * */public class DeadLockDemo &#123; public static void main(String[] args) &#123; String lockA = \"lockA\"; String lockB = \"lockB\"; new Thread(new HoldLockThread(lockA, lockB), \"ThreadAAA\").start(); new Thread(new HoldLockThread(lockB, lockA), \"ThreadBBB\").start(); /** * linux ps -eflgrep xxxx ls -l * window 进程号 jstack */ &#125;&#125;class HoldLockThread implements Runnable&#123; private String lockA; private String lockB; public HoldLockThread(String lockA, String lockB) &#123; this.lockA = lockA; this.lockB = lockB; &#125; @Override public void run() &#123; synchronized (lockA)&#123; System.out.println(Thread.currentThread().getName()+\"\\t 直接持有：\"+lockA+\"\\t 尝试获得：\"+lockB); try&#123; TimeUnit.SECONDS.sleep(2); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125;finally &#123; &#125; synchronized (lockB)&#123; System.out.println(Thread.currentThread().getName()+\"\\t 直接持有：\"+lockB+\"\\t 尝试获得：\"+lockA); &#125; &#125; &#125;&#125; 解决（通过底层，不一定只有日志）jps命令定位进程号jstack找到死锁查看","categories":[{"name":"面试","slug":"面试","permalink":"https://lijiale96.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"JUC","slug":"JUC","permalink":"https://lijiale96.github.io/tags/JUC/"},{"name":"synchronized","slug":"synchronized","permalink":"https://lijiale96.github.io/tags/synchronized/"},{"name":"volatile","slug":"volatile","permalink":"https://lijiale96.github.io/tags/volatile/"}]},{"title":"算法笔记12","slug":"算法笔记12","date":"2020-04-13T08:33:36.000Z","updated":"2020-04-13T11:46:03.359Z","comments":true,"path":"2020/04/13/算法笔记12/","link":"","permalink":"https://lijiale96.github.io/2020/04/13/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B012/","excerpt":"程序员常用10种算法1.1 二分查找算法（非递归）1.1.1 介绍有序数组O（log2^n)","text":"程序员常用10种算法1.1 二分查找算法（非递归）1.1.1 介绍有序数组O（log2^n) 1.1.2 代码实现123456789101112131415161718192021222324252627282930313233package com.atguigu.binarysearchnorecursion;public class BinarySearchNoRecur &#123; public static void main(String[] args) &#123; int[] arr=&#123;1,3,8,10,11,67,100&#125;; int index = binarySearch(arr,2); System.out.println(\"index=\"+index);//0 &#125; //二分查找的非递归实现 /** * * @param arr 待查找的数组,arr是升序排序 * @param target 需要查找的数 * @return 返回对应下标，-1表示没有找到 */ public static int binarySearch(int[] arr,int target)&#123; int left =0; int right = arr.length -1; while(left&lt;=right)&#123; //说明可以继续查找 int mid =(left+right)/2; if (arr[mid]==target)&#123; return mid; &#125;else if(arr[mid]&gt;target)&#123; right = mid-1;//需要向左边查找 &#125;else&#123; left = mid+1;//需要向右边查找 &#125; &#125; return -1; &#125;&#125; 1.2 分治算法1.2.1 介绍分而治之快速排序，归并排序，傅里叶变换汉诺塔 1.2.2 基本步骤1）分解2）解决3）合并 1.2.3 Divide and Conquer 设计模式1.2.4 汉诺塔代码实现 123456789101112131415161718192021222324package com.atguigu.binarysearchnorecursion.dac;public class Hanoitower &#123; public static void main(String[] args) &#123; hanoiTower(5,'A','B','C'); &#125; //汉诺塔的移动方法 //使用分治算法 public static void hanoiTower(int num,char a,char b,char c)&#123; //如果只有一个盘 if (num==1)&#123; System.out.println(\"第1个盘从 \"+a+\"-&gt;\"+c); &#125;else&#123; //如果我们有n&gt;=2 情况， 我们总是可以看做是两个盘 1.最下边一个的盘，2.上面的所有盘 //1.先把最上面的盘A-&gt;B,移动过程会使用到c hanoiTower(num-1,a,c,b); //2.把最下边的盘A-&gt;C System.out.println(\"第\"+num+\"个盘从 \"+a+\"-&gt;\"+c); //3.把B塔的所有盘 从B-&gt;C,移动过程使用到a塔 hanoiTower(num-1,b,a,c); &#125; &#125;&#125; 1.3 动态规划算法1.3.1 应用场景1）要求达到的目标为装入的背包的总价值最大，并且重量不超出2）要求装入的物品不能重复 1.3.2 动态规划算法介绍1）将大问题划分为小问题2）与分治类似3）区别：经分解得到的子问题不是相互独立的4）填表推进，最优解 1.3.3 思路1.3.4 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.atguigu.dynamic;import javax.xml.xpath.XPath;public class KnapsackProblem &#123; public static void main(String[] args) &#123; int[] w =&#123;1,4,3&#125;;//物品的重量 int[] val = &#123;1500,3000,2000&#125;;//物品的价值 这里val[i] 就是前面讲的v[i] int m=4;//背包的容量 int n = val.length;//物品的个数 //创建二维数组 //v[i][j] 表示在前i个物品中能够装入容量为j的背包中的最大价值 int[][] v = new int[n+1][m+1]; //为了记录放入商品的情况，我们定一个二维数组 int[][] path = new int[n+1][m+1]; //初始化第一行和第一列，这里可以不处理，默认就是0 for (int i=0;i&lt;v.length;i++)&#123; v[i][0]=0;//将第一列设置为0 &#125; for (int i=0;i&lt;v[0].length;i++)&#123; v[0][i]=0;//将第一行设置0 &#125; //根据前面的公式来动态规划处理 for (int i=1;i&lt;v.length;i++)&#123;//不处理第一行 i是从1开始的 for (int j=1;j&lt;v[0].length;j++)&#123;//不处理第一列，j是从1开始的 //公式 if (w[i-1]&gt;j)&#123;//程序是从1开始的，公式是从0开始的 v[i][j]=v[i-1][j]; &#125;else&#123; //说明： //i是从1开始的，调整// v[i][j]=Math.max(v[i-1][j],val[i-1]+v[i-1][j-w[i-1]]); //为了记录商品存放到背包，使用if-else来体现公式 if (v[i-1][j]&lt;val[i-1]+v[i-1][j-w[i-1]])&#123; v[i][j] =val[i-1]+v[i-1][j-w[i-1]]; //把当前的情况记录到path path[i][j]=1; &#125;else&#123; v[i][j]=v[i-1][j]; &#125; &#125; &#125; &#125; //输出一下v 看看目前的情况 for (int i=0;i&lt;v.length;i++)&#123; for (int j=0;j&lt;v[i].length;j++)&#123; System.out.print(v[i][j]+\" \"); &#125; System.out.println(); &#125; System.out.println(\"================================\"); //输出最后我们是放入哪些商品 //遍历path,这样输出会把所有的放入情况都得到，其实我们只需要最后的放入// for (int i=0;i&lt;path.length;i++)&#123;// for (int j=0;j&lt;path[i].length;j++)&#123;// if (path[i][j]=1) &#123;// System.out.printf(\"第%d个商品放入到背包\\n\", i);// &#125;// &#125;// &#125; //动脑筋 int i= path.length-1;//行的最大下标 int j= path[0].length-1;//列的最大下标 while(i&gt;0)&#123;//从path的最后开始找 if(path[i][j]==1)&#123; System.out.printf(\"第%d个商品放入到背包\\n\", i); j-=w[i-1];//w[i-1] &#125; i--; &#125; &#125;&#125; 1.4 KMP算法1.4.1 字符串匹配问题1.4.2 暴力匹配算法并假设str1匹配到i位置，子串str2匹配到j位置，则有：1）如果当前字符匹配成功（str1[i]==str2[j]),则i++，j++，继续匹配下一个字符2）如果失配（str1[i]!=str2[j]），令i=i-(j-1),j=0。相当于每次匹配失败时，i回溯，j被置为0.3）用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间4）暴力匹配实现 1234567891011121314151617181920212223242526272829303132333435363738394041package com.atguigu.kmp;public class ViolenceMatch &#123; public static void main(String[] args) &#123; //暴力匹配 String str1 =\"硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好\"; String str2 =\"尚硅谷你尚硅你\"; int index = violenceMath(str1,str2); System.out.println(\"index=\"+index); &#125; //暴力匹配算法 public static int violenceMath(String str1,String str2)&#123; char[] s1=str1.toCharArray(); char[] s2=str2.toCharArray(); int s1Len = s1.length; int s2Len = s2.length; int i=0;//i索引指向s1 int j=0;//j索引指向s2 while(i&lt;s1Len &amp;&amp; j&lt;s2Len)&#123; //保证匹配时，不越界 if (s1[i]==s2[j])&#123;//匹配成功 i++; j++; &#125;else&#123;//没有匹配成功 //如果失配（即str1[i] !=str2[j],令i=i-（j-1),j=0 i=i-(j-1); j=0; &#125; &#125; //判断是否匹配成功 if (j==s2Len)&#123; return i-j; &#125;else&#123; return -1; &#125; &#125;&#125; 1.4.3 KMP算法介绍KMP是一个解决模式串在文本串是否出现过利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配的位置，省去了大量的时间 1.4.4 应用实例字符串匹配问题;判断str1是否含有str2，如果存在，就返回第一次出现的位置，如果没有，返回-1代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.atguigu.kmp;import java.util.Arrays;public class KMPAlgorithm &#123; public static void main(String[] args) &#123; String str1 = \"BBC ABCDAB ABCDABCDABDE\"; String str2 = \"ABCDABD\";// String str2 = \"BBC\"; int[] next =kmpNext(\"ABCDABD\");//[0,1，2,0] System.out.println(\"next=\"+ Arrays.toString(next)); int index =kmpSearch(str1,str2,next); System.out.println(\"index=\"+index);//15 &#125; //写出我们的kmp搜索算法 /** * * @param str1 源字符串 * @param str2 子串 * @param next 部分匹配表，是子串对应的部分匹配表 * @return 如果是-1 没有匹配到，否则就返回第一个匹配的位置 */ public static int kmpSearch(String str1,String str2,int[] next)&#123; //遍历 for (int i=0,j=0;i&lt;str1.length();i++)&#123; //需要处理str1.charAt(i) != str2.charAt(j),去调整j的大小 //KMP算法核心点 while(j&gt;0 &amp;&amp; str1.charAt(i) != str2.charAt(j))&#123; j = next[j-1]; &#125; if (str1.charAt(i)==str2.charAt(j))&#123; j++; &#125; if (j==str2.length())&#123; //找到了 //j=3 i return i-j+1; &#125; &#125; return -1; &#125; //获取到一个字符串（子串）的部分匹配值表 public static int[] kmpNext(String dest)&#123; //创建一个next 数组保存部分匹配值 int[] next = new int[dest.length()]; next[0]=0;//如果字符串是长度为1部分匹配值就是0 for (int i=1,j=0;i&lt;dest.length();i++)&#123; //当dest.charAt(i)!=dest.charAt(j),我们需要从Next[j-1]获取新的j //直到我们发现有 dest.charAt(i) == dest.charAt(j)成立才退出 //这时kmp算法的核心点 while(j&lt;0&amp;&amp;dest.charAt(i)!=dest.charAt(j))&#123; j=next[j-1]; &#125; //当dest.charAt(i)==dest.charAt(j）满足时，部分匹配值就是+1 if (dest.charAt(i)==dest.charAt(j))&#123; j++; &#125; next[i]=j; &#125; return next; &#125;&#125; 1.5 贪心算法1.5.1 集合覆盖问题如何选择最少的广播台，让所有的地区都可以接收到信号 1.5.2 贪心算法的介绍1）每一步选择都采取最好最优的选择2）得到的结果不一定是最优的结果，但都是相似接近最优解的结果 1.5.3 集合覆盖1）穷举法，效率低，消耗时间 2^n-12）贪心算法，效率高 代码实现: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.atguigu.greedy;import java.util.ArrayList;import java.util.HashMap;import java.util.HashSet;public class GreedyAlgorithm &#123; public static void main(String[] args) &#123; //创建广播电台，放入到Map HashMap&lt;String, HashSet&lt;String&gt;&gt; broadcasts = new HashMap&lt;String,HashSet&lt;String&gt;&gt;(); //将各个电台放入到broadcasts HashSet&lt;String&gt; hashSet1 = new HashSet&lt;String&gt;(); hashSet1.add(\"北京\"); hashSet1.add(\"上海\"); hashSet1.add(\"天津\"); HashSet&lt;String&gt; hashSet2 = new HashSet&lt;String&gt;(); hashSet2.add(\"广州\"); hashSet2.add(\"北京\"); hashSet2.add(\"深圳\"); HashSet&lt;String&gt; hashSet3 = new HashSet&lt;String&gt;(); hashSet3.add(\"成都\"); hashSet3.add(\"上海\"); hashSet3.add(\"杭州\"); HashSet&lt;String&gt; hashSet4 = new HashSet&lt;String&gt;(); hashSet4.add(\"上海\"); hashSet4.add(\"天津\"); HashSet&lt;String&gt; hashSet5 = new HashSet&lt;String&gt;(); hashSet5.add(\"杭州\"); hashSet5.add(\"大连\"); //加入到map broadcasts.put(\"K1\",hashSet1); broadcasts.put(\"K2\",hashSet2); broadcasts.put(\"K3\",hashSet3); broadcasts.put(\"K4\",hashSet4); broadcasts.put(\"K5\",hashSet5); //allAreas 存放所有的地区 HashSet&lt;String&gt; allAreas = new HashSet&lt;String&gt;(); allAreas.add(\"北京\"); allAreas.add(\"上海\"); allAreas.add(\"天津\"); allAreas.add(\"广州\"); allAreas.add(\"深圳\"); allAreas.add(\"成都\"); allAreas.add(\"杭州\"); allAreas.add(\"大连\"); //创建ArrayList，存放选择的电台 ArrayList&lt;String&gt; selects= new ArrayList&lt;String&gt;(); //定义一个临时的集合，在遍历的过程中，存放遍历过程的电台覆盖的地区和当前还没有覆盖的地区的交集 HashSet&lt;String&gt; tempSet = new HashSet&lt;String&gt;(); //定义给maxkey，保存在一次遍历过程中，能够覆盖最大未覆盖的地区对应的电台的key //如果maxKey 不为null，则会加入到selects String maxKey = null; while(allAreas.size()!=0)&#123;//如果allAreas不为0，则还没有覆盖到所有的地区 //每进行一次while，需要 maxKey =null; //遍历broadcasts，取出对应的key for (String key:broadcasts.keySet())&#123; //每进行一次for tempSet.clear(); //当前这个key能够覆盖的地区 HashSet&lt;String&gt; areas = broadcasts.get(key); tempSet.addAll(areas); //求出tempset和allAreas集合的交集，交集会赋给tempset tempSet.retainAll(allAreas); //如果当前这个集合包含的未覆盖地区的数量，比maxKey指向的集合地区还多 //就需要重置maxKey //tempSet.size() &gt; broadcasts.get(maxKey).size()) 体现出贪心算法的特点，每次都选择最优的 if(tempSet.size()&gt;0 &amp;&amp; (maxKey==null || tempSet.size() &gt; broadcasts.get(maxKey).size()))&#123; maxKey =key; &#125; &#125; //maxKey!=null,就应该将maxkey加入 selects if (maxKey!=null)&#123; selects.add(maxKey); //将maxkey指向的广播电台覆盖的地区，从allAreas 去掉 allAreas.removeAll(broadcasts.get(maxKey)); &#125; &#125; System.out.println(\"得到的选择结果是\"+selects);//[k1,k2,k3,k5] &#125;&#125; 1.6 普利姆算法1.6.1 修路问题在7个村庄之间修路，连通7个村庄，使路的长度最短 1.6.2 最小生成树MST:N个边，N-1条边 1.6.3 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.atguigu.prim;import java.util.Arrays;public class PrimAlgorithm &#123; public static void main(String[] args) &#123; //测试看看图是否创建成功 char[] data = new char[]&#123;'A','B','C','D','E','F','G'&#125;; int verxs = data.length; //邻接矩阵的关系使用二维数组表示,10000这个大数，表示两个点不连通 int [][]weight = new int[][]&#123; &#123;10000,5,7,10000,10000,10000,2&#125;, &#123;5,10000,10000,9,10000,10000,3&#125;, &#123;7,10000,10000,10000,8,10000,10000&#125;, &#123;10000,9,10000,10000,10000,4,10000&#125;, &#123;10000,10000,8,10000,10000,5,4&#125;, &#123;10000,10000,10000,4,5,10000,6&#125;, &#123;2,3,10000,10000,4,6,10000&#125;,&#125;; //创建MGraph MGraph graph = new MGraph(verxs); //创建一个MinTree对象 MinTree minTree = new MinTree(); minTree.createGraph(graph,verxs,data,weight); //输出 minTree.showGraph(graph); //测试普利姆算法 minTree.prim(graph,1); &#125; &#125;//创建最小生成树-&gt;村庄的图class MinTree&#123; //创建图的邻接矩阵 /** * * @param graph 图对象 * @param verxs 图对应的顶点个数 * @param data 图的各个顶点的值 * @param weight 图的邻接矩阵 */ public void createGraph(MGraph graph,int verxs,char data[],int[][] weight)&#123; int i,j; for (i=0;i&lt;verxs;i++)&#123;//顶点 graph.data[i] = data[i]; for (j=0;j&lt;verxs;j++)&#123; graph.weight[i][j]=weight[i][j]; &#125; &#125; &#125; //显示图的方法 public void showGraph(MGraph graph)&#123; for (int[] link:graph.weight)&#123; System.out.println(Arrays.toString(link)); &#125; &#125; //编写prim算法，得到最小生成树 /** * * @param graph 图 * @param v 表示从图的第几个顶点开始生成‘A’-&gt;0 'B'-&gt;1 */ public void prim(MGraph graph,int v)&#123; //visited[] 标记结点（顶点)是否被访问过 int visited[] = new int[graph.verxs]; //visited[] 默认元素的值都是0，表示没有访问过// for (int i=0;i&lt;graph.verxs;i++)&#123;// visited[i]=0;// &#125; //把当前这个结点标记已访问 visited[v]=1; //h1和h2记录两个顶点的下标 int h1=-1; int h2=-1; int minWeight =10000;//将minWeight 初始成一个大数，后面在遍历过程中，会被替换 for (int k=1;k&lt;graph.verxs;k++)&#123; //因为有graph.verxs顶点，普利姆算法结束后，有graph.verxs-1边 //这个是确定每一次生成的子图，和哪个结点的距离最近 for (int i=0;i&lt;graph.verxs;i++)&#123;//i结点表示被访问过的结点 for (int j=0;j&lt;graph.verxs;j++)&#123;//j结点表示还没有访问过的结点 if (visited[i]==1 &amp;&amp; visited[j]==0 &amp;&amp; graph.weight[i][j]&lt;minWeight)&#123; //替换minWeight（寻找已经访问过的结点和未访问的结点间的权值最小的边） minWeight = graph.weight[i][j]; h1=i; h2=j; &#125; &#125; &#125; //找到一条边是最小 System.out.println(\"边&lt;\"+graph.data[h1] +\",\"+graph.data[h2]+\"&gt; 权值：\"+minWeight); //将当前这个结点标记为已经访问 visited[h2]=1; //minWeight 重新设置为最大值 10000 minWeight=10000; &#125; &#125;&#125;class MGraph &#123; int verxs;//表示图的节点个数 char[] data;//存放节点数据 int[][] weight;//存放边，就是我们的邻接矩阵 public MGraph(int verxs)&#123; this.verxs =verxs; data = new char[verxs]; weight = new int[verxs][verxs]; &#125;&#125; 1.7 克鲁斯卡尔算法1.7.1 公交站问题连通7个点，里程最短 1.7.2 介绍从小到大选择n-1条边，并保证n-1边不构成回路 1.7.3 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193package com.atguigu.kruskal;import java.util.Arrays;public class KruskalCase &#123; private int edgeNum;//边的个数 private char[] vertexs;//顶点数组 private int[][] matrix;//邻接矩阵 //使用INF 表示两个顶点不能连通 private static final int INF = Integer.MAX_VALUE; public static void main(String[] args) &#123; char[] vertexs = &#123;'A','B','C','D','E','F','G'&#125;; int matrix[][]=&#123; &#123;0,12,INF,INF,INF,16,14&#125;, &#123;12,0,10,INF,INF,7,INF&#125;, &#123;INF,10,0,3,5,6,INF&#125;, &#123;INF,INF,3,0,4,INF,INF&#125;, &#123;INF,INF,5,4,0,2,8&#125;, &#123;16,7,6,INF,2,0,9&#125;, &#123;14,INF,INF,INF,8,9,0&#125;&#125;; //创建kruskalCase 对象实例 KruskalCase kruskalCase = new KruskalCase(vertexs,matrix); //输出构建的 kruskalCase.print(); kruskalCase.kruskal();// EData[] edges = kruskalCase.getEdges();// System.out.println(\"排序前=\"+Arrays.toString(edges));//没有排序// kruskalCase.sortEdges(edges);// System.out.println(\"排序后=\"+Arrays.toString(edges)); &#125; //构造器 public KruskalCase(char[] vertexs, int[][] matrix) &#123; //初始化顶点数和边的个数 int vlen = vertexs.length; //初始化顶点 this.vertexs = new char[vlen]; for (int i = 0; i &lt; vertexs.length; i++) &#123; this.vertexs[i] = vertexs[i]; &#125; //初始化边,使用的是复制拷贝的方式 this.matrix = new int[vlen][vlen]; for (int i = 0; i &lt; vlen; i++) &#123; for (int j = 0; j &lt; vlen; j++) &#123; this.matrix[i][j] = matrix[i][j]; &#125; &#125; //统计边的条数 for (int i = 0; i &lt; vlen; i++) &#123; for (int j = i+1; j &lt; vlen; j++) &#123; if (this.matrix[i][j] != INF) &#123; edgeNum++; &#125; &#125; &#125; &#125; public void kruskal()&#123; int index=0;//表示最后结果数组的索引 int[] ends = new int[edgeNum];//用于保存“已有最小生成树”中的每个顶点在最小生成树的的终点 //创建结果数组，保存最后的最小生成树 EData[] rets = new EData[edgeNum]; //获取图中 所有的边的集合，一共有12边 EData[] edges = getEdges(); System.out.println(\"图的边的集合=\"+Arrays.toString(edges)+\"共\"+edges.length);//12 //按照边的权值大小进行排序（从小到大) sortEdges(edges); //遍历edges 数组 将边添加到最小生成树时，判断是准备加入的边是否形成了回路，如果没有，就加入rets，否则不能加入 for (int i=0;i&lt;edgeNum;i++)&#123; //获取到第i条边的第一个顶点（起点） int p1=getPosition(edges[i].start); //获取到第i条边的第2个顶点 int p2 = getPosition(edges[i].end); //获取p1这个顶点在已有最小生成树中的终点 int m = getEnd(ends,p1); //获取p2这个顶点在已有最小生成树中的终点 int n =getEnd(ends,p2); //是否构成回路 if (m!=n)&#123;//没有构成回路 ends[m]=n;//s设置m 在“已有最小生成树”中的终点 &lt;E,F&gt; [0,0,0,0,5,0,0,0,0,0,0,0 rets[index++]=edges[i];//有一条边加入到rets数组 &#125; &#125; //统计并打印\"最小生成树\",输出rets System.out.println(\"最小生成树=\"); for (int i=0;i&lt;index;i++) &#123; System.out.println(rets[i]); &#125; &#125; //打印邻接矩阵 public void print() &#123; System.out.println(\"邻接矩阵为： \\n\"); for (int i = 0; i &lt; vertexs.length; i++) &#123; for (int j = 0; j &lt; vertexs.length; j++) &#123; System.out.printf(\"%12d\\t\",matrix[i][j]); &#125; System.out.println();//换行 &#125; &#125; //对边进行排序处理，冒泡排序 /** * 功能：对边进行排序处理，冒泡排序 * @param edges 边的集合 */ private void sortEdges(EData[] edges)&#123; for (int i=0;i&lt;edges.length-1;i++)&#123; for (int j=0;j&lt;edges.length-1-i;j++)&#123; if (edges[j].weight&gt;edges[j+1].weight)&#123;//交换 EData tmp =edges[j]; edges[j]=edges[j+1]; edges[j+1]=tmp; &#125; &#125; &#125; &#125; // /** * * @param ch 顶点的值，比如‘A’，‘B’ * @return 返回ch顶点对应的下标，如果找不到，返回-1 */ private int getPosition(char ch)&#123; for (int i=0;i&lt;vertexs.length;i++)&#123; if (vertexs[i]==ch)&#123;//找到 return i; &#125; &#125; //找不到，返回-1 return -1; &#125; /** * 功能：获取图中边，放到EData[] 数组中，后面我们需要遍历该数组 * 是通过matrix 邻接矩阵来获取 * EData[] 形式[['A','B',12],['B','F',7],.....] * @return */ private EData[] getEdges()&#123; int index =0; EData[] edges = new EData[edgeNum]; for (int i=0;i&lt;vertexs.length;i++)&#123; for (int j=i+1;j&lt;vertexs.length;j++)&#123; if (matrix[i][j]!=INF)&#123; edges[index++] = new EData(vertexs[i],vertexs[j],matrix[i][j]); &#125; &#125; &#125; return edges; &#125; /** * 功能：获取下标为i的顶点的终点，用于后面判断两个顶点的终点是否相同 * @param ends 数组就是记录了各个顶点对应的终点是哪个，ends数组是在遍历过程中，逐步形成 * @param i 表示传入的顶点对应的下标 * @return 返回的就是 下标为i的这个顶点对应的终点的下标 */ private int getEnd(int[] ends,int i)&#123; while (ends[i]!=0)&#123; i=ends[i]; &#125; return i; &#125;&#125;//创建一个类EData 它的对象实例就表示一条边class EData&#123; char start;//边的一个点 char end;//边的另外一个点 int weight;//边的权值 //构造器 public EData(char start,char end,int weight)&#123; this.start=start; this.end=end; this.weight =weight; &#125; //重写toString，便于输出边信息 @Override public String toString() &#123; return \"EData&#123;\" + \"&lt;\" + start + \", \" + end + \"&gt;=\" + weight + '&#125;'; &#125;&#125; 1.8 迪杰斯特拉算法1.8.1 最短路径G村庄到其它各个村庄的最短距离其他村庄呢？ 1.8.2 Dijkstra介绍典型最短路径算法，主要特点以起始点为中心向外层层扩散（广度优先搜索思想），直到扩展到终点为止。 1.8.3 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193package com.atguigu.dijkstra;import java.util.Arrays;public class DijkstraAlgorithm &#123; public static void main(String[] args) &#123; char[] vertex =&#123;'A','B','C','D','E','F','G'&#125;; //邻接矩阵 int[][] matrix = new int[vertex.length][vertex.length]; final int N =65535;//表示不可以连接 matrix[0] = new int[]&#123;N,5,7,N,N,N,2&#125;; matrix[1] = new int[]&#123;5,N,N,9,N,N,3&#125;; matrix[2] = new int[]&#123;7,N,N,N,8,N,N&#125;; matrix[3] = new int[]&#123;N,9,N,N,N,4,N&#125;; matrix[4] = new int[]&#123;N,N,8,N,N,5,4&#125;; matrix[5] = new int[]&#123;N,N,N,4,5,N,6&#125;; matrix[6] = new int[]&#123;2,3,N,N,4,6,N&#125;; //创建Graph对象 Graph graph = new Graph(vertex,matrix); graph.showGraph(); graph.dsj(2); graph.showDijkstra(); &#125;&#125;class Graph&#123; private char[] vertex; private int[][] matrix; private VisitedVertex vv;//已经访问的顶点的集合 public Graph(char[] vertex, int[][] matrix) &#123; this.vertex = vertex; this.matrix = matrix; &#125; //显示结果 public void showDijkstra()&#123; vv.show(); &#125; //显示图 public void showGraph()&#123; for (int[] link:matrix)&#123; System.out.println(Arrays.toString(link)); &#125; &#125; //迪杰斯特拉算法 /** * * @param index 表示出发顶点对应的下标 */ public void dsj(int index)&#123; vv = new VisitedVertex(vertex.length,index); update(index);//更新index顶点到周围顶点的距离和前驱节点 for (int j=1;j&lt;vertex.length;j++)&#123; index = vv.updateArr();//选择并返回新的访问结点 update(index);//更新index顶点到周围顶点的距离和前驱节点 &#125; &#125; //更新index下标顶点到周围顶点的距离和周围顶点的前驱顶点， private void update(int index)&#123; int len=0; //根据遍历我们的邻接矩阵的matrix[index]行 for (int j=0;j&lt;matrix[index].length;j++)&#123; //len 含义是：出发顶点到index顶点的距离 + 从index顶点到j顶点的距离和 len = vv.getDis(index) + matrix[index][j]; //如果j顶点没有被访问过，并且len 小于出发顶点到j顶点的距离，就需要更新 if (!vv.in(j) &amp;&amp; len&lt; vv.getDis(j))&#123; vv.updatePre(j,index);//更新j顶点的前驱为index顶点 vv.updateDis(j,len);//更新出发顶点到j顶点的距离 &#125; &#125; &#125;&#125;//已访问顶点集合class VisitedVertex&#123; //记录各个顶点是否访问过 1表示访问过，动态更新 public int[] already_arr; //每个下标对应的值为前一个顶点的下标，动态更新 public int[] pre_visited; //记录出发顶点到其他所有顶点的距离，比如G为出发顶点，就会记录G到其他顶点的距离，动态更新，求最短距离就会存放到dis public int[] dis; //构造器 /** * * @param length 顶点的个数 * @param index 出发顶点对应的下标，比如G顶点，下标就是6 */ public VisitedVertex(int length,int index)&#123; this.already_arr=new int[length]; this.pre_visited = new int[length]; this.dis=new int[length]; //初始化dis数组 Arrays.fill(dis,65535); this.already_arr[index]=1;//设置出发顶点被访问过 this.dis[index]=0;//设置出发顶点的访问距离为0 &#125; /** * 功能：判断index顶点是否被访问过 * @param index * @return 如果访问过，就访问true，否则就访问false */ public boolean in(int index)&#123; return already_arr[index]==1; &#125; /** * 功能： 更新出发顶点到index顶点的距离 * @param index * @param len */ public void updateDis(int index,int len)&#123; dis[index] =len; &#125; /** * 功能：更新pre顶点的前驱顶点为index结点 * @param pre * @param index */ public void updatePre(int pre,int index)&#123; pre_visited[pre]=index; &#125; /** * 功能：返回出发顶点到index顶点的距离 * @param index */ public int getDis(int index)&#123; return dis[index]; &#125; /** * 继续选择并返回新的访问顶点，比如这里的G完后，就是A点作为新的访问顶点（注意不是出发顶点） * @return */ public int updateArr()&#123; int min = 65535,index=0; for (int i=0;i&lt;already_arr.length;i++)&#123; if (already_arr[i]==0 &amp;&amp; dis[i]&lt;min)&#123; min=dis[i]; index=i; &#125; &#125; //更新index 顶点被访问过 already_arr[index]=1; return index; &#125; //显示最后的结果 //即将三个数组的情况输出 public void show()&#123; System.out.println(\"============================================\"); //输出already_arr for (int i : already_arr)&#123; System.out.print(i +\" \"); &#125; System.out.println(); //输出pre_visited for (int i : pre_visited)&#123; System.out.print(i+\" \"); &#125; System.out.println(); //输出dis for (int i : dis)&#123; System.out.print(i+\" \"); &#125; System.out.println(); //为了好看，最后的最短距离，我们处理 char[] vertex =&#123;'A','B','C','D','E','F','G'&#125;; int count =0; for (int i :dis)&#123; if (i!=65535)&#123; System.out.println(\"该站到\"+vertex[count]+\"站最短距离为\"+i+\"。\"); &#125;else&#123; System.out.println(\"N \"); &#125; count++; &#125; System.out.println(); &#125;&#125; 1.8 佛洛伊德算法1.8.1 介绍用于寻找给定加权图中顶点间最短路径算法与Dijkstra区别：Dijstra：某一个顶点到其他顶点最短路径Floyd：每一个顶点都是出发访问点，求出每一个顶点到其他顶点最短路径 1.8.2 思路第一轮循坏中，以A作为中间顶点即把A作为中间顶点的所有情况都进行遍历，就会得到更新距离表和前驱关系 1.8.3 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.atguigu.floyd;import java.util.Arrays;public class FloydAlgorithm &#123; public static void main(String[] args) &#123; char[] vertex =&#123;'A','B','C','D','E','F','G'&#125;; int[][] matrix = new int[vertex.length][vertex.length]; final int N =65535; matrix[0] = new int[]&#123;0,5,7,N,N,N,2&#125;; matrix[1] = new int[]&#123;5,0,N,9,N,N,3&#125;; matrix[2] = new int[]&#123;7,N,0,N,8,N,N&#125;; matrix[3] = new int[]&#123;N,9,N,0,N,4,N&#125;; matrix[4] = new int[]&#123;N,N,8,N,0,5,4&#125;; matrix[5] = new int[]&#123;N,N,N,4,5,0,6&#125;; matrix[6] = new int[]&#123;2,3,N,N,4,6,0&#125;; Graph graph = new Graph(vertex.length,matrix,vertex); //调用佛洛伊德算法 graph.floyd(); graph.show(); &#125;&#125;//创建图class Graph&#123; private char[] vertex;//存放顶点的数组 private int[][] dis;//保存，从各个顶点出发到其他顶点的距离，最后的结果，也是保留在数组 private int[][] pre;//保存到目标顶点的前驱顶点 //构造器 public Graph(int length,int[][] matrix,char[] vertex)&#123; this.vertex=vertex; this.dis=matrix; this.pre=new int[length][length]; //对pre数组初始化，注意存放的是前驱顶点的下标 for (int i=0;i&lt;length;i++)&#123; Arrays.fill(pre[i],i); &#125; &#125; //显示pre数组和dis数组 public void show()&#123; char[] vertex =&#123;'A','B','C','D','E','F','G'&#125;; for (int k=0;k&lt;dis.length;k++)&#123; //先将pre数组输出的一行 for (int i=0;i&lt;dis.length;i++)&#123; System.out.print(vertex[pre[k][i]]+\" \"); &#125; System.out.println(); //输出dis数组的一行数据 for (int i=0;i&lt;dis.length;i++)&#123; System.out.print(\"(\"+vertex[k]+\"到\"+vertex[i]+\"最短路径是\"+dis[k][i]+ \"）\"); &#125; System.out.println(); System.out.println(); &#125; &#125; //佛洛伊德算法 public void floyd()&#123; int len=0;//变量保存距离 //从中间顶点遍历，k就是中间顶点的下标 for (int k=0;k&lt;dis.length;k++)&#123; //从i顶点开始出发【A,B,C,D,E,F,G】 for (int i=0;i&lt;dis.length;i++)&#123; //到达j顶点 for (int j=0;j&lt;dis.length;j++)&#123; len=dis[i][k]+dis[k][j];//求出从i顶点出发，经过k中间顶点，到达j顶点距离 if (len&lt;dis[i][j])&#123;//如果len小于dis[i][j] dis[i][j]=len;//更新距离 pre[i][j]=pre[k][j];//更新前驱顶点 &#125; &#125; &#125; &#125; &#125;&#125; 1.10 马踏棋盘算法1.10.1 介绍1）马踏棋盘算法也被称为骑士周游问题2）8*8棋盘，马走日字，走遍棋盘上全部64个方格 1.10.2 思路贪心算法优化非递减 1.10.3 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139package com.atguigu.horse;import java.awt.*;import java.util.ArrayList;import java.util.Comparator;public class HorseChessboard &#123; private static int X;//棋盘列数 private static int Y;//棋盘行数 //创建一个数组，标记棋盘的各个位置是否被访问过 private static boolean visited[]; //使用一个属性，标记是否棋盘的所有位置都访问 private static boolean finished;//如果为true，表示成功 public static void main(String[] args) &#123; System.out.println(\"骑士周游算法，开始运行~~\"); //测试骑士周游算法算法正确 X=8; Y=8; int row=1;//马儿初始位置的行，从1开始编写 int column =1; //马儿初始位置的列，从1开始编写 //创建棋盘 int[][] chessboard = new int[X][Y]; visited = new boolean[X*Y];//初始值都是false //测试一下耗时 long start = System.currentTimeMillis(); traversalChessboard(chessboard,row-1,column-1,1); long end = System.currentTimeMillis(); System.out.println(\"共耗时：\"+(end-start)+\"毫秒\"); //输出棋盘的最后情况 for (int[] rows :chessboard)&#123; for (int step:rows)&#123; System.out.print(step +\"\\t\"); &#125; System.out.println(); &#125; &#125; /** * 完成骑士周游问题的算法 * @param chessboard 棋盘 * @param row 马儿当前的位置的行 从0开始 * @param column 马儿当前的位置的列 从0开始 * @param step 第几步，初始位置就是第一步 */ public static void traversalChessboard(int[][] chessboard,int row,int column,int step)&#123; chessboard[row][column]=step; visited[row*X+column]=true;//标记该位置已经访问 //获取当前位置可以走的下一个位置的集合 ArrayList&lt;Point&gt; ps=next(new Point(column,row)); //对ps进行排序，排序的规则就是对ps的所有的Point对象的下一步的位置的数目，进行非递减排序 sort(ps); //遍历ps while(!ps.isEmpty())&#123; Point p=ps.remove(0);//取出下一个可以走的位置 //判断该点是否已经访问过 if (!visited[p.y*X+p.x])&#123;//说明还没有访问过 traversalChessboard(chessboard,p.y,p.x,step+1); &#125; &#125; //判断马儿是否完成了任务，使用step和应该走的步数比较， //如果没有达到数量，则表示没有完成任务，将整个棋盘置0 //说明: step&lt;X*Y &amp;&amp; !finished 成立的情况有两种 //1.棋盘到目前位置，仍然没有走完 //2.棋盘处于应该回溯过程 if (step&lt;X*Y &amp;&amp; !finished)&#123; chessboard[row][column]=0; visited[row*X+column]=false; &#125;else &#123; finished =true; &#125; &#125; /** * 功能：根据当前位置（Point对象)，计算马儿还能走那些位置，并放入到一个集合中（AreayList），最多8个 * @param curPoint * @return */ public static ArrayList&lt;Point&gt; next (Point curPoint)&#123; //创建一个ArrayList ArrayList&lt;Point&gt; ps = new ArrayList&lt;Point&gt;(); //创建一个Point Point p1= new Point(); //表示马可以走5这个位置 if ((p1.x=curPoint.x-2)&gt;=0 &amp;&amp; (p1.y=curPoint.y-1)&gt;=0)&#123; ps.add(new Point(p1)); &#125; //表示马可以走6这个位置 if ((p1.x=curPoint.x-1)&gt;=0 &amp;&amp; (p1.y=curPoint.y-2)&gt;=0)&#123; ps.add(new Point(p1)); &#125; //表示马可以走7这个位置 if ((p1.x=curPoint.x+1) &lt;X &amp;&amp; (p1.y=curPoint.y-2)&gt;=0)&#123; ps.add(new Point(p1)); &#125; //表示马可以走0这个位置 if ((p1.x=curPoint.x+2)&lt;X &amp;&amp; (p1.y=curPoint.y-1)&gt;=0)&#123; ps.add(new Point(p1)); &#125; //表示马可以走1这个位置 if ((p1.x=curPoint.x+2)&lt;X &amp;&amp; (p1.y=curPoint.y+1)&lt;Y)&#123; ps.add(new Point(p1)); &#125; //表示马可以走2这个位置 if ((p1.x=curPoint.x+1)&lt;X &amp;&amp; (p1.y=curPoint.y+2)&lt;Y)&#123; ps.add(new Point(p1)); &#125; //表示马可以走3这个位置 if ((p1.x=curPoint.x-1)&gt;=0 &amp;&amp; (p1.y=curPoint.y+2)&lt;Y)&#123; ps.add(new Point(p1)); &#125; //表示马可以走4这个位置 if ((p1.x=curPoint.x-2)&gt;=0 &amp;&amp; (p1.y=curPoint.y+1)&lt;Y)&#123; ps.add(new Point(p1)); &#125; return ps; &#125; //根据当前这一步的所有的下一步的选择位置，进行非递减排序,减少回溯的次数 public static void sort(ArrayList&lt;Point&gt;ps)&#123; ps.sort(new Comparator&lt;Point&gt;() &#123; @Override public int compare(Point o1, Point o2) &#123; //获取到o1的下一步的所有位置个数 int count1 = next(o1).size(); //获取到o2的下一步的所有位置个数 int count2 = next(o2).size(); if (count1&lt;count2)&#123; return -1; &#125;else if (count1 ==count2)&#123; return 0; &#125;else&#123; return 1; &#125; &#125; &#125;); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://lijiale96.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二分算法","slug":"二分算法","permalink":"https://lijiale96.github.io/tags/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"},{"name":"分治算法","slug":"分治算法","permalink":"https://lijiale96.github.io/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"},{"name":"动态规划算法","slug":"动态规划算法","permalink":"https://lijiale96.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/"},{"name":"KMP算法","slug":"KMP算法","permalink":"https://lijiale96.github.io/tags/KMP%E7%AE%97%E6%B3%95/"},{"name":"贪心算法","slug":"贪心算法","permalink":"https://lijiale96.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"普利姆算法","slug":"普利姆算法","permalink":"https://lijiale96.github.io/tags/%E6%99%AE%E5%88%A9%E5%A7%86%E7%AE%97%E6%B3%95/"},{"name":"克鲁斯卡尔算法","slug":"克鲁斯卡尔算法","permalink":"https://lijiale96.github.io/tags/%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95/"},{"name":"迪杰斯特拉算法","slug":"迪杰斯特拉算法","permalink":"https://lijiale96.github.io/tags/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/"},{"name":"费洛伊德算法","slug":"费洛伊德算法","permalink":"https://lijiale96.github.io/tags/%E8%B4%B9%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95/"},{"name":"骑士周游算法","slug":"骑士周游算法","permalink":"https://lijiale96.github.io/tags/%E9%AA%91%E5%A3%AB%E5%91%A8%E6%B8%B8%E7%AE%97%E6%B3%95/"}]},{"title":"算法笔记11","slug":"算法笔记11","date":"2020-04-06T08:33:36.000Z","updated":"2020-04-13T11:45:21.598Z","comments":true,"path":"2020/04/06/算法笔记11/","link":"","permalink":"https://lijiale96.github.io/2020/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B011/","excerpt":"图1.1 图的基本介绍1.1.1 为什么要有图1）线性表和树2）线性表局限于一个直接前驱和直接后继3）树也只能一个直接前驱也就是父节点4）多对多————图 1.1.2 图举例说明图是一种数据结构，结点可以具有零个或多个相邻元素。两个结点之间的连接为边。结点为顶点 1.1.3 图的常用概念1）顶点2）边3）路径4）无向图5）有向图6) 带权图","text":"图1.1 图的基本介绍1.1.1 为什么要有图1）线性表和树2）线性表局限于一个直接前驱和直接后继3）树也只能一个直接前驱也就是父节点4）多对多————图 1.1.2 图举例说明图是一种数据结构，结点可以具有零个或多个相邻元素。两个结点之间的连接为边。结点为顶点 1.1.3 图的常用概念1）顶点2）边3）路径4）无向图5）有向图6) 带权图 1.2 图的表达方式二维数组（邻接矩阵）；链表表示（邻接表） 1.2.1 邻接矩阵1.2.2 邻接表1）很多遍不存在2）只关心存在的边，不关心不存在的边，没有空间浪费，由数组+链表组成 1.3 图的快速入门案例1）图的创建2）思路分析 （1）存储顶点String 使用ArrayList （2）保存矩阵 int[][] edges3）代码实现 12345678910111213141516//插入节点 public void insertVertex(String vertex)&#123; vertexList.add(vertex); &#125; //添加边 /** * * @param v1 表示点的下标即是第几个顶点 “A” ——\"B\" “A”-&gt;0 \"B\" -&gt;1 * @param v2 第二个顶点对应的下标 * @param weight */ public void insertEdge(int v1,int v2,int weight)&#123; edges[v1][v2] =weight; edges[v2][v1] =weight; numOfEdges++; &#125; 1.4 图的深度优先遍历介绍1.4.1 图遍历介绍（1）深度优先遍历（2）广度优先遍历 1.4.2 深度优先遍历基本思想Depth First Search 代码实现： 123456789101112131415161718192021222324252627//深度优先遍历算法 //i 第一次就是0 private void dfs(boolean[] isVisited,int i)&#123; //首先我们访问该节点，输出 System.out.print(getValueByIndex(i)+\"-&gt;\"); //将结点设置为已经访问 isVisited[i] =true; //查找结点i的第一个邻接结点w int w = getFirstNeighbor(i); while(w!=-1) &#123;//说明有 if (!isVisited[w]) &#123;//未访问过 dfs(isVisited, w); &#125; //如果w结点已经被访问过 w = getNextNeighbor(i, w); &#125; &#125; //对dfs 进行一个重载，遍历我们所有的结点，并进行dfs public void dfs()&#123; isVisited= new boolean[vertexList.size()]; //遍历所有的结点，进行dfs【回溯】 for (int i=0;i&lt;getNumOfVertex();i++)&#123; if (!isVisited[i])&#123; dfs(isVisited,i); &#125; &#125; &#125; 1.5 图的广度优先遍历Broad First Search 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142//对一个结点进行广度优先遍历的方法 private void bfs(boolean[] isVisited,int i)&#123; int u;// 表示队列的头结点对应下标 int w;// 邻接结点 //队列，记录结点访问的顺序 LinkedList queue = new LinkedList(); //访问结点，输出结点信息 System.out.print(getValueByIndex(i)+\"=&gt;\"); //标记为已访问 isVisited[i] =true; //将结点加入队列 queue.addLast(i); while(!queue.isEmpty())&#123; //取出队列的头结点下标 u =(Integer)queue.removeFirst(); //得到第一个邻接点的下标w w = getFirstNeighbor(u); while(w!=-1)&#123;//找到 //是否访问过 if (!isVisited[w])&#123; System.out.print(getValueByIndex(w)+\"=&gt;\"); //标记已经访问 isVisited[w] = true; //入队 queue.addLast(w); &#125; //以u为前驱点，找w后面的的下一个邻接点 w = getNextNeighbor(u,w);//体现出我们的广度优先 &#125; &#125; &#125; //遍历所有的结点，都进行广度优先搜索 public void bfs()&#123; isVisited= new boolean[vertexList.size()]; for (int i=0;i&lt;getNumOfVertex();i++)&#123; if (!isVisited[i])&#123; bfs(isVisited,i); &#125; &#125; &#125; 1.6 图的代码汇总代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202package com.atguigu.graph;import java.util.ArrayList;import java.util.Arrays;import java.util.LinkedList;public class Graph &#123; private ArrayList&lt;String&gt; vertexList;//存储顶点集合 private int[][] edges;//存储图对应的邻结矩阵 private int numOfEdges;//表示边的数目 //定义一个数组boolean[],记录某个结点是否被访问 private boolean[] isVisited; public static void main(String[] args) &#123; //测试一把图是否创建ok int n=8; //节点的个数// String VertexValue[] =&#123;\"A\",\"B\",\"C\",\"D\",\"E\"&#125;; String VertexValue[] =&#123;\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\"&#125;; //创建图对象 Graph graph =new Graph(n); //循坏的添加顶点 for (String value: VertexValue)&#123; graph.insertVertex(value); &#125; //添加边 //A-B A-C B-C B-D B-E// graph.insertEdge(0,1,1);//A-B// graph.insertEdge(0,2,1);//A-C// graph.insertEdge(1,2,1);//B-C // graph.insertEdge(1,3,1);//B-D// graph.insertEdge(1,4,1);//B-E //更新边的关系 graph.insertEdge(0,1,1);//A-B graph.insertEdge(0,2,1);//A-B graph.insertEdge(1,3,1);//A-B graph.insertEdge(1,4,1);//A-B graph.insertEdge(3,7,1);//A-B graph.insertEdge(4,7,1);//A-B graph.insertEdge(2,5,1);//A-B graph.insertEdge(2,6,1);//A-B graph.insertEdge(5,6,1);//A-B //显示 graph.showGraph(); //我们的dfs遍历 System.out.println(\"深度遍历\"); graph.dfs();//A -&gt; B -&gt;C -&gt;D-&gt; E, 12485367 System.out.println(); System.out.println(\"广度优先！\"); graph.bfs();//A-&gt;B-&gt;C-&gt;D-&gt;E, 12345678 &#125; //构造器 public Graph(int n)&#123; //初始化矩阵和vertexList edges = new int[n][n]; vertexList = new ArrayList&lt;String&gt;(n); numOfEdges =0; &#125; //得到第一个邻接结点的下标 w /** * * @param index * @return 如果存在就返回对应的下标，否则返回-1 */ public int getFirstNeighbor(int index)&#123; for (int j=0;j&lt;vertexList.size();j++)&#123; if (edges[index][j]&gt;0)&#123; return j; &#125; &#125; return -1; &#125; //根据前一个邻接结点的下标来获取下一个邻接结点 public int getNextNeighbor(int v1,int v2)&#123; for (int j=v2+1;j&lt;vertexList.size();j++)&#123; if (edges[v1][j]&gt;0)&#123; return j; &#125; &#125; return -1; &#125; //深度优先遍历算法 //i 第一次就是0 private void dfs(boolean[] isVisited,int i)&#123; //首先我们访问该节点，输出 System.out.print(getValueByIndex(i)+\"-&gt;\"); //将结点设置为已经访问 isVisited[i] =true; //查找结点i的第一个邻接结点w int w = getFirstNeighbor(i); while(w!=-1) &#123;//说明有 if (!isVisited[w]) &#123;//未访问过 dfs(isVisited, w); &#125; //如果w结点已经被访问过 w = getNextNeighbor(i, w); &#125; &#125; //对dfs 进行一个重载，遍历我们所有的结点，并进行dfs public void dfs()&#123; isVisited= new boolean[vertexList.size()]; //遍历所有的结点，进行dfs【回溯】 for (int i=0;i&lt;getNumOfVertex();i++)&#123; if (!isVisited[i])&#123; dfs(isVisited,i); &#125; &#125; &#125; //对一个结点进行广度优先遍历的方法 private void bfs(boolean[] isVisited,int i)&#123; int u;// 表示队列的头结点对应下标 int w;// 邻接结点 //队列，记录结点访问的顺序 LinkedList queue = new LinkedList(); //访问结点，输出结点信息 System.out.print(getValueByIndex(i)+\"=&gt;\"); //标记为已访问 isVisited[i] =true; //将结点加入队列 queue.addLast(i); while(!queue.isEmpty())&#123; //取出队列的头结点下标 u =(Integer)queue.removeFirst(); //得到第一个邻接点的下标w w = getFirstNeighbor(u); while(w!=-1)&#123;//找到 //是否访问过 if (!isVisited[w])&#123; System.out.print(getValueByIndex(w)+\"=&gt;\"); //标记已经访问 isVisited[w] = true; //入队 queue.addLast(w); &#125; //以u为前驱点，找w后面的的下一个邻接点 w = getNextNeighbor(u,w);//体现出我们的广度优先 &#125; &#125; &#125; //遍历所有的结点，都进行广度优先搜索 public void bfs()&#123; isVisited= new boolean[vertexList.size()]; for (int i=0;i&lt;getNumOfVertex();i++)&#123; if (!isVisited[i])&#123; bfs(isVisited,i); &#125; &#125; &#125; //图中常用的方法 //返回节点的个数 public int getNumOfVertex()&#123; return vertexList.size(); &#125; //显示图对应的矩阵 public void showGraph()&#123; for (int[] link: edges)&#123; System.out.println(Arrays.toString(link)); &#125; &#125; //得到边的数目 public int getNumOfEdges()&#123; return numOfEdges; &#125; //返回结点i(下标）对应的数据 0——&gt;\"A\" 1——&gt;\"B\" 2——&gt;\"C\" public String getValueByIndex(int i)&#123; return vertexList.get(i); &#125; //返回v1和v2的权值 public int getWeight(int v1,int v2)&#123; return edges[v1][v2]; &#125; //插入节点 public void insertVertex(String vertex)&#123; vertexList.add(vertex); &#125; //添加边 /** * * @param v1 表示点的下标即是第几个顶点 “A” ——\"B\" “A”-&gt;0 \"B\" -&gt;1 * @param v2 第二个顶点对应的下标 * @param weight */ public void insertEdge(int v1,int v2,int weight)&#123; edges[v1][v2] =weight; edges[v2][v1] =weight; numOfEdges++; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://lijiale96.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"图","slug":"图","permalink":"https://lijiale96.github.io/tags/%E5%9B%BE/"}]},{"title":"算法笔记10","slug":"算法笔记10","date":"2020-04-03T08:33:36.000Z","updated":"2020-04-03T13:03:55.086Z","comments":true,"path":"2020/04/03/算法笔记10/","link":"","permalink":"https://lijiale96.github.io/2020/04/03/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B010/","excerpt":"多路查找树1.1、二叉树与B树1.1.1 二叉树的问题分析问题1：二叉树多次i/o操作时，节点海量，速度有影响问题2：节点海量，二叉树的高度很大，会降低操作速度 1.1.2 多叉树1）每个节点有更多的数据项和更多的子节点2）多叉树通过重新组织节点，减少树的高度，优化二叉树 1.1.3 B树的介绍B树通过重新组织节点，降低树的高度，并且减少i/o读写次数来提高效率1）一个节点的大小设为等于一个页（页的大小通常为4k），这样每个节点只需要依次I/O就可以完全载入2）树的度M设置为1024，在600亿个元素中最多只需要4次I/O操作就可以读取想要的元素，B树（B+）应用于文件存储系统以及数据库系统中 1.2 2-3树1.2.1 特点2-3树是最简单的数的结构1）2-3树的叶子节点都在同一层2）两个子节点的节点叫二节点3）有三个子节点的节点叫三节点4）2-3树是由二节点和三节点构成的树","text":"多路查找树1.1、二叉树与B树1.1.1 二叉树的问题分析问题1：二叉树多次i/o操作时，节点海量，速度有影响问题2：节点海量，二叉树的高度很大，会降低操作速度 1.1.2 多叉树1）每个节点有更多的数据项和更多的子节点2）多叉树通过重新组织节点，减少树的高度，优化二叉树 1.1.3 B树的介绍B树通过重新组织节点，降低树的高度，并且减少i/o读写次数来提高效率1）一个节点的大小设为等于一个页（页的大小通常为4k），这样每个节点只需要依次I/O就可以完全载入2）树的度M设置为1024，在600亿个元素中最多只需要4次I/O操作就可以读取想要的元素，B树（B+）应用于文件存储系统以及数据库系统中 1.2 2-3树1.2.1 特点2-3树是最简单的数的结构1）2-3树的叶子节点都在同一层2）两个子节点的节点叫二节点3）有三个子节点的节点叫三节点4）2-3树是由二节点和三节点构成的树 1.2.2 应用案例插入规则：插入一个数到某个节点时，不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层，拆后仍需要满足上面三个条件对于三节点的子树的值大小仍然遵守BST 1.2.3 其他说明除了23树，还有234树 1.3 B树、B+树和B*树1.3.1 B树、B+树和B*树B：balanced 1.3.2 B树的介绍1）B树阶：节点最多子节点树2）B树搜索3）关键字集合分布在整棵树，即叶子节点和非叶子节点都存放数据4）搜索有可能咋非叶子节点5）搜索性能等价于关键字全集内做一次二分查找 1.3.3 B+树的介绍1）只有达到叶子节点才命中，搜索性能等价于关键字全集做一次二分查找2）稠密索引3）不可能在非叶子节点4）非叶子节点相当于叶子节点的索引，叶子节点相当于数据5）更适合索引系统6）各有各的优势 1.3.4 B*树1）非叶子节点关键字个数至少为（2/3）M,块最低使用率为2/3，而B+树块最低使用率为1/22）B树分配新节点概率比B+低，空间使用率更高","categories":[{"name":"算法","slug":"算法","permalink":"https://lijiale96.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"B-tree","slug":"B-tree","permalink":"https://lijiale96.github.io/tags/B-tree/"},{"name":"B+树","slug":"B-树","permalink":"https://lijiale96.github.io/tags/B-%E6%A0%91/"},{"name":"B*树","slug":"B-树","permalink":"https://lijiale96.github.io/tags/B-%E6%A0%91/"}]},{"title":"算法笔记9","slug":"算法笔记9","date":"2020-03-28T14:33:36.000Z","updated":"2020-04-04T14:42:48.948Z","comments":true,"path":"2020/03/28/算法笔记9/","link":"","permalink":"https://lijiale96.github.io/2020/03/28/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B09/","excerpt":"1、树结构实际应用1.1 堆排序1.1.1 堆排序基本介绍1）选择排序 ，最坏、最好、平均时间复杂度一样，不稳定2）大顶堆3）小顶堆4）左右子节点无大小关系","text":"1、树结构实际应用1.1 堆排序1.1.1 堆排序基本介绍1）选择排序 ，最坏、最好、平均时间复杂度一样，不稳定2）大顶堆3）小顶堆4）左右子节点无大小关系 1.1.2 堆排序基本思想1.1.3 代码一个数组{4,6,8,5,9}，使用堆排序法，升序排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.atguigu.tree;import java.util.Arrays;public class HeapSort &#123; public static void main(String[] args) &#123; //要求将数组进行升序排序 int arr[] = &#123;4, 6, 8, 5, 9,-1,90,89,-99,232&#125;; heapSort(arr); &#125; //编写一个堆排序的方法 public static void heapSort(int arr[]) &#123; int temp=0; System.out.println(\"堆排序！\"); //分步完成// adjustHeap(arr, 1, arr.length);// System.out.println(\"第一次\" + Arrays.toString(arr));//4,9,8,5,6// adjustHeap(arr, 0, arr.length);// System.out.println(\"第一次\" + Arrays.toString(arr));//9,6,8,5,4 //最终代码 for (int i = arr.length/2-1;i&gt;=0;i--)&#123; adjustHeap(arr,i,arr.length); &#125; /** * 交换，沉 */ for (int j= arr.length-1;j&gt;0;j--)&#123; //交换 temp =arr[j]; arr[j]=arr[0]; arr[0]=temp; adjustHeap(arr,0,j); &#125; System.out.println(\"数组\"+Arrays.toString(arr)); &#125; /** * 功能： 完成 将以 i 对应的非叶子节点的数调整成大顶堆 * 举例 int arr[] =&#123;4,6,8,5,9&#125;;=&gt; i=1=&gt;adjustHeap =&gt;得到&#123;4,9,8,5,6&#125; * 如果再次调用 adjustHeap 传入的是 i=0 =&gt; 得到&#123;4，9，8,5,6&#125;=&gt;&#123;9,6,8,5,4&#125; * * @param arr 待调整的数组 * @param i 表示非叶子节点在数组在索引 * @param length 表示对多少个元素继续调整，length是在逐渐的减少 */ //将一个数组（二叉树），调整成一个大顶堆 public static void adjustHeap(int arr[], int i, int length) &#123; int temp = arr[i];//先取出当前元素的值，保存在临时变量 //开始调整 //1.k=i*2+1 k是i节点的左子节点 for (int k = i * 2 + 1; k &lt; length; k = k * 2 + 1) &#123; if (k + 1 &lt; length &amp;&amp; arr[k] &lt; arr[k + 1]) &#123; //说明左子节点的值小于右子节点的值 k++;//k指向右子节点 &#125; if (arr[k] &gt; temp) &#123;//如果子节点大于父节点 arr[i] = arr[k];//把较大的值赋给当前节点 i = k;//!!! i指向k，继续循坏比较 &#125; else &#123; break; &#125; &#125; //当for循坏结束后，我们已经将以 i 为父节点的树的最大值，放在了最顶（局部） arr[i] = temp;//将temp值放到调整后的位置 &#125;&#125; 1.2 赫夫曼树1.2.1 基本介绍1）n个权值作为n个叶子节点，构造一颗二叉树，若该树的待权路径长度wpl达到最小，为最优二叉树，哈夫曼树 Huffman Tree2）带权路径长度最短的数，权值较大的结点离根较近 1.2.2 重要概念1）路径和路径长度2）结点权和带权路径的长度3）树的带权路径长度=树的所有叶子节点的带权路径之和 wpl权值越大结点离根节点越近的二叉树4）wpl最小的就是赫夫曼树 1.2.3 创建思路1）从小到大排序2）取出根节点权值最小的两颗二叉树3）新的二叉树权值为最小二颗二叉树的权值之和4）不断重复以上步骤 ，得到Huffman树 1.2.3 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.atguigu.huffmanTree;import java.util.ArrayList;import java.util.Collection;import java.util.Collections;import java.util.List;public class HuffmanTree &#123; public static void main(String[] args) &#123; int arr[] = &#123;13, 7, 8, 3, 29, 6, 1&#125;; Node root = createHuffmanTree(arr); //测试 preOrder(root); //67,29,38，15,7,8,23，10,4,1,3,6，13&#125; &#125; //编写一个前序遍历的方法 public static void preOrder(Node root)&#123; if (root!=null)&#123; root.preOrder(); &#125;else&#123; System.out.println(\"是空树，不能遍历~\"); &#125; &#125; //创建赫夫曼树 /** * * @param arr 需要创建成赫夫曼树的数组 * @return 创建好后的赫夫曼树的root结点 */ public static Node createHuffmanTree(int[] arr)&#123; //第一步 为了操作方便 //1.遍历 arr 数组 //2.将arr的每个元素构建成一个Node //3.将Node 放入到ArrayList中 List&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;(); for (int value:arr)&#123; nodes.add(new Node(value)); &#125; while(nodes.size()&gt;1) &#123; //排序从小到大 Collections.sort(nodes); System.out.println(\"nodes=\" + nodes); //取出根节点权值最小的两颗二叉树 //（1）取出权值最小的结点(二叉树） Node leftNode = nodes.get(0); //（2） 取出权值第二小的结点（二叉树） Node rightNode = nodes.get(1); //（3）构建一颗新的二叉树 Node parent = new Node(leftNode.value + rightNode.value); parent.left = leftNode; parent.right = rightNode; //（4）从ArrayList删除处理过的二叉树 nodes.remove(leftNode); nodes.remove(rightNode); //（5）将parent加入到nodes nodes.add(parent); &#125; //返回赫夫曼树的root的结点 return nodes.get(0); &#125;&#125; // 创建节点类//为了让Node 对象持续排序Collections集合排序//让Node 实现Comparable 接口class Node implements Comparable&lt;Node&gt;&#123; int value;//结点权值 Node left;//指向左子节点 Node right;//指向右子节点 //写一个前序遍历 public void preOrder()&#123; System.out.println(this); if (this.left!=null)&#123; this.left.preOrder(); &#125; if (this.right!=null)&#123; this.right.preOrder(); &#125; &#125; public Node(int value)&#123; this.value=value; &#125; @Override public String toString() &#123; return \"Node&#123;\" + \"value=\" + value + '&#125;'; &#125; @Override public int compareTo(Node o) &#123; //表示从小到大排序 return this.value - o.value; //表示从大到小// return -( this.value - o.value); &#125;&#125; 1.3 赫夫曼编码1.3.1 介绍1）Huffman Coding2）电讯通信3）数据文件压缩，百分之20~904）可变字长编码VLC 1.3.2 原理定长编码 ：359 变长编码：匹配的多义性 赫夫曼编码满足前缀编码，不会造成匹配的多义性，无损处理 注：排序方法不同，赫夫曼编码也完全不一样，但是wpl是一样的，都是最小的 1.3.3 数据压缩（构建赫夫曼树）构建赫夫曼树的具体实现 12345678910111213141516171819202122232425 //可以通过List 创建对应的赫夫曼树 private static Node createHuffmanTree(List&lt;Node&gt; nodes)&#123; while(nodes.size()&gt;1)&#123; //排序,从小到大 Collections.sort(nodes); //取出第一颗最小的二叉树 Node leftNode = nodes.get(0); //取出第二颗最小的二叉树 Node rightNode = nodes.get(1); //创建一颗新的二叉树，它的根节点没有data，只有权值 Node parent = new Node(null,leftNode.weight+rightNode.weight); parent.left=leftNode; parent.right=rightNode; //将已经处理的两颗二叉树从nodes删除 nodes.remove(leftNode); nodes.remove(rightNode); //将新的二叉树，加入到nodes nodes.add(parent); &#125; //nodes 最后的节点 就是赫夫曼树的根节点 return nodes.get(0); &#125;&#125; 1.3.4 数据压缩（生成赫夫曼编码和赫夫曼编码后的数据）代码实现： 123456789101112131415161718192021222324/** * 功能：将传入的node结点的所有叶子结点的赫夫曼编码得到，并放入到huffmanCodes集合 * @param node 传入结点 * @param code 路径：左子节点是0，右子节点是1 * @param stringBuilder 是用于拼接路径 */ private static void getCodes(Node node,String code,StringBuilder stringBuilder)&#123; StringBuilder stringBuilder2=new StringBuilder(stringBuilder); //将code 加入到stringBuilder2 stringBuilder2.append(code); if (node!=null)&#123; //如果node==null 不处理 //判断当前node 是叶子节点还是非叶子节点 if (node.data==null)&#123;//非叶子结点 //递归处理 //向左递归 getCodes(node.left,\"0\",stringBuilder2); //向右递归 getCodes(node.right,\"1\",stringBuilder2); &#125;else&#123; //说明是一个叶子结点 //就表示找到某个叶子结点的最后 huffmanCodes.put(node.data,stringBuilder2.toString()); &#125; &#125; &#125; 1.3.5 数据解压代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879 //编写一个方法，完成对压缩数据的解码 /** * * @param huffmanCodes 赫夫曼编码 map * @param huffmanBytes 赫夫曼编码得到的字节数组 * @return 就是原来的字符串对应的数组 */ private static byte[] decode(Map&lt;Byte,String&gt; huffmanCodes, byte[] huffmanBytes)&#123; //1.先得到huffmanBytes 对应的二进制的字符串，形式 10101000010111... StringBuilder stringBuilder = new StringBuilder(); //将byte数组转成二进制的字符串 for (int i=0;i&lt;huffmanBytes.length;i++)&#123; byte b = huffmanBytes[i]; //判断是不是最后一个字节 boolean flag=(i==huffmanBytes.length-1); stringBuilder.append(byteToBitString(!flag,b)); &#125;// System.out.println(\"赫夫曼字节数组对应的二进制字符串=\"+stringBuilder.toString());// return null; //把字符串安装指定的赫夫曼编码进行解码 //把赫夫曼编码进行调换，因为反向查询 a-&gt;100 100-&gt;a Map&lt;String,Byte&gt; map = new HashMap&lt;String, Byte&gt;(); for (Map.Entry&lt;Byte,String&gt; entry:huffmanCodes.entrySet())&#123; map.put(entry.getValue(),entry.getKey()); &#125; //创建一个集合，存放byte List&lt;Byte&gt; list = new ArrayList&lt;&gt;(); //i可以理解成就是索引，扫描StringBuilder for (int i=0;i&lt;stringBuilder.length();)&#123; int count=1; boolean flag =true; Byte b =null; while(flag)&#123; //10101000010111... //递增的取出一个‘1’ ‘0’ String key = stringBuilder.substring(i,i+count);//i 不动，让count移动，指定匹配一个字符 b = map.get(key); if (b==null)&#123;//说明没有匹配到 count++; &#125;else&#123; //匹配到 flag = false; &#125; &#125; list.add(b); i += count;// i 直接移动到 count &#125; //当for循坏结束后，我们list中存放了所有的字符 \"i like like like java do you like a java\" //把list 中的数据放入到byte[] 并返回 byte b[] = new byte[list.size()]; for (int i =0; i&lt;b.length;i++)&#123; b[i] = list.get(i); &#125; return b;&#125; /** * 将一个字符串 转成一个二进制的字符串 * @param b 传入的byte * @param flag 标志是否需要补高位如果是true，表示需要补高位，如果是false 表示不补,如果是最后一个字节，无需补高位 * @return 是该b 对应的二进制的字符串，（注意是按补码返回) */ private static String byteToBitString(boolean flag,byte b)&#123; //使用变量保存 b int temp =b; //将b 转成 int //如果是正数我们还存在补高位 if (flag) &#123; temp |= 256;// 按位或256 1 0000 0000 | 0000 0001 =》 1 0000 0001 &#125; String str = Integer.toBinaryString(temp);//返回的是temp对应的二进制补码 if (flag)&#123; return str.substring(str.length()-8); //按8位处理 &#125;else&#123; return str; &#125; &#125;` 1.3.6 文件压缩代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//编写方法，将一个文件进行压缩 /** * * @param srcFile 你传入的希望压缩的文件的全路径 * @param dstFile 我们压缩文后将压缩文件放到哪个目录 */ public static void zipFile(String srcFile,String dstFile)&#123; //创建输出流 OutputStream os =null; ObjectOutputStream oos =null; //创建文件的输入流 FileInputStream is =null; try &#123; //创建文件的输入流 is = new FileInputStream(srcFile); //创建一个和源文件大小一样的Byte[] byte[] b = new byte[is.available()]; //读取文件 is.read(b); //直接对源文件压缩 byte[] huffmanBytes =huffmanZip(b); //创建文件的输出流，存放压缩文件 os = new FileOutputStream(dstFile); //创建一个和文件输出流关联的ObjectOutputStream oos = new ObjectOutputStream(os); //把 赫夫曼编码后的字节数组写入压缩文件 oos.writeObject(huffmanBytes);//我们先把 //以对象流的方式写入赫夫曼编码，是为了以后我们恢复源文件时使用 //注意一定要把赫夫曼编码写入压缩文件 oos.writeObject(huffmanCodes); &#125;catch (Exception e)&#123; System.out.println(e.getMessage()); &#125;finally &#123; try &#123; is.close(); oos.close(); os.close(); &#125; catch (IOException e) &#123; System.out.println(e.getMessage()); &#125; &#125; &#125; 1.3.7 文件解压代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142//编写一个方法，完成对压缩文件的解压 /** * * @param zipFile 准备解压的文件 * @param dstFile 将文件解压到哪个路径 */ public static void unZipFile(String zipFile,String dstFile) &#123; //定义文件输入流 InputStream is = null; //定义一个对象输入流 ObjectInputStream ois = null; //定义文件的输出流 OutputStream os = null; try &#123; //创建文件输入流 is = new FileInputStream(zipFile); //创建一个和 is 关联的对象输入流 ois = new ObjectInputStream(is); //读取byte数组 huffmanBytes byte[] huffmanBytes = (byte[]) ois.readObject(); //读取赫夫曼编码表 Map&lt;Byte, String&gt; huffmanCodes = (Map&lt;Byte, String&gt;) ois.readObject(); //解码 byte[] bytes = decode(huffmanCodes, huffmanBytes); //将bytes 数组写入到目标文件 os = new FileOutputStream(dstFile); //写数据 os.write(bytes); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; finally &#123; try &#123; os.close(); ois.close(); is.close(); &#125;catch (Exception e2)&#123; System.out.println(e2.getMessage()); &#125; &#125; &#125; 1.3.8 代码汇总123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439package com.atguigu.huffmancode;import java.io.*;import java.util.*;public class huffmanCode &#123; public static void main(String[] args) &#123; //测试压缩文件// String srcFile = \"d://a.jpg\";// String dstFile =\"d://dst.zip\";//// zipFile(srcFile,dstFile);// System.out.println(\"压缩文件成功~\"); //测试解压文件 String zipFile =\"d://dst.zip\"; String dstFile = \"d://src2.bmp\"; unZipFile(zipFile,dstFile); System.out.println(\"解压成功~\"); /* String content=\"i like like like java do you like a java\"; byte[] contentBytes = content.getBytes(); System.out.println(contentBytes.length);//40 byte[] huffmanCodeBytes =huffmanZip(contentBytes); System.out.println(\"压缩后的结果 \"+Arrays.toString(huffmanCodeBytes)+\" 长度 \"+huffmanCodeBytes.length); // 测试byteToBitString方法// System.out.println(byteToBitString((byte)1)); byte[] sourceBytes = decode(huffmanCodes,huffmanCodeBytes); System.out.println(\"原来的字符串=\"+new String(sourceBytes));// \"i like like like java do you like a java\"*/ //如果将数据进行解压（解码) /*分步过程 List&lt;Node&gt; nodes = getNodes(contentBytes); System.out.println(\"nodes=\"+nodes); //创建的二叉树 System.out.println(\"赫夫曼树\"); Node huffmanTreeRoot = createHuffmanTree(nodes); System.out.println(\"前序遍历\"); huffmanTreeRoot.preOrder(); //赫夫曼编码 Map&lt;Byte,String&gt; huffmanCodes=getCodes(huffmanTreeRoot); System.out.println(\"生成的赫夫曼编码表=\"+huffmanCodes); //测试 byte[] huffmanCodeBytes = zip(contentBytes,huffmanCodes); System.out.println(\"huffmanCodeBytes\"+Arrays.toString(huffmanCodeBytes));//17 */ &#125; //编写一个方法，完成对压缩文件的解压 /** * * @param zipFile 准备解压的文件 * @param dstFile 将文件解压到哪个路径 */ public static void unZipFile(String zipFile,String dstFile) &#123; //定义文件输入流 InputStream is = null; //定义一个对象输入流 ObjectInputStream ois = null; //定义文件的输出流 OutputStream os = null; try &#123; //创建文件输入流 is = new FileInputStream(zipFile); //创建一个和 is 关联的对象输入流 ois = new ObjectInputStream(is); //读取byte数组 huffmanBytes byte[] huffmanBytes = (byte[]) ois.readObject(); //读取赫夫曼编码表 Map&lt;Byte, String&gt; huffmanCodes = (Map&lt;Byte, String&gt;) ois.readObject(); //解码 byte[] bytes = decode(huffmanCodes, huffmanBytes); //将bytes 数组写入到目标文件 os = new FileOutputStream(dstFile); //写数据 os.write(bytes); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; finally &#123; try &#123; os.close(); ois.close(); is.close(); &#125;catch (Exception e2)&#123; System.out.println(e2.getMessage()); &#125; &#125; &#125; //编写方法，将一个文件进行压缩 /** * * @param srcFile 你传入的希望压缩的文件的全路径 * @param dstFile 我们压缩文后将压缩文件放到哪个目录 */ public static void zipFile(String srcFile,String dstFile)&#123; //创建输出流 OutputStream os =null; ObjectOutputStream oos =null; //创建文件的输入流 FileInputStream is =null; try &#123; //创建文件的输入流 is = new FileInputStream(srcFile); //创建一个和源文件大小一样的Byte[] byte[] b = new byte[is.available()]; //读取文件 is.read(b); //直接对源文件压缩 byte[] huffmanBytes =huffmanZip(b); //创建文件的输出流，存放压缩文件 os = new FileOutputStream(dstFile); //创建一个和文件输出流关联的ObjectOutputStream oos = new ObjectOutputStream(os); //把 赫夫曼编码后的字节数组写入压缩文件 oos.writeObject(huffmanBytes);//我们先把 //以对象流的方式写入赫夫曼编码，是为了以后我们恢复源文件时使用 //注意一定要把赫夫曼编码写入压缩文件 oos.writeObject(huffmanCodes); &#125;catch (Exception e)&#123; System.out.println(e.getMessage()); &#125;finally &#123; try &#123; is.close(); oos.close(); os.close(); &#125; catch (IOException e) &#123; System.out.println(e.getMessage()); &#125; &#125; &#125; //完成数据的解压 //思路 //1.将huffmanCodeBytes 【[-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]】 //重新先转成赫夫曼编码对应的二进制的字符串“1010100010111。。” //2.赫夫曼编码对应的二进制的字符串“10101000010111...” =&gt;赫夫曼编码=》“i like like like java do you like a java” //编写一个方法，完成对压缩数据的解码 /** * * @param huffmanCodes 赫夫曼编码 map * @param huffmanBytes 赫夫曼编码得到的字节数组 * @return 就是原来的字符串对应的数组 */ private static byte[] decode(Map&lt;Byte,String&gt; huffmanCodes, byte[] huffmanBytes)&#123; //1.先得到huffmanBytes 对应的二进制的字符串，形式 10101000010111... StringBuilder stringBuilder = new StringBuilder(); //将byte数组转成二进制的字符串 for (int i=0;i&lt;huffmanBytes.length;i++)&#123; byte b = huffmanBytes[i]; //判断是不是最后一个字节 boolean flag=(i==huffmanBytes.length-1); stringBuilder.append(byteToBitString(!flag,b)); &#125;// System.out.println(\"赫夫曼字节数组对应的二进制字符串=\"+stringBuilder.toString());// return null; //把字符串安装指定的赫夫曼编码进行解码 //把赫夫曼编码进行调换，因为反向查询 a-&gt;100 100-&gt;a Map&lt;String,Byte&gt; map = new HashMap&lt;String, Byte&gt;(); for (Map.Entry&lt;Byte,String&gt; entry:huffmanCodes.entrySet())&#123; map.put(entry.getValue(),entry.getKey()); &#125; //创建一个集合，存放byte List&lt;Byte&gt; list = new ArrayList&lt;&gt;(); //i可以理解成就是索引，扫描StringBuilder for (int i=0;i&lt;stringBuilder.length();)&#123; int count=1; boolean flag =true; Byte b =null; while(flag)&#123; //10101000010111... //递增的取出一个‘1’ ‘0’ String key = stringBuilder.substring(i,i+count);//i 不动，让count移动，指定匹配一个字符 b = map.get(key); if (b==null)&#123;//说明没有匹配到 count++; &#125;else&#123; //匹配到 flag = false; &#125; &#125; list.add(b); i += count;// i 直接移动到 count &#125; //当for循坏结束后，我们list中存放了所有的字符 \"i like like like java do you like a java\" //把list 中的数据放入到byte[] 并返回 byte b[] = new byte[list.size()]; for (int i =0; i&lt;b.length;i++)&#123; b[i] = list.get(i); &#125; return b;&#125; /** * 将一个字符串 转成一个二进制的字符串 * @param b 传入的byte * @param flag 标志是否需要补高位如果是true，表示需要补高位，如果是false 表示不补,如果是最后一个字节，无需补高位 * @return 是该b 对应的二进制的字符串，（注意是按补码返回) */ private static String byteToBitString(boolean flag,byte b)&#123; //使用变量保存 b int temp =b; //将b 转成 int //如果是正数我们还存在补高位 if (flag) &#123; temp |= 256;// 按位或256 1 0000 0000 | 0000 0001 =》 1 0000 0001 &#125; String str = Integer.toBinaryString(temp);//返回的是temp对应的二进制补码 if (flag)&#123; return str.substring(str.length()-8); //按8位处理 &#125;else&#123; return str; &#125; &#125; //使用一个方法，将前面的方法封装起来，便于我们调用 /** * * @param bytes 原始的字符串对应的字节数组 * @return 是经过 赫夫曼编码处理后的字节数组（压缩后的数组） */ private static byte[] huffmanZip(byte[] bytes)&#123; List&lt;Node&gt; nodes = getNodes(bytes); //根据nodes创建的赫夫曼树 Node huffmanTreeRoot = createHuffmanTree(nodes); //对应的赫夫曼编码（根据赫夫曼树） Map&lt;Byte,String&gt; huffmanCodes=getCodes(huffmanTreeRoot); //根据 byte[] huffmanCodeBytes = zip(bytes,huffmanCodes); return huffmanCodeBytes; &#125; //编写一个方法，将字符串对应的byte【】数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码 压缩的byte[] /** * * @param bytes 这时原始的字符串对应的byte[] * @param huffmanCodes 生成的赫夫曼编码map * @return 返回赫夫曼编码处理的byte[] * 举例：String content=\"i like like like java do you like a java\"; =》 byte[] contentBytes = content.getByte * 返回的字符串是 * =》 对应的byte[] huffmanCodebytes,即8位对应一个byte，放入到huffmanCodeBytes *huffmanCodebytes[0] = 10101000(补码） 11010111（反码） =&gt; 11011000 = -88 *huffmanCodebytes[1] =-88 */ public static byte[] zip(byte[] bytes,Map&lt;Byte,String&gt; huffmanCodes)&#123; //1.利用huffmanCode 将bytes 转成对应的字符串 StringBuilder stringBuilder = new StringBuilder(); //遍历bytes 数组 for (byte b:bytes)&#123; stringBuilder.append(huffmanCodes.get(b)); &#125; System.out.println(\"\"); //将\"1010100001011111110...\"转成byte[] //统计返回byte[] huffmanCodeBytes 长度 //一句话 int len = (stringBuilder.length()+)/8 int len; if (stringBuilder.length()%8==0)&#123; len=stringBuilder.length()/8; &#125;else&#123; len=stringBuilder.length()/8+1; &#125; //创建存储压缩后的 byte数组 byte[] huffmanCodeBytes = new byte[len]; int index =0;//记录是第几个byte for (int i=0;i&lt;stringBuilder.length();i+=8)&#123;//因为是每8位对应一个byte，所以步长+8 String strByte; if (i+8&gt;stringBuilder.length())&#123;//不够8位 strByte =stringBuilder.substring(i); &#125;else&#123; strByte =stringBuilder.substring(i,i+8); &#125; //将strByte 转成一个Byte，放入到huffmanCodeBytes huffmanCodeBytes[index] = (byte)Integer.parseInt(strByte,2); index++; &#125; return huffmanCodeBytes; &#125; //生成赫夫曼树对应的赫夫曼编码 //思路： //1.将赫夫曼码表存放在Map&lt;Byte,String&gt; 形式 // 32-&gt;0 97-&gt;100 100 -&gt;11000 等 static Map&lt;Byte,String&gt; huffmanCodes = new HashMap&lt;Byte,String&gt;(); //2. 在生成赫夫曼编码表示，需要拼接路径，定义一个StringBuilder 存储某个叶子结点的路径 static StringBuilder stringBuilder = new StringBuilder(); //为了调用方便，我们重载getCodes private static Map&lt;Byte,String&gt; getCodes(Node root)&#123; if (root==null)&#123; return null; &#125; //处理root的左子树 getCodes(root.left,\"0\",stringBuilder); //处理root的右子树 getCodes(root.right,\"1\",stringBuilder); return huffmanCodes; &#125; /** * 功能：将传入的node结点的所有叶子结点的赫夫曼编码得到，并放入到huffmanCodes集合 * @param node 传入结点 * @param code 路径：左子节点是0，右子节点是1 * @param stringBuilder 是用于拼接路径 */ private static void getCodes(Node node,String code,StringBuilder stringBuilder)&#123; StringBuilder stringBuilder2=new StringBuilder(stringBuilder); //将code 加入到stringBuilder2 stringBuilder2.append(code); if (node!=null)&#123; //如果node==null 不处理 //判断当前node 是叶子节点还是非叶子节点 if (node.data==null)&#123;//非叶子结点 //递归处理 //向左递归 getCodes(node.left,\"0\",stringBuilder2); //向右递归 getCodes(node.right,\"1\",stringBuilder2); &#125;else&#123; //说明是一个叶子结点 //就表示找到某个叶子结点的最后 huffmanCodes.put(node.data,stringBuilder2.toString()); &#125; &#125; &#125; //前序遍历的方法 private static void preOrder(Node root)&#123; if (root!=null)&#123; root.preOrder(); &#125;else&#123; System.out.println(\"赫夫曼树为空\"); &#125; &#125; /** * @param bytes 接收字节数组 * @return 返回的就是 List 形式 [Node[data97,weight=5],Node[data =32,weight=9]]... */ private static List&lt;Node&gt; getNodes(byte[] bytes)&#123; //1、创建一个ArrayList ArrayList&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;(); //遍历 bytes，统计 每一个byte 出现的次数 -》map[key,value] Map&lt;Byte,Integer&gt; counts = new HashMap&lt;&gt;(); for (byte b : bytes)&#123; Integer count = counts.get(b); if (count==null)&#123; //Map 还没有这个字符数据,第一次 counts.put(b,1); &#125;else&#123; counts.put(b,count+1); &#125; &#125; //把每个键值对转成一个Node对象，并加入到nodes集合 //遍历map for (Map.Entry&lt;Byte,Integer&gt; entry :counts.entrySet())&#123; nodes.add(new Node(entry.getKey(),entry.getValue())); &#125; return nodes; &#125; //可以通过List 创建对应的赫夫曼树 private static Node createHuffmanTree(List&lt;Node&gt; nodes)&#123; while(nodes.size()&gt;1)&#123; //排序,从小到大 Collections.sort(nodes); //取出第一颗最小的二叉树 Node leftNode = nodes.get(0); //取出第二颗最小的二叉树 Node rightNode = nodes.get(1); //创建一颗新的二叉树，它的根节点没有data，只有权值 Node parent = new Node(null,leftNode.weight+rightNode.weight); parent.left=leftNode; parent.right=rightNode; //将已经处理的两颗二叉树从nodes删除 nodes.remove(leftNode); nodes.remove(rightNode); //将新的二叉树，加入到nodes nodes.add(parent); &#125; //nodes 最后的节点 就是赫夫曼树的根节点 return nodes.get(0); &#125;&#125;//创建Node，待数据和权值class Node implements Comparable&lt;Node&gt;&#123; Byte data; //存放数据本身，比如‘a' =&gt; 97 ' ' =&gt;32 int weight; //权值，表示字符出现的次数 Node left;// Node right; public Node(Byte data,int weight)&#123; this.data =data; this.weight = weight; &#125; @Override public int compareTo(Node o) &#123; //从小到大排序 return this.weight-o.weight; &#125; @Override public String toString() &#123; return \"Node&#123;\" + \"data=\" + data + \", weight=\" + weight + '&#125;'; &#125; //前序遍历 public void preOrder()&#123; System.out.println(this); if (this.left!=null)&#123; this.left.preOrder(); &#125; if (this.right!=null)&#123; this.right.preOrder(); &#125; &#125;&#125; 1.3.9 赫夫曼编码压缩文件注意事项1）如果文件本身就是经过压缩处理的，那么使用赫夫曼编码效率不会有明显变化 2）按字节来处理，因此可以处理所有的文件（二进制文件，文本文件0 3）重复的数据不多，压缩效果不是很明显 1.4 二叉排序树1.4.1 需求{7,3,10,12,5,1,9}完成数据的查询添加 1.4.2 方法 使用数组 数组未排序 添加快，查找慢 数组排序 二分法，查找快，添加慢 链式存储链表查找慢 添加快 二叉排序树 1.4.3 二叉排序树介绍BST 任何一个飞叶子节点，左子节点的值比当前节点的值小，右子节点的值比当前节点值大注：如果相同值，左右均可 1.4.4 二叉排序树的创建和遍历代码实现class Node 1234567891011121314151617181920212223242526272829303132333435//添加节点方法 //递归的形式添加结点，注意需要满足二叉排序树的要求 public void add(Node node)&#123; if (node==null)&#123; return; &#125; //判断传入的节点的值，和当前子树的根节点的值的关系 if (node.value&lt;this.value)&#123; //如果当前结点左子节点为null if (this.left==null)&#123; this.left=node; &#125;else&#123; //递归的向左子树添加 this.left.add(node); &#125; &#125;else&#123;//添加的节点的值大于 当前节点的值 if (this.right==null)&#123; this.right=node; &#125;else&#123; //递归的向右子树添加 this.right.add(node); &#125; &#125; &#125; //中序遍历 public void infixOrder()&#123; if (this.left!=null)&#123; this.left.infixOrder(); &#125; System.out.println(this); if (this.right!=null)&#123; this.right.infixOrder(); &#125; &#125; class BinarySortTree 12345678910111213141516//添加节点的方法 public void add(Node node)&#123; if (root==null)&#123; root=node;//如果root为空则直接让root指向node &#125;else &#123; root.add(node); &#125; &#125; //中序遍历 public void infixOrder()&#123; if (root!=null)&#123; root.infixOrder(); &#125;else&#123; System.out.println(\"二叉排序树为空，不能遍历\"); &#125; &#125; 1.4.5 二叉排序树的删除代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237package com.atguigu.binarysorttree;public class BinarySortTreeDemo &#123; public static void main(String[] args) &#123; int[] arr=&#123;7,3,10,12,5,1,9,0&#125;; BinarySortTree binarySortTree = new BinarySortTree(); for (int i=0;i&lt;arr.length;i++)&#123; binarySortTree.add(new Node(arr[i])); &#125; //中序遍历 System.out.println(\"中序遍历二叉树\"); binarySortTree.infixOrder();//1,3,5,7,9,10,12 //测试一下删除叶子节点// binarySortTree.delNode(2);// binarySortTree.delNode(5);// binarySortTree.delNode(9);// binarySortTree.delNode(12);// binarySortTree.delNode(1);// binarySortTree.delNode(7); binarySortTree.delNode(10); System.out.println(\"删除节点后\"); binarySortTree.infixOrder(); &#125;&#125;//创建二叉排序树class BinarySortTree&#123; private Node root; //查找要删除的节点 public Node search(int value)&#123; if (root==null)&#123; return null; &#125;else&#123; return root.search(value); &#125; &#125; //查找父节点 public Node searchParent(int value)&#123; if (root == null)&#123; return null; &#125;else&#123; return root.searchParent(value); &#125; &#125; //编写方法 //1. 返回的 以node 为跟节点的二叉排序树的最小节点的值 //2. 删除的node为根节点的二叉排序树的最小节点 /** * * @param node 传入的结点（当做二叉排序树的根节点） * @return 返回的 以node 为跟节点的二叉排序树的最小节点的值 */ public int delRightTreeMin(Node node)&#123; Node target = node; //循坏的查找的左子节点，就会找到最小值 while(target.left!=null)&#123; target =target.left; &#125; //这是target指向了最小节点 //删除最小节点 delNode(target.value); return target.value; &#125; //删除节点 public void delNode(int value)&#123; if (root ==null)&#123; return; &#125;else&#123; //1.需求先去找到要删除的节点 targetNode Node targetNode = search(value); //如果没有找到要删除的节点 if (targetNode ==null)&#123; return; &#125; //如果我们发现当前这颗二叉排序树只有一个结点 if (root.left==null &amp;&amp; root.right==null)&#123; root =null; return; &#125; //去找到targetNode的父节点 Node parent = searchParent(value); //如果要删除的节点是叶子节点 if (targetNode.left ==null &amp;&amp; targetNode.right ==null)&#123; //判断targetNode 是父节点的左子节点，还是右子节点 if (parent.left!=null &amp;&amp; parent.left.value ==value)&#123; //是左子节点 parent.left =null; &#125;else if (parent.right!=null &amp;&amp; parent.right.value==value)&#123;//是右子节点 parent.right =null; &#125; &#125;else if (targetNode.left!=null &amp;&amp; targetNode.right!=null)&#123; // 删除有两颗子树的节点 int minVal = delRightTreeMin(targetNode.right); targetNode.value =minVal; &#125;else&#123; //删除只有一颗子树的结点 //如果要删除的节点只有左子节点 if (targetNode.left!=null)&#123; //如果targetNode 是parent 的左子节点 if (parent.left.value ==value)&#123; parent.left =targetNode.left; &#125;else&#123; // target是parent的右子节点 parent.right =targetNode.left; &#125; &#125; else&#123; //如果要删除的节点只有右子节点 //如果targetNode 是parent的左子节点 if (parent.left.value ==value)&#123; parent.left =targetNode.right; &#125;else&#123; //如果targetNode 是parent的右子节点 parent.right = targetNode.right; &#125; &#125; &#125; &#125; &#125; //添加节点的方法 public void add(Node node)&#123; if (root==null)&#123; root=node;//如果root为空则直接让root指向node &#125;else &#123; root.add(node); &#125; &#125; //中序遍历 public void infixOrder()&#123; if (root!=null)&#123; root.infixOrder(); &#125;else&#123; System.out.println(\"二叉排序树为空，不能遍历\"); &#125; &#125;&#125;//创建Node节点class Node&#123; int value; Node left; Node right; public Node(int value) &#123; this.value = value; &#125; //查找要删除的节点 /** * * @param value 希望删除的节点的值 * @return 如果找到返回该节点，否则返回null */ public Node search(int value)&#123; if (value == this.value)&#123; //找到就是该结点 return this; &#125; else if (value&lt;this.value)&#123; //如果查找的值小于当前节点，向左子树递归查找 //如果左子节点为空 if (this.left == null)&#123; return null; &#125; return this.left.search(value); &#125;else&#123;//如果查找的值不小于当前节点，向右子树递归查找 if (this.right==null)&#123; return null; &#125; return this.right.search(value); &#125; &#125; //查找要删除节点的父节点 /** * * @param value 要找到的节点的值 * @return 返回的是要删除的节点的父节点，如果没有就返回null */ public Node searchParent(int value)&#123; //如果当前节点就是要删除的节点的父节点，就返回 if ((this.left !=null &amp;&amp; this.left.value ==value) || (this.right!=null &amp;&amp; this.right.value ==value))&#123; return this; &#125;else&#123; //如果查找的值小于当前节点的值，并且当前节点的左子节点不为空 if (value&lt;this.value&amp;&amp;this.left!=null)&#123; return this.left.searchParent(value);//向左子树递归查找 &#125;else if (value&gt;=this.value &amp;&amp; this.right !=null)&#123; return this.right.searchParent(value); //向右子树递归查找 &#125;else&#123; return null;//没有找到父节点 ，比如根节点 &#125; &#125; &#125; @Override public String toString() &#123; return \"Node&#123;\" + \"value=\" + value + '&#125;'; &#125; //添加节点方法 //递归的形式添加结点，注意需要满足二叉排序树的要求 public void add(Node node)&#123; if (node==null)&#123; return; &#125; //判断传入的节点的值，和当前子树的根节点的值的关系 if (node.value&lt;this.value)&#123; //如果当前结点左子节点为null if (this.left==null)&#123; this.left=node; &#125;else&#123; //递归的向左子树添加 this.left.add(node); &#125; &#125;else&#123;//添加的节点的值大于 当前节点的值 if (this.right==null)&#123; this.right=node; &#125;else&#123; //递归的向右子树添加 this.right.add(node); &#125; &#125; &#125; //中序遍历 public void infixOrder()&#123; if (this.left!=null)&#123; this.left.infixOrder(); &#125; System.out.println(this); if (this.right!=null)&#123; this.right.infixOrder(); &#125; &#125;&#125; 1.4.7 课后作业删除情况三：从左子树找到最大的 12345678910111213141516171819//编写方法 //1. 返回的 以node 为跟节点的二叉排序树的最大节点的值 //2. 删除的node为根节点的二叉排序树的最大节点 /** * * @param node 传入的结点（当做二叉排序树的根节点） * @return 返回的 以node 为跟节点的二叉排序树的最大节点的值 */ public int delRightTreeMax(Node node)&#123; Node target = node; //循坏的查找的右子节点，就会找到最大值 while(target.right!=null)&#123; target =target.right; &#125; //这是target指向了最大节点 //删除最大节点 delNode(target.value); return target.value; &#125; 1.4.8 注意事项情况二删除只有一颗子树的节点出现bug 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277package com.atguigu.binarysorttree;public class BinarySortTreeDemo &#123; public static void main(String[] args) &#123; int[] arr=&#123;7,3,10,12,5,1,9,2&#125;; BinarySortTree binarySortTree = new BinarySortTree(); for (int i=0;i&lt;arr.length;i++)&#123; binarySortTree.add(new Node(arr[i])); &#125; //中序遍历 System.out.println(\"中序遍历二叉树\"); binarySortTree.infixOrder();//1,3,5,7,9,10,12 //测试一下删除叶子节点 binarySortTree.delNode(2); binarySortTree.delNode(5); binarySortTree.delNode(9); binarySortTree.delNode(12); binarySortTree.delNode(7); binarySortTree.delNode(3); binarySortTree.delNode(10); binarySortTree.delNode(1); System.out.println(\"删除节点后\"); System.out.println(\"root=\"+binarySortTree.getRoot()); binarySortTree.infixOrder(); &#125;&#125;//创建二叉排序树class BinarySortTree&#123; private Node root; public Node getRoot() &#123; return root; &#125; public void setRoot(Node root) &#123; this.root = root; &#125; //查找要删除的节点 public Node search(int value)&#123; if (root==null)&#123; return null; &#125;else&#123; return root.search(value); &#125; &#125; //查找父节点 public Node searchParent(int value)&#123; if (root == null)&#123; return null; &#125;else&#123; return root.searchParent(value); &#125; &#125; //编写方法 //1. 返回的 以node 为跟节点的二叉排序树的最小节点的值 //2. 删除的node为根节点的二叉排序树的最小节点 /** * * @param node 传入的结点（当做二叉排序树的根节点） * @return 返回的 以node 为跟节点的二叉排序树的最小节点的值 */ public int delRightTreeMin(Node node)&#123; Node target = node; //循坏的查找的左子节点，就会找到最小值 while(target.left!=null)&#123; target =target.left; &#125; //这是target指向了最小节点 //删除最小节点 delNode(target.value); return target.value; &#125; //编写方法 //1. 返回的 以node 为跟节点的二叉排序树的最大节点的值 //2. 删除的node为根节点的二叉排序树的最大节点 /** * * @param node 传入的结点（当做二叉排序树的根节点） * @return 返回的 以node 为跟节点的二叉排序树的最大节点的值 */ public int delRightTreeMax(Node node)&#123; Node target = node; //循坏的查找的右子节点，就会找到最大值 while(target.right!=null)&#123; target =target.right; &#125; //这是target指向了最大节点 //删除最大节点 delNode(target.value); return target.value; &#125; //删除节点 public void delNode(int value)&#123; if (root ==null)&#123; return; &#125;else&#123; //1.需求先去找到要删除的节点 targetNode Node targetNode = search(value); //如果没有找到要删除的节点 if (targetNode ==null)&#123; return; &#125; //如果我们发现当前这颗二叉排序树只有一个结点 if (root.left==null &amp;&amp; root.right==null)&#123; root =null; return; &#125; //去找到targetNode的父节点 Node parent = searchParent(value); //如果要删除的节点是叶子节点 if (targetNode.left ==null &amp;&amp; targetNode.right ==null)&#123; //判断targetNode 是父节点的左子节点，还是右子节点 if (parent.left!=null &amp;&amp; parent.left.value ==value)&#123; //是左子节点 parent.left =null; &#125;else if (parent.right!=null &amp;&amp; parent.right.value==value)&#123;//是右子节点 parent.right =null; &#125; &#125;else if (targetNode.left!=null &amp;&amp; targetNode.right!=null)&#123; // 删除有两颗子树的节点// int minVal = delRightTreeMin(targetNode.right);//// targetNode.value =minVal; int maxVal = delRightTreeMax(targetNode.left); targetNode.value =maxVal; &#125;else&#123; //删除只有一颗子树的结点 //如果要删除的节点只有左子节点 if (targetNode.left!=null)&#123; if (parent !=null) &#123; //如果targetNode 是parent 的左子节点 if (parent.left.value == value) &#123; parent.left = targetNode.left; &#125; else &#123; // target是parent的右子节点 parent.right = targetNode.left; &#125; &#125;else&#123; root =targetNode.left; &#125; &#125; else &#123; //如果要删除的节点只有右子节点 //如果targetNode 是parent的左子节点 if (parent != null) &#123; if (parent.left.value == value) &#123; parent.left = targetNode.right; &#125; else &#123; //如果targetNode 是parent的右子节点 parent.right = targetNode.right; &#125; &#125;else&#123; root =targetNode.right; &#125; &#125; &#125; &#125; &#125; //添加节点的方法 public void add(Node node)&#123; if (root==null)&#123; root=node;//如果root为空则直接让root指向node &#125;else &#123; root.add(node); &#125; &#125; //中序遍历 public void infixOrder()&#123; if (root!=null)&#123; root.infixOrder(); &#125;else&#123; System.out.println(\"二叉排序树为空，不能遍历\"); &#125; &#125;&#125;//创建Node节点class Node&#123; int value; Node left; Node right; public Node(int value) &#123; this.value = value; &#125; //查找要删除的节点 /** * * @param value 希望删除的节点的值 * @return 如果找到返回该节点，否则返回null */ public Node search(int value)&#123; if (value == this.value)&#123; //找到就是该结点 return this; &#125; else if (value&lt;this.value)&#123; //如果查找的值小于当前节点，向左子树递归查找 //如果左子节点为空 if (this.left == null)&#123; return null; &#125; return this.left.search(value); &#125;else&#123;//如果查找的值不小于当前节点，向右子树递归查找 if (this.right==null)&#123; return null; &#125; return this.right.search(value); &#125; &#125; //查找要删除节点的父节点 /** * * @param value 要找到的节点的值 * @return 返回的是要删除的节点的父节点，如果没有就返回null */ public Node searchParent(int value)&#123; //如果当前节点就是要删除的节点的父节点，就返回 if ((this.left !=null &amp;&amp; this.left.value ==value) || (this.right!=null &amp;&amp; this.right.value ==value))&#123; return this; &#125;else&#123; //如果查找的值小于当前节点的值，并且当前节点的左子节点不为空 if (value&lt;this.value&amp;&amp;this.left!=null)&#123; return this.left.searchParent(value);//向左子树递归查找 &#125;else if (value&gt;=this.value &amp;&amp; this.right !=null)&#123; return this.right.searchParent(value); //向右子树递归查找 &#125;else&#123; return null;//没有找到父节点 ，比如根节点 &#125; &#125; &#125; @Override public String toString() &#123; return \"Node&#123;\" + \"value=\" + value + '&#125;'; &#125; //添加节点方法 //递归的形式添加结点，注意需要满足二叉排序树的要求 public void add(Node node)&#123; if (node==null)&#123; return; &#125; //判断传入的节点的值，和当前子树的根节点的值的关系 if (node.value&lt;this.value)&#123; //如果当前结点左子节点为null if (this.left==null)&#123; this.left=node; &#125;else&#123; //递归的向左子树添加 this.left.add(node); &#125; &#125;else&#123;//添加的节点的值大于 当前节点的值 if (this.right==null)&#123; this.right=node; &#125;else&#123; //递归的向右子树添加 this.right.add(node); &#125; &#125; &#125; //中序遍历 public void infixOrder()&#123; if (this.left!=null)&#123; this.left.infixOrder(); &#125; System.out.println(this); if (this.right!=null)&#123; this.right.infixOrder(); &#125; &#125;&#125; 1.5 平衡二叉树（AVL）1.5.1 问题{1,2,3,4,5,6}，创建一颗二叉排序树问题分析：1）左子树全为空，单链表2）插入速度没有影响3）查询速度明显降低，不能发挥bst的优势，因为每次还要比较左子树，查询速度比单链表还慢4）使用平衡二叉树（AVL） 1.5.2 基本介绍1）平衡二叉搜索树 avl 查询效率高2）一颗空树或它的左右两个子树的高度差的绝对值不超过1，左右两个子树都是一颗平衡二叉树 1.5.3 单旋转（左）代码实现： 12345678910111213141516//左旋转方法 private void leftRotate()&#123; //创建新的节点，以当前根节点的值 Node newNode = new Node(value); //把新的节点的左子树设置成当前节点的左子树 newNode.left =left; //把新的结点的右子树设置成带你当前节点的右子树的左子树 newNode.right = right.left; //把当前接的值替换成右子节点的值 value = right.value; //把当前结点的右子树设置成当前节点右子树的右子树 right = right.right; //把当前节点的左子树（左子节点）设置成新的节点 left=newNode; &#125; 1.5.4 单旋转（右旋转）代码实现： 123456789//右旋转方法private void rightRotate()&#123; Node newNode = new Node(value); newNode.right=right; newNode.left = left.right; value=left.value; left=left.left; right=newNode;&#125; 1.5.5 双旋转代码实现： 12345678910111213141516171819202122232425262728//当添加完一个结点后，如果：(右子树的高度-左子树的高度) &gt; 1,左旋转 if (rightHeight()-leftHeight()&gt;1) &#123; //如果它的右子树的左子树高度大于它的右子树的右子树的高度 if (right != null &amp;&amp; right.rightHeight() &lt; right.leftHeight()) &#123; //先对右子节点进行右旋转 right.rightRotate(); //然后对当前结点进行左旋转 leftRotate();//左旋转 &#125; else &#123; //直接进行左旋转即可 leftRotate(); &#125; return; //必须要 &#125; //当添加完一个节点后，如果（左子树的高度-右子树的高度）&gt;1,右旋转 if (leftHeight()-rightHeight()&gt;1)&#123; //如果它的左子树的右子树高度大于它的左子树的高度 if (left!=null &amp;&amp; left.rightHeight()&gt;left.leftHeight()) &#123; //先对当前结点的左结点（左子树）-》左旋转 left.leftRotate(); //再对当前结点进行右旋转 rightRotate(); &#125;else&#123; //直接进行右旋转即可 rightRotate(); &#125; &#125; &#125; 1.5.6 最终代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352package com.atguigu.avl;public class AVLTreeDemo &#123; public static void main(String[] args) &#123;// int[] arr = &#123;4,3,6,5,7,8&#125;; int[] arr = &#123;10,12,8,9,7,6&#125;; //创建一个AVLTree对象 AVLTree avlTree = new AVLTree(); //添加节点 for (int i=0;i&lt;arr.length;i++)&#123; avlTree.add(new Node(arr[i])); &#125; //遍历 System.out.println(\"中序遍历\"); avlTree.infixOrder(); System.out.println(\"在平衡处理前~~\"); System.out.println(\"树的高度=\"+avlTree.getRoot().height());//4/3 System.out.println(\"树的左子树高度=\"+avlTree.getRoot().leftHeight());//1/2 System.out.println(\"树的右子树高度=\"+avlTree.getRoot().rightHeight());//3/2 System.out.println(\"当前根节点=\"+avlTree.getRoot());//8 System.out.println(\"根节点的左子节点+\"+avlTree.getRoot().left); &#125;&#125;//创建AVLTreeclass AVLTree &#123; private Node root; public Node getRoot() &#123; return root; &#125; public void setRoot(Node root) &#123; this.root = root; &#125; //查找要删除的节点 public Node search(int value) &#123; if (root == null) &#123; return null; &#125; else &#123; return root.search(value); &#125; &#125; //查找父节点 public Node searchParent(int value) &#123; if (root == null) &#123; return null; &#125; else &#123; return root.searchParent(value); &#125; &#125; //编写方法 //1. 返回的 以node 为跟节点的二叉排序树的最小节点的值 //2. 删除的node为根节点的二叉排序树的最小节点 /** * @param node 传入的结点（当做二叉排序树的根节点） * @return 返回的 以node 为跟节点的二叉排序树的最小节点的值 */ public int delRightTreeMin(Node node) &#123; Node target = node; //循坏的查找的左子节点，就会找到最小值 while (target.left != null) &#123; target = target.left; &#125; //这是target指向了最小节点 //删除最小节点 delNode(target.value); return target.value; &#125; //编写方法 //1. 返回的 以node 为跟节点的二叉排序树的最大节点的值 //2. 删除的node为根节点的二叉排序树的最大节点 /** * @param node 传入的结点（当做二叉排序树的根节点） * @return 返回的 以node 为跟节点的二叉排序树的最大节点的值 */ public int delRightTreeMax(Node node) &#123; Node target = node; //循坏的查找的右子节点，就会找到最大值 while (target.right != null) &#123; target = target.right; &#125; //这是target指向了最大节点 //删除最大节点 delNode(target.value); return target.value; &#125; //删除节点 public void delNode(int value) &#123; if (root == null) &#123; return; &#125; else &#123; //1.需求先去找到要删除的节点 targetNode Node targetNode = search(value); //如果没有找到要删除的节点 if (targetNode == null) &#123; return; &#125; //如果我们发现当前这颗二叉排序树只有一个结点 if (root.left == null &amp;&amp; root.right == null) &#123; root = null; return; &#125; //去找到targetNode的父节点 Node parent = searchParent(value); //如果要删除的节点是叶子节点 if (targetNode.left == null &amp;&amp; targetNode.right == null) &#123; //判断targetNode 是父节点的左子节点，还是右子节点 if (parent.left != null &amp;&amp; parent.left.value == value) &#123; //是左子节点 parent.left = null; &#125; else if (parent.right != null &amp;&amp; parent.right.value == value) &#123;//是右子节点 parent.right = null; &#125; &#125; else if (targetNode.left != null &amp;&amp; targetNode.right != null) &#123; // 删除有两颗子树的节点// int minVal = delRightTreeMin(targetNode.right);//// targetNode.value =minVal; int maxVal = delRightTreeMax(targetNode.left); targetNode.value = maxVal; &#125; else &#123; //删除只有一颗子树的结点 //如果要删除的节点只有左子节点 if (targetNode.left != null) &#123; if (parent != null) &#123; //如果targetNode 是parent 的左子节点 if (parent.left.value == value) &#123; parent.left = targetNode.left; &#125; else &#123; // target是parent的右子节点 parent.right = targetNode.left; &#125; &#125; else &#123; root = targetNode.left; &#125; &#125; else &#123; //如果要删除的节点只有右子节点 //如果targetNode 是parent的左子节点 if (parent != null) &#123; if (parent.left.value == value) &#123; parent.left = targetNode.right; &#125; else &#123; //如果targetNode 是parent的右子节点 parent.right = targetNode.right; &#125; &#125; else &#123; root = targetNode.right; &#125; &#125; &#125; &#125; &#125; //添加节点的方法 public void add(Node node) &#123; if (root == null) &#123; root = node;//如果root为空则直接让root指向node &#125; else &#123; root.add(node); &#125; &#125; //中序遍历 public void infixOrder() &#123; if (root != null) &#123; root.infixOrder(); &#125; else &#123; System.out.println(\"二叉排序树为空，不能遍历\"); &#125; &#125;&#125;//创建Node节点class Node&#123; int value; Node left; Node right; public Node(int value) &#123; this.value = value; &#125; //返回左子树的高度 public int leftHeight()&#123; if (left==null)&#123; return 0; &#125; return left.height(); &#125; //返回右子树的高度 public int rightHeight()&#123; if (right==null)&#123; return 0; &#125; return right.height(); &#125; //返回当前节点的高度，以该节点为根节点的数的高度 public int height()&#123; return Math.max(left==null?0:left.height(),right==null?0:right.height())+1; &#125; //左旋转方法 private void leftRotate()&#123; //创建新的节点，以当前根节点的值 Node newNode = new Node(value); //把新的节点的左子树设置成当前节点的左子树 newNode.left =left; //把新的结点的右子树设置成带你当前节点的右子树的左子树 newNode.right = right.left; //把当前接的值替换成右子节点的值 value = right.value; //把当前结点的右子树设置成当前节点右子树的右子树 right = right.right; //把当前节点的左子树（左子节点）设置成新的节点 left=newNode; &#125; //右旋转方法 private void rightRotate()&#123; Node newNode = new Node(value); newNode.right=right; newNode.left = left.right; value=left.value; left=left.left; right=newNode; &#125; //查找要删除的节点 /** * * @param value 希望删除的节点的值 * @return 如果找到返回该节点，否则返回null */ public Node search(int value)&#123; if (value == this.value)&#123; //找到就是该结点 return this; &#125; else if (value&lt;this.value)&#123; //如果查找的值小于当前节点，向左子树递归查找 //如果左子节点为空 if (this.left == null)&#123; return null; &#125; return this.left.search(value); &#125;else&#123;//如果查找的值不小于当前节点，向右子树递归查找 if (this.right==null)&#123; return null; &#125; return this.right.search(value); &#125; &#125; //查找要删除节点的父节点 /** * * @param value 要找到的节点的值 * @return 返回的是要删除的节点的父节点，如果没有就返回null */ public Node searchParent(int value)&#123; //如果当前节点就是要删除的节点的父节点，就返回 if ((this.left !=null &amp;&amp; this.left.value ==value) || (this.right!=null &amp;&amp; this.right.value ==value))&#123; return this; &#125;else&#123; //如果查找的值小于当前节点的值，并且当前节点的左子节点不为空 if (value&lt;this.value&amp;&amp;this.left!=null)&#123; return this.left.searchParent(value);//向左子树递归查找 &#125;else if (value&gt;=this.value &amp;&amp; this.right !=null)&#123; return this.right.searchParent(value); //向右子树递归查找 &#125;else&#123; return null;//没有找到父节点 ，比如根节点 &#125; &#125; &#125; @Override public String toString() &#123; return \"Node&#123;\" + \"value=\" + value + '&#125;'; &#125; //添加节点方法 //递归的形式添加结点，注意需要满足二叉排序树的要求 public void add(Node node)&#123; if (node==null)&#123; return; &#125; //判断传入的节点的值，和当前子树的根节点的值的关系 if (node.value&lt;this.value)&#123; //如果当前结点左子节点为null if (this.left==null)&#123; this.left=node; &#125;else&#123; //递归的向左子树添加 this.left.add(node); &#125; &#125;else&#123;//添加的节点的值大于 当前节点的值 if (this.right==null)&#123; this.right=node; &#125;else&#123; //递归的向右子树添加 this.right.add(node); &#125; &#125; //当添加完一个结点后，如果：(右子树的高度-左子树的高度) &gt; 1,左旋转 if (rightHeight()-leftHeight()&gt;1) &#123; //如果它的右子树的左子树高度大于它的右子树的右子树的高度 if (right != null &amp;&amp; right.rightHeight() &lt; right.leftHeight()) &#123; //先对右子节点进行右旋转 right.rightRotate(); //然后对当前结点进行左旋转 leftRotate();//左旋转 &#125; else &#123; //直接进行左旋转即可 leftRotate(); &#125; return; //必须要 &#125; //当添加完一个节点后，如果（左子树的高度-右子树的高度）&gt;1,右旋转 if (leftHeight()-rightHeight()&gt;1)&#123; //如果它的左子树的右子树高度大于它的左子树的高度 if (left!=null &amp;&amp; left.rightHeight()&gt;left.leftHeight()) &#123; //先对当前结点的左结点（左子树）-》左旋转 left.leftRotate(); //再对当前结点进行右旋转 rightRotate(); &#125;else&#123; //直接进行右旋转即可 rightRotate(); &#125; &#125; &#125;// &#125; //中序遍历 public void infixOrder()&#123; if (this.left!=null)&#123; this.left.infixOrder(); &#125; System.out.println(this); if (this.right!=null)&#123; this.right.infixOrder(); &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://lijiale96.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"堆排序","slug":"堆排序","permalink":"https://lijiale96.github.io/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"}]},{"title":"算法笔记7","slug":"算法笔记7","date":"2020-03-25T14:33:36.000Z","updated":"2020-03-27T07:36:08.532Z","comments":true,"path":"2020/03/25/算法笔记7/","link":"","permalink":"https://lijiale96.github.io/2020/03/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B07/","excerpt":"哈希1、哈希表1.1、Google上机题根据员工id，查找员工的所有信息不使用数据库，节省内存，速度越快越好=》哈希表 1.2、介绍散列表=哈希表，根据（key value）直接访问的数据结构映射函数 散列函数","text":"哈希1、哈希表1.1、Google上机题根据员工id，查找员工的所有信息不使用数据库，节省内存，速度越快越好=》哈希表 1.2、介绍散列表=哈希表，根据（key value）直接访问的数据结构映射函数 散列函数 1.3 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180package com.atguigu.hashtab;import java.util.Scanner;public class HashTabDemo &#123; public static void main(String[] args) &#123; //创建哈希表 HashTab hashTab = new HashTab(7); //写一个简单的菜单 String key =\"\"; Scanner scanner = new Scanner(System.in); while(true)&#123; System.out.println(\"add: 添加雇员\"); System.out.println(\"list: 显示雇员\"); System.out.println(\"find: 查找雇员\"); System.out.println(\"exit: 退出系统\"); key = scanner.next(); switch (key)&#123; case \"add\": System.out.println(\"输入id\"); int id =scanner.nextInt(); System.out.println(\"输入名字\"); String name = scanner.next(); //创建雇员 Emp emp=new Emp(id,name); hashTab.add(emp); break; case \"list\": hashTab.list(); break; case \"find\": System.out.println(\"请输入要查找的id\"); id = scanner.nextInt(); hashTab.findEmpById(id); break; case \"exit\": scanner.close(); System.exit(0); default: break; &#125; &#125; &#125;&#125;//创建HashTab 管理多条链表class HashTab&#123; private EmpLinkedList[] empLinkedListArray; private int size;//多少条链表 //构造器 public HashTab(int size)&#123; this.size =size; //初始化empLinkedListArray empLinkedListArray = new EmpLinkedList[size]; //这是不要初始化每个链表 for (int i=0;i&lt;size;i++)&#123; empLinkedListArray[i] = new EmpLinkedList(); &#125; &#125; //添加雇员 public void add(Emp emp)&#123; //根据员工的id，得到该员工 int empLinkedListNo = hashFun(emp.id); //将emp添加到对应的链表中 empLinkedListArray[empLinkedListNo].add(emp); &#125; //遍历所有的链表,遍历hashtab public void list()&#123; for (int i=0;i&lt;size;i++)&#123; empLinkedListArray[i].list(i); &#125; &#125; //根据输入的id 查找雇员 public void findEmpById(int id)&#123; //使用散列函数确定到哪条链表查找 int empLinkedListNo = hashFun(id); Emp emp = empLinkedListArray[empLinkedListNo].findEmpById(id); if (emp!=null) &#123;//找到 System.out.printf(\"在第%d条链表中找到 雇员 id = %d \\n\", (empLinkedListNo+1),id); &#125;else&#123; System.out.println(\"在哈希表中，没有找到该雇员\"); &#125; &#125; //编写散列函数，使用一个简单取模法 public int hashFun(int id)&#123; return id%size; &#125;&#125;//表示一个雇员class Emp&#123; public int id; public String name; public Emp next;//默认为null public Emp(int id, String name) &#123; super(); this.id = id; this.name = name; &#125;&#125;//创建EmpLinkedList，表示链表class EmpLinkedList&#123; //头指针，执行第一个Emp，因此我们这个链表的head 是直接指向第一个Emp private Emp head;//默认null //添加雇员到链表 //说明 //1.假定，当添加雇员时，id是自增长，即id的分配总是从小到大 // 因此我们将该雇员直接加入到本链表的最后即可 public void add(Emp emp)&#123; //如果是添加第一个雇员 if (head==null)&#123; head =emp; return; &#125; //如果不是第一个雇员，则使用一个辅助的指针，帮助定位到最后 Emp curEmp =head; while(true)&#123; if (curEmp.next==null)&#123; //说明到链表最后 break; &#125; curEmp = curEmp.next;//后移 &#125; //退出时直接将Emp加入链表 curEmp.next = emp; &#125; //遍历链表的雇员信息 public void list(int no) &#123; if (head == null) &#123;//说明链表为空 System.out.println(\"第 \"+(no+1)+\" 链表为空\"); return; &#125; System.out.print(\"第 \"+(no+1)+\" 链表的信息为\"); Emp curEmp = head;//辅助指针 while (true) &#123; System.out.printf(\" =&gt; id=%d name=%s\\t\", curEmp.id, curEmp.name); if (curEmp.next == null) &#123;//说明curEmp已经是最后结点 break; &#125; curEmp = curEmp.next;//后移，遍历 &#125; System.out.println(); &#125; //根据id查找雇员 //如果查到，就返回Emp，如果没有找到，就返回null public Emp findEmpById(int id)&#123; //判断链表是否为空 if (head==null)&#123; System.out.println(\"链表为空\"); return null; &#125; //辅助指针 Emp curEmp =head; while (true)&#123; if (curEmp.id==id)&#123;//找到 break;//这时curEmp就指向要查找的雇员 &#125; //退出 if (curEmp.next ==null) &#123;//说明遍历当前链表没有找到该雇员 curEmp =null; break; &#125; curEmp=curEmp.next;//以后 &#125; return curEmp; &#125;&#125; 思考：1）id从低到高插入，若不是从高到低2）该链表不带表头，链表的第一个节点就存放雇员信息3）删除操作的代码 1234567891011121314151617181920212223242526272829303132333435363738 public void delete(int id)&#123; Emp curEmp = head; boolean flag1 = false,flag2 = false; if (head==null)&#123; System.out.printf(\"要删除的%d不存在\",id); System.out.println(); return;// throw new RuntimeException(\"链表为空，不能删除\"); &#125; while(true)&#123; if (curEmp.next==null)&#123; break; &#125; if (curEmp.id==id)&#123; flag1=true; break; &#125; if (curEmp.next.id==id)&#123; flag2 =true; break; &#125; curEmp =curEmp.next; &#125; if (flag1)&#123; head=curEmp.next; System.out.printf(\"头节点 %d 删除\",id); &#125;else if (flag2)&#123; curEmp.next=curEmp.next.next; System.out.printf(\"第 %d 节点已删除\",id); &#125; else if (!flag1 || !flag2)&#123; System.out.printf(\"不好意思，删除的 第 %d 节点后就没了,再增加一个节点后操作吧\",id); &#125; else&#123; System.out.printf(\"要删除的%d不存在\",id); &#125; System.out.println(); &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://lijiale96.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"哈希","slug":"哈希","permalink":"https://lijiale96.github.io/tags/%E5%93%88%E5%B8%8C/"}]},{"title":"算法笔记6","slug":"算法笔记6","date":"2020-03-24T14:33:36.000Z","updated":"2020-03-25T14:19:27.134Z","comments":true,"path":"2020/03/24/算法笔记6/","link":"","permalink":"https://lijiale96.github.io/2020/03/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B06/","excerpt":"1、查找算法1.1、查找算法介绍1）顺序查找2）二分查找3）插值查找4）斐波那契查找","text":"1、查找算法1.1、查找算法介绍1）顺序查找2）二分查找3）插值查找4）斐波那契查找 1.2 线性查找代码实现： 1234567891011121314151617181920212223242526272829package com.atguigu.search;public class SeqSearch &#123; public static void main(String[] args) &#123; int arr[] &#x3D;&#123;1,9,11,-1,34,89&#125;;&#x2F;&#x2F;没有顺序的数组 int index &#x3D;seqSearch(arr,11); if (index&#x3D;&#x3D;-1)&#123; System.out.println(&quot;没有找到&quot;); &#125;else&#123; System.out.println(&quot;找到，下标&#x3D;&quot;+index); &#125; &#125; &#x2F;** * 这里我们实现的线性查找是找到一个满足条件的值，就返回 * @param arr * @param value * @return *&#x2F; public static int seqSearch(int[] arr,int value)&#123; &#x2F;&#x2F;线性查找是逐一比对，发现有相同值，就返回下标 for (int i&#x3D;0;i&lt;arr.length;i++)&#123; if (arr[i]&#x3D;&#x3D;value)&#123; return i; &#125; &#125; return -1; &#125;&#125; 1.3 二分查找算法说明：查找增加多个相同的值得下标代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.atguigu.search;import java.util.ArrayList;import java.util.List;&#x2F;&#x2F;注意：使用二分法查找的前提是 该数组是有序的public class BinarySearch &#123; public static void main(String[] args) &#123; int arr[] &#x3D;&#123;1,8,10,89,1000,1000,1000,1000,1000,1234&#125;;&#x2F;&#x2F; int resIndex &#x3D; binarySearch(arr,0,arr.length-1,8921);&#x2F;&#x2F; System.out.println(&quot;resIndex&#x3D;&quot;+resIndex); List&lt;Integer&gt; resIndexList&#x3D;binarySearch2(arr,0,arr.length-1,1000); System.out.println(&quot;resIndexList&#x3D;&quot;+resIndexList); &#125; &#x2F;&#x2F;二分查找算法 &#x2F;** * * @param arr 数组 * @param left 左索引 * @param right 右索引 * @param findVal 要查找的值 * @return 如果找到就返回下标，如果没有找到，就返回 -1 *&#x2F; public static int binarySearch(int[] arr,int left,int right,int findVal)&#123; &#x2F;&#x2F;当left&gt;right 时 说明递归整个数组，但是没有找到 if (left&gt;right)&#123; return -1; &#125; int mid &#x3D; (left+right)&#x2F;2; int midVal &#x3D; arr[mid]; if (findVal&gt;midVal)&#123; return binarySearch(arr,mid+1,right,findVal); &#125;else if(findVal&lt;midVal)&#123;&#x2F;&#x2F;向左递归 return binarySearch(arr,left,mid-1,findVal); &#125;else&#123; return mid; &#125; &#125; &#x2F;** * * @param arr 数组 * @param left 左索引 * @param right 右索引 * @param findVal 要查找的值 * @return 如果找到就返回下标，如果没有找到，就返回 -1 *&#x2F; public static ArrayList&lt;Integer&gt; binarySearch2(int[] arr,int left,int right,int findVal)&#123; &#x2F;&#x2F;当left&gt;right 时 说明递归整个数组，但是没有找到 if (left&gt;right)&#123; return new ArrayList&lt;Integer&gt;(); &#125; int mid &#x3D; (left+right)&#x2F;2; int midVal &#x3D; arr[mid]; if (findVal&gt;midVal)&#123; return binarySearch2(arr,mid+1,right,findVal); &#125;else if(findVal&lt;midVal)&#123;&#x2F;&#x2F;向左递归 return binarySearch2(arr,left,mid-1,findVal); &#125;else&#123; &#x2F;* &#x2F;&#x2F;思路分析 1.在找到mid索引值，不用马上返回 2.向mid索引值得左边扫描，将所有满足1000，的元素的下标，加入到集合ArrayList 3.向mid索引值得右边扫描，将所有满足1000，的元素的下标，加入到集合ArrayList 4.将Arraylist返回 *&#x2F; ArrayList&lt;Integer&gt; resIndexlist &#x3D; new ArrayList&lt;Integer&gt;(); &#x2F;&#x2F;向mid索引值得左边扫描，将所有满足1000，的元素的下标，加入到集合ArrayList int temp &#x3D; mid-1; while(true) &#123; if (temp &lt; 0 || arr[temp] !&#x3D; findVal) &#123;&#x2F;&#x2F;退出 break; &#125; &#x2F;&#x2F;否则，就temp放入到resIndexlist resIndexlist.add(temp); temp -&#x3D; 1;&#x2F;&#x2F;temp左移 &#125; resIndexlist.add(mid); &#x2F;&#x2F;向mid索引值得右边扫描，将所有满足1000，的元素的下标，加入到集合ArrayList temp &#x3D; mid+1; while(true) &#123; if (temp &gt; arr.length-1 || arr[temp] !&#x3D; findVal) &#123;&#x2F;&#x2F;退出 break; &#125; &#x2F;&#x2F;否则，就temp放入到resIndexlist resIndexlist.add(temp); temp +&#x3D; 1;&#x2F;&#x2F;temp左移 &#125; return resIndexlist; &#125; &#125;&#125; 1.4 插值查找类似于二分法，从自适应mid查找 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.atguigu.search;import java.util.Arrays;public class InsertValueSearch &#123; public static void main(String[] args) &#123; int[] arr = new int[100]; for (int i=0;i&lt;100;i++)&#123; arr[i] =i+1; &#125; int index= insertValueSearch(arr,0,arr.length-1,32);// int index= binarySearch(arr,0,arr.length-1,32); System.out.println(\"index=\"+index); &#125; //编写插值查找算法 //说明：插值查找算法，也要求数组是有序的 /** * * @param arr 数组 * @param left 左索引 * @param right 右索引 * @param findVal 查找值 * @return */ public static int insertValueSearch(int[] arr,int left,int right,int findVal)&#123; System.out.println(\"插值查找次数~\"); //注意：findVal &lt; arr[0] || findVal &gt;arr[arr.length-1]必须需要 //否则mid可能越界 if (left &gt; right || findVal &lt; arr[0] || findVal &gt;arr[arr.length-1])&#123; return -1; &#125; //求出mid int mid = left + (right-left)*(findVal-arr[left])/(arr[right]-arr[left]); int midVal = arr[mid]; if (findVal&gt;midVal)&#123; //说明应该向右边递归 return insertValueSearch(arr, mid+1, right, findVal); &#125;else if (findVal&lt;midVal)&#123; return insertValueSearch(arr, left, mid-1, findVal); &#125;else&#123; return mid; &#125; &#125; public static int binarySearch(int[] arr,int left,int right,int findVal)&#123; System.out.println(\"二分查找次数~\"); //当left&gt;right 时 说明递归整个数组，但是没有找到 if (left&gt;right)&#123; return -1; &#125; int mid = (left+right)/2; int midVal = arr[mid]; if (findVal&gt;midVal)&#123; return binarySearch(arr,mid+1,right,findVal); &#125;else if(findVal&lt;midVal)&#123;//向左递归 return binarySearch(arr,left,mid-1,findVal); &#125;else&#123; return mid; &#125; &#125;&#125; 注：1）数据量较大，关键值分布比较均匀，采用插值查找，速度较快2）关键值分布不均匀，该方法不一定比折半查找要好 1.5 斐波那契（黄金分割法）查找算法1）黄金分割点 0.6182）斐波那契数列{1,1,2,3,5,8,13,21,34,55} 有序数组才能用斐波那契查找算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.atguigu.search;import java.util.Arrays;public class FibonacciSearch &#123; public static int maxSize = 20; public static void main(String[] args) &#123; int[] arr = &#123;1, 8, 10, 89, 1000, 1234&#125;; System.out.println(fibSearch(arr,1));//0 &#125; //因为后面我们mid=low+F（k-1)-1，需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列 //非递归方法得到一个斐波那契数列 public static int[] fib() &#123; int[] f = new int[maxSize]; f[0] = 1; f[1] = 1; for (int i = 2; i &lt; maxSize; i++) &#123; f[i] = f[i - 1] + f[i - 2]; &#125; return f; &#125; //编写斐波那契查找算法 /** * @param a 数组 * @param key 我们需要查找的关键码（值） * @return */ public static int fibSearch(int[] a, int key) &#123; int low = 0; int high = a.length - 1; int k = 0;//表示斐波那契分割数值的下标 int mid = 0;//存放mid值 int f[] = fib();//获取斐波那契数列 //获取到斐波那契分割数值的下标 while (high &gt; f[k] - 1) &#123; k++; &#125; //因为f[k]值可能大于a的长度，因此我们需要使用Arrays类，构造一个新的数组，并指向temp[] //不足的部分会使用0填充 int[] temp = Arrays.copyOf(a, f[k]); //实际上需求使用a数组最后的数填充temp //举例： //temp=&#123;1,8,10,89,1000,1234,0,0,0&#125;=》 for (int i = high + 1; i &lt; temp.length; i++) &#123; temp[i] = a[high]; &#125; //使用while来循坏处理，找到我们的数key while (low &lt;= high) &#123;//只要这个条件满足，就可以找 mid = low + f[k - 1] - 1; if (key &lt; temp[mid]) &#123;//我们应该继续向数组的前面查找（左边） high = mid - 1; //为什么是k-- //1.全部元素=前面的元素+后边的元素 //2.f[k]=f[k-1]+f[k-2] //因为前面有f[k-1]个元素，所以可以继续拆分f[k-1]=f[k-2]+f[k-3] //即在f[k-1]的前面继续查找 k-- //即下次循坏 mid =f[k-1-1]-1 k--; &#125; else if (key &gt; temp[mid]) &#123;//我们应该继续向数组的前面查找（右边） low = mid + 1; //为什么是 k-=2 //说明 //1.全部元素=前面的元素+后边的元素 //2.f[k]=f[k-1]+f[k-2] //3.因为后面我们有f[k-2] 所以可以继续拆分f[k-2]=f[k-3]+f[k-4] //4.即在f[k-2]的前面进行查找 k-=2 //5.即下次循坏 mid=f[k-1-2]-1 k -= 2; &#125; else &#123;//找到 //需要确定，返回的是哪个下标 if (mid &lt;= high) &#123; return mid; &#125; else &#123; return high; &#125; &#125; &#125; return -1; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://lijiale96.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"查找","slug":"查找","permalink":"https://lijiale96.github.io/tags/%E6%9F%A5%E6%89%BE/"}]},{"title":"算法笔记8","slug":"算法笔记8","date":"2020-03-24T14:33:36.000Z","updated":"2020-03-31T16:25:33.222Z","comments":true,"path":"2020/03/24/算法笔记8/","link":"","permalink":"https://lijiale96.github.io/2020/03/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B08/","excerpt":"1、树结构基础部分1.1、二叉树1.1.1、为什么需要树这种数据结构1）数组优点：通过下标访问元素，速度快缺点：检索值，插入值缺点效率低 2）链式存储优点: 插入删除效率高缺点：检索效率仍然低下，从头节点遍历 3）树提供存储、读取效率，比如二叉排序树保证数据检索保证数据插入、增加、删除","text":"1、树结构基础部分1.1、二叉树1.1.1、为什么需要树这种数据结构1）数组优点：通过下标访问元素，速度快缺点：检索值，插入值缺点效率低 2）链式存储优点: 插入删除效率高缺点：检索效率仍然低下，从头节点遍历 3）树提供存储、读取效率，比如二叉排序树保证数据检索保证数据插入、增加、删除 1.1.2 术语叶子节点节点的权路径森林 1.1.3 二叉树1）最多两个子节点2）左节点、右节点3）满二叉树：叶子节点都在最后一层4）完全二叉树：所有叶子节点都在最后一层或者倒数第二层，最后一层叶子节点在左边连续，倒数第二层在右边连续 1.1.4 二叉树遍历说明1）前序：父，左，右2）中序：左，父，右3）后序：左，右，父看父节点顺序即可判断 1.1.5 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150package com.atguigu.tree;public class BinaryTreeDemo &#123; public static void main(String[] args) &#123; //先需要创建一个二叉树 BinaryTree binaryTree = new BinaryTree(); //创建需要的节点 HeroNode root = new HeroNode(1,\"宋江\"); HeroNode node2 = new HeroNode(2,\"吴用\"); HeroNode node3 = new HeroNode(3,\"卢俊义\"); HeroNode node4 = new HeroNode(4,\"林冲\"); HeroNode node5 = new HeroNode(5,\"关胜\"); //说明，我们先手动创建二叉树，后面我们学习递归的方式创建二叉树 root.setLeft(node2);// root.left =node2; root.setRight(node3); node3.setRight(node4); node3.setLeft(node5); binaryTree.setRoot(root); // System.out.println(\"前序遍历\");//1,2,3,5,4 binaryTree.preOrder(); System.out.println(\"中序遍历\");//2,1,5,3,4 binaryTree.infixOrder(); System.out.println(\"后序遍历\");//2,5,4,3,1 binaryTree.postOrder(); &#125;&#125;//定义BinaryTreeclass BinaryTree&#123; private HeroNode root; public void setRoot(HeroNode root) &#123; this.root = root; &#125; //前序遍历 public void preOrder()&#123; if (this.root!=null)&#123; this.root.preOrder(); &#125;else&#123; System.out.println(\"二叉树为空，无法遍历\"); &#125; &#125; //中序遍历 public void infixOrder()&#123; if (this.root!=null)&#123; this.root.infixOrder(); &#125;else&#123; System.out.println(\"二叉树为空，无法遍历\"); &#125; &#125; //后序遍历 public void postOrder()&#123; if (this.root!=null)&#123; this.root.postOrder(); &#125;else&#123; System.out.println(\"二叉树为空，无法遍历\"); &#125; &#125;&#125;class HeroNode&#123; private int no; private String name; private HeroNode left; //默认null private HeroNode right;//默认null public HeroNode(int no,String name)&#123; super(); this.no=no; this.name=name; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public HeroNode getLeft() &#123; return left; &#125; public void setLeft(HeroNode left) &#123; this.left = left; &#125; public HeroNode getRight() &#123; return right; &#125; public void setRight(HeroNode right) &#123; this.right = right; &#125; @Override public String toString() &#123; return \"HeroNode&#123;\" + \"no=\" + no + \", name='\" + name + '\\'' + '&#125;'; &#125; //编写前序遍历的方法 public void preOrder()&#123; System.out.println(this);//先输出父节点 //递归向左子树前序遍历 if (this.left!=null)&#123; this.left.preOrder(); &#125; //递归向右子树前序遍历 if (this.right!=null)&#123; this.right.preOrder(); &#125; &#125; //中序public void infixOrder()&#123; //递归左子树终须遍历 if (this.left != null) &#123; this.left.infixOrder(); &#125; System.out.println(this); if (this.right != null) &#123; this.right.infixOrder(); &#125;&#125; // 后序 public void postOrder()&#123; //递归左子树终须遍历 if (this.left != null) &#123; this.left.postOrder(); &#125; if (this.right != null) &#123; this.right.postOrder(); &#125; System.out.println(this); &#125;&#125; 1.1.6 二叉树-查找指定节点要求1）请编写前序查找，中序查找，后序查找2）分别使用三种查找方式，查找5的节点3）分析比较次数4）思路 5）代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278package com.atguigu.tree;public class BinaryTreeDemo &#123; public static void main(String[] args) &#123; //先需要创建一个二叉树 BinaryTree binaryTree = new BinaryTree(); //创建需要的节点 HeroNode root = new HeroNode(1,\"宋江\"); HeroNode node2 = new HeroNode(2,\"吴用\"); HeroNode node3 = new HeroNode(3,\"卢俊义\"); HeroNode node4 = new HeroNode(4,\"林冲\"); HeroNode node5 = new HeroNode(5,\"关胜\"); //说明，我们先手动创建二叉树，后面我们学习递归的方式创建二叉树 root.setLeft(node2);// root.left =node2; root.setRight(node3); node3.setRight(node4); node3.setLeft(node5); binaryTree.setRoot(root); // System.out.println(\"前序遍历\");//1,2,3,5,4 binaryTree.preOrder(); System.out.println(\"中序遍历\");//2,1,5,3,4 binaryTree.infixOrder(); System.out.println(\"后序遍历\");//2,5,4,3,1 binaryTree.postOrder(); //前序遍历 //前序遍历的次数 4次// System.out.println(\"前序遍历方式~~~\");// HeroNode resNode = binaryTree.preOrderSearch(5);// if (resNode!=null)&#123;// System.out.printf(\"找到了，信息为 no =%d name = %s\",resNode.getNo(),resNode.getName());// &#125;else&#123;// System.out.printf(\"没有找到no=%d的英雄\",5);// &#125; //中序遍历 //中序遍历的次数 3次// System.out.println(\"中序遍历方式~~~\");// HeroNode resNode = binaryTree.infixOrderSearch(5);// if (resNode!=null)&#123;// System.out.printf(\"找到了，信息为 no =%d name = %s\",resNode.getNo(),resNode.getName());// &#125;else&#123;// System.out.printf(\"没有找到no=%d的英雄\",5);// &#125; //后序遍历 //后序遍历的次数 3次 System.out.println(\"中序遍历方式~~~\"); HeroNode resNode = binaryTree.postOrderSearch(5); if (resNode!=null)&#123; System.out.printf(\"找到了，信息为 no =%d name = %s\",resNode.getNo(),resNode.getName()); &#125;else&#123; System.out.printf(\"没有找到no=%d的英雄\",5); &#125; &#125;&#125;//定义BinaryTreeclass BinaryTree&#123; private HeroNode root; public void setRoot(HeroNode root) &#123; this.root = root; &#125; //前序遍历 public void preOrder()&#123; if (this.root!=null)&#123; this.root.preOrder(); &#125;else&#123; System.out.println(\"二叉树为空，无法遍历\"); &#125; &#125; //中序遍历 public void infixOrder()&#123; if (this.root!=null)&#123; this.root.infixOrder(); &#125;else&#123; System.out.println(\"二叉树为空，无法遍历\"); &#125; &#125; //后序遍历 public void postOrder()&#123; if (this.root!=null)&#123; this.root.postOrder(); &#125;else&#123; System.out.println(\"二叉树为空，无法遍历\"); &#125; &#125; //前序遍历 public HeroNode preOrderSearch(int no)&#123; if (root!=null)&#123; return root.preOrderSearch(no); &#125;else&#123; return null; &#125; &#125; //中序遍历 public HeroNode infixOrderSearch(int no)&#123; if (root!=null)&#123; return root.infixOrderSearch(no); &#125;else&#123; return null; &#125; &#125; //后序遍历 public HeroNode postOrderSearch(int no)&#123; if (root!=null)&#123; return root.postOrderSearch(no); &#125;else&#123; return null; &#125; &#125;&#125;class HeroNode&#123; private int no; private String name; private HeroNode left; //默认null private HeroNode right;//默认null public HeroNode(int no,String name)&#123; super(); this.no=no; this.name=name; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public HeroNode getLeft() &#123; return left; &#125; public void setLeft(HeroNode left) &#123; this.left = left; &#125; public HeroNode getRight() &#123; return right; &#125; public void setRight(HeroNode right) &#123; this.right = right; &#125; @Override public String toString() &#123; return \"HeroNode&#123;\" + \"no=\" + no + \", name='\" + name + '\\'' + '&#125;'; &#125; //编写前序遍历的方法 public void preOrder()&#123; System.out.println(this);//先输出父节点 //递归向左子树前序遍历 if (this.left!=null)&#123; this.left.preOrder(); &#125; //递归向右子树前序遍历 if (this.right!=null)&#123; this.right.preOrder(); &#125; &#125; //中序public void infixOrder()&#123; //递归左子树终须遍历 if (this.left != null) &#123; this.left.infixOrder(); &#125; System.out.println(this); if (this.right != null) &#123; this.right.infixOrder(); &#125;&#125; // 后序 public void postOrder()&#123; //递归左子树终须遍历 if (this.left != null) &#123; this.left.postOrder(); &#125; if (this.right != null) &#123; this.right.postOrder(); &#125; System.out.println(this); &#125; //前序遍历查找 /** * * @param no 查找no * @return 如果找到就返回该node，如果没有找到就返回null */ public HeroNode preOrderSearch(int no)&#123; System.out.println(\"进入前序遍历\"); //比较当前节点是不是 if (this.no==no)&#123; return this; &#125; //1.则判断当前节点的左子节点是否为空，如果不为空，则递归前序查找 //2.如果左递归前序查找，找到节点，则返回 HeroNode resNode =null; if (this.left!=null)&#123; resNode = this.left.preOrderSearch(no); &#125; if (resNode !=null)&#123; //说明我们左子树找到 return resNode; &#125; //1.左递归前序查找，找到结点，则返回，否继续判断 //2.当前的节点的右子节点是否为空，如果不空，则继续向右递归前序查找 if (this.right!=null)&#123; resNode = this.right.preOrderSearch(no); &#125; return resNode; &#125; //中序遍历查找 public HeroNode infixOrderSearch(int no)&#123; //判断当前节点的左子节点是否为空，如果不为空，则递归中序查找 HeroNode resNode =null; if (this.left!=null)&#123; resNode = this.left.infixOrderSearch(no); &#125; if (resNode!=null)&#123; return resNode; &#125; System.out.println(\"进入中序遍历\"); //如果找到，则返回，如果没有找到，就和当前节点比较，如果是则返回当前节点 if (this.no==no)&#123; return this; &#125; //否则继续进行有递归的中序查找 if (this.right!=null)&#123; resNode = this.right.infixOrderSearch(no); &#125; return resNode; &#125; //后序遍历 public HeroNode postOrderSearch(int no)&#123; HeroNode resNode=null; if (this.left!=null)&#123; resNode = this.left.postOrderSearch(no); &#125; if (resNode!=null)&#123; //说明在左子树找到 return resNode; &#125; //如果右子树没有找到，则向右子树递归进行后序遍历查找 if (this.right!=null)&#123; resNode=this.right.postOrderSearch(no); &#125; if (resNode!=null)&#123; return resNode; &#125; System.out.println(\"进入后序遍历\"); //如果左右子树都没有找到，就比较当前节点是不是 if (this.no==no)&#123; return this; &#125; return resNode; &#125;&#125; 1.1.7 二叉树-删除节点要求1）如果删除的节点是叶子节点，则删除该节点2）如果删除的节点是非叶子节点，则删除该子树3）删除5号叶子节点和3 号子树思路1、单向，判断当前节点的子节点是否需要删除节点，而不能去判断当前这个节点是不是需要删除节点2、如果当前节点左子节点不为空，并且左子节点就是要删除节点，就将this.left=null,并且就返回（结束递归删除）3、如果当前节点右子节点不为空，并且右子节点就是要删除节点，就将this.right=null,并且就返回（结束递归删除）4、如果2和3没有删除，那么我们就需要向左子树进行递归删除 5、如果第4步也没有删除节点，则应该向右子树进行删除 代码实现：在class HeroNode中添加代码 12345678910111213141516171819202122232425262728293031//递归删除节点 //1.如果删除的节点是叶子节点，则删除该节点 //2.如果删除的节点是非叶子节点，则删除该子树 public void delNode(int no)&#123; //思路 /** * 1、单向，判断当前节点的子节点是否需要删除节点，而不能去判断当前这个节点是不是需要删除节点 * 2、如果当前节点左子节点不为空，并且左子节点就是要删除节点，就将this.left=null,并且就返回（结束递归删除） * 3、如果当前节点右子节点不为空，并且右子节点就是要删除节点，就将this.right=null,并且就返回（结束递归删除） * 4、如果2和3没有删除，那么我们就需要向左子树进行递归删除 * 5、如果第4步也没有删除节点，则应该向右子树进行删除 */ //2、如果当前节点左子节点不为空，并且左子节点就是要删除节点，就将this.left=null,并且就返回（结束递归删除） if (this.left !=null &amp;&amp; this.left.no==no)&#123; this.left=null; return; &#125; //3、如果当前节点右子节点不为空，并且右子节点就是要删除节点，就将this.right=null,并且就返回（结束递归删除） if (this.right !=null &amp;&amp; this.right.no==no)&#123; this.right=null; return; &#125; //4、我们就需要向左子树进行递归删除 if (this.left!=null)&#123; this.left.delNode(no); &#125; //5、应该向右子树进行删除 if (this.right!=null)&#123; this.right.delNode(no); &#125; &#125; 在class BinaryTree 添加代码 1234567891011121314//删除节点public void delNode(int no)&#123; if (root!=null) &#123;//如果只有一个root节点，这里立即判断root是不是就是要删除节点 if (root.getNo() == no) &#123; root = null; &#125; else &#123; //递归删除 root.delNode(no); &#125; &#125;else&#123; System.out.println(\"空树，不能删除\"); &#125;&#125; 1.1.8 课后思考1）非叶子节点A只有一个B，B替代A2）非叶子节点A有B和c，让左子节点替代A3）二叉排序树讲解在class HeroNode 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public void delNode(int no)&#123; //思路 /** * 1、单向，判断当前节点的子节点是否需要删除节点，而不能去判断当前这个节点是不是需要删除节点 * 2、如果当前节点左子节点不为空，并且左子节点就是要删除节点，就将this.left=null,并且就返回（结束递归删除） * 3、如果当前节点右子节点不为空，并且右子节点就是要删除节点，就将this.right=null,并且就返回（结束递归删除） * 4、如果2和3没有删除，那么我们就需要向左子树进行递归删除 * 5、如果第4步也没有删除节点，则应该向右子树进行删除 */ //2、如果当前节点左子节点不为空，并且左子节点就是要删除节点，就将this.left=null,并且就返回（结束递归删除） //非叶子节点A只有一个B，B替代A //非叶子节点A有B和c，让左子节点替代A if (this.left !=null &amp;&amp; this.left.no==no)&#123; if (this.left.left !=null&amp;&amp; this.left.right !=null)&#123; this.left =this.left.left; return; &#125; else if(this.left.left !=null )&#123; this.left = this.left.left; return; &#125;else if ( this.left.right !=null)&#123; this.left = this.left.right; return; &#125; this.left=null; return; &#125; //3、如果当前节点右子节点不为空，并且右子节点就是要删除节点，就将this.right=null,并且就返回（结束递归删除） //非叶子节点A只有一个B，B替代A //非叶子节点A有B和c，让左子节点替代A if (this.right !=null &amp;&amp; this.right.no==no)&#123; if (this.right.left !=null&amp;&amp; this.right.right !=null)&#123; this.right =this.right.left; return; &#125; if(this.right.left !=null )&#123; this.right= this.right.left; return; &#125;else if ( this.right.right !=null)&#123; this.right= this.right.right; return; &#125; this.right=null; return; &#125; //4、我们就需要向左子树进行递归删除 if (this.left!=null)&#123; this.left.delNode(no); &#125; //5、应该向右子树进行删除 if (this.right!=null)&#123; this.right.delNode(no); &#125; &#125; 1.2 顺序存储二叉树1.2.1 概念数组可以转换成树，树也可以转换成数组 特点：1） 只考虑完全二叉树2） 第n个元素的左子节点为2n+13） 第n个元素的右子节点为2n+24） 第n个元素的父节点为(n-1)/25） n表示二叉树的第几个元素（按0开始） 1.2.2 实现代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.atguigu.tree;public class ArrBinaryTreeDemo &#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 2, 3, 4, 5, 6, 7&#125;; //创建一个ArrBinaryTree ArrBinaryTree arrBinaryTree = new ArrBinaryTree(arr); arrBinaryTree.preOrder();//1,2,4,5,3,6,7 &#125;&#125;class ArrBinaryTree&#123; private int[] arr;//存储数据节点的数据 public ArrBinaryTree(int[] arr)&#123; this.arr=arr; &#125; //重载preOrder public void preOrder()&#123; this.arr=arr; &#125; //编写一个方法，完成顺序存储二叉树的前序遍历 /** * * @param index 数组的下标 */ public void preOrder(int index)&#123; //如果数组为空，或者arr.length=0 if(arr==null||arr.length==0)&#123; System.out.println(\"数组为空，不能按照二叉树的前序遍历\"); &#125; //输出当前这个元素 System.out.println(arr[index]); //向左递归遍历 if ((index*2+1)&lt;arr.length)&#123; preOrder(2*index+1); &#125; //向右递归遍历 if((index*2+2)&lt;arr.length)&#123; preOrder(2*index+2); &#125; &#125;&#125; 1.2.4 课后练习完成对数组以二叉树中序、后序遍历 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.atguigu.tree;public class ArrBinaryTreeDemo &#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 2, 3, 4, 5, 6, 7&#125;; //创建一个ArrBinaryTree ArrBinaryTree arrBinaryTree = new ArrBinaryTree(arr); System.out.println(\"前序\"); arrBinaryTree.preOrder();//1,2,4,5,3,6,7 System.out.println(); System.out.println(\"中序\"); arrBinaryTree.infixOrder();//4,2,5,1,6,3,7 System.out.println(); System.out.println(\"后序\"); arrBinaryTree.postOrder();//4,5,2,6,7,3,1 &#125;&#125;class ArrBinaryTree&#123; private int[] arr;//存储数据节点的数据 public ArrBinaryTree(int[] arr)&#123; this.arr=arr; &#125; //重载preOrder public void preOrder()&#123; this.preOrder(0); &#125; //重载preOrder public void infixOrder()&#123; this.infixOrder(0); &#125; //重载preOrder public void postOrder()&#123; this.postOrder(0); &#125; //编写一个方法，完成顺序存储二叉树的前序遍历 /** * * @param index 数组的下标 */ public void preOrder(int index)&#123; //如果数组为空，或者arr.length=0 if(arr==null||arr.length==0)&#123; System.out.println(\"数组为空，不能按照二叉树的前序遍历\"); &#125; //输出当前这个元素 System.out.print(arr[index]); //向左递归遍历 if ((index*2+1)&lt;arr.length)&#123; preOrder(2*index+1); &#125; //向右递归遍历 if((index*2+2)&lt;arr.length)&#123; preOrder(2*index+2); &#125; &#125; /** * * @param index 数组的下标 */ public void infixOrder(int index)&#123; //如果数组为空，或者arr.length=0 if(arr==null||arr.length==0)&#123; System.out.println(\"数组为空，不能按照二叉树的中序遍历\"); &#125; //输出当前这个元素 //向左递归遍历 if ((index*2+1)&lt;arr.length)&#123; infixOrder(2*index+1); &#125; System.out.print(arr[index]); //向右递归遍历 if((index*2+2)&lt;arr.length)&#123; infixOrder(2*index+2); &#125; &#125; /** * * @param index 数组的下标 */ public void postOrder(int index)&#123; //如果数组为空，或者arr.length=0 if(arr==null||arr.length==0)&#123; System.out.println(\"数组为空，不能按照二叉树的后序遍历\"); &#125; //输出当前这个元素 //向左递归遍历 if ((index*2+1)&lt;arr.length)&#123; postOrder(2*index+1); &#125; //向右递归遍历 if((index*2+2)&lt;arr.length)&#123; postOrder(2*index+2); &#125; System.out.print(arr[index]); &#125;&#125; 1.2.4 顺序存储二叉树的应用实例堆排序使用到顺序存储二叉树 1.3 线索化二叉树1.3.1 问题将数列{1,3,6,8,10,14}构成一个二叉树，n+1=7 分析：1）中序遍历，数列为{8,3,10,1,6,14}2）但是 6,8,10,14这几个节点的左右指针，并没有完全利用上3）充分利用各个节点的左右指针4）线索二叉树 1.3.2 介绍附加的指针 ：线索一个节点前一个节点，前驱节点一个节点后一个节点，后继节点 1.3.3 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404package com.atguigu.tree.threadedbinarytree;public class ThreadedBinaryTreeDemo &#123; public static void main(String[] args) &#123; HeroNode root = new HeroNode(1,\"kang\"); HeroNode node2 = new HeroNode(3,\"tom\"); HeroNode node3 = new HeroNode(6,\"jack\"); HeroNode node4 = new HeroNode(8,\"smith\"); HeroNode node5 = new HeroNode(10,\"dim\"); HeroNode node6 = new HeroNode(14,\"bb\"); root.setLeft(node2); root.setRight(node3); node2.setLeft(node4); node2.setRight(node5); node3.setLeft(node6); //中序线索化 ThreadedBinaryTree threadedBinaryTree = new ThreadedBinaryTree(); threadedBinaryTree.setRoot(root); threadedBinaryTree.threadedNodes(); //测试：以10号节点测试 HeroNode leftNode = node5.getLeft(); HeroNode rightNode = node5.getRight(); System.out.println(\"10号节点的前驱结点是= \" + leftNode); System.out.println(\"10号结点的后继节点是= \" + rightNode); //当线索化二叉树后，能在使用原来的遍历方法// threadedBinaryTree.infixOrder(); System.out.println(\"使用线索化的方式遍历 线索化二叉树\"); threadedBinaryTree.threadedList(); &#125;&#125;//线索化二叉树//定义ThreadBinaryTree 实现了线索化功能的二叉树class ThreadedBinaryTree&#123; private HeroNode root; //为了实现线索化，需要创建要给指向当前结点的前驱节点的指针 //在递归进行线索化时，pre总是保留前一个节点 private HeroNode pre =null; public void setRoot(HeroNode root) &#123; this.root = root; &#125; //重载threadedNodes public void threadedNodes()&#123; this.threadedNodes(root); &#125; //遍历线索化二叉树的方法 public void threadedList()&#123; //定义一个变量，存储当前遍历的节点，从root开始 HeroNode node =root; while(node != null)&#123; //循坏的找到leftType ==1 的结点，第一个找到就是8节点 //后面随着遍历而变化，因为当leftType==1时，说明该结点是按照线索化 //处理后的节点 while(node.getLeftType()==0)&#123; node = node.getLeft(); &#125; //打印当前这个节点 System.out.println(node); //如果当前节点的右指针指向的是后继节点，就一直输出 while(node.getRightType()==1)&#123; //获取到当前结点的后继节点 node = node.getRight(); System.out.println(node); &#125; //替换这个遍历的节点 node = node.getRight(); &#125; &#125; //编写对二叉树进行中序线索化的方法 /** * * @param node 就是当前需要线索化的结点 */ public void threadedNodes(HeroNode node)&#123; //如果 node==null，不能线索化 if (node==null)&#123; return; &#125; // (一) 先线索化左子树 threadedNodes(node.getLeft()); // (二) 线索化当前结点[有点难度] //处理当前节点的前驱节点 //以8结点的left == null，8结点的leftType=1（相当于前驱节点，空） if (node.getLeft()==null)&#123; //让当前结点的左指针指向前驱节点(pre) node.setLeft(pre); //修改当前节点的左指针的类型，指向前驱节点 node.setLeftType(1);//8结点的leftType=1（相当于前驱节点，空） &#125; //处理后继节点 if (pre != null &amp;&amp; pre.getRight()==null)&#123;//如果本身有值就不能处理 //让前驱结点的右指针指向当前节点 pre.setRight(node); //修改前驱结点的右指针类型 pre.setRightType(1); &#125; //!!!每处理一个节点后，让当前节点是下一个节点的前驱节点 pre = node; // (三) 再线索化右子树 threadedNodes(node.getRight()); &#125; //删除节点 public void delNode(int no)&#123; if (root!=null) &#123; //如果只有一个root节点，这里立即判断root是不是就是要删除节点 if (root.getNo() == no) &#123; root = null; &#125; else &#123; //递归删除 root.delNode(no); &#125; &#125;else&#123; System.out.println(\"空树，不能删除\"); &#125; &#125; //前序遍历 public void preOrder()&#123; if (this.root!=null)&#123; this.root.preOrder(); &#125;else&#123; System.out.println(\"二叉树为空，无法遍历\"); &#125; &#125; //中序遍历 public void infixOrder()&#123; if (this.root!=null)&#123; this.root.infixOrder(); &#125;else&#123; System.out.println(\"二叉树为空，无法遍历\"); &#125; &#125; //后序遍历 public void postOrder()&#123; if (this.root!=null)&#123; this.root.postOrder(); &#125;else&#123; System.out.println(\"二叉树为空，无法遍历\"); &#125; &#125; //前序遍历 public HeroNode preOrderSearch(int no)&#123; if (root!=null)&#123; return root.preOrderSearch(no); &#125;else&#123; return null; &#125; &#125; //中序遍历 public HeroNode infixOrderSearch(int no)&#123; if (root!=null)&#123; return root.infixOrderSearch(no); &#125;else&#123; return null; &#125; &#125; //后序遍历 public HeroNode postOrderSearch(int no)&#123; if (root!=null)&#123; return root.postOrderSearch(no); &#125;else&#123; return null; &#125; &#125;&#125;//创建HeroNodeclass HeroNode &#123; private int no; private String name; private HeroNode left; //默认null private HeroNode right;//默认null //说明 //1. 如果leftType == 0 表示指向的是左子树，如果1则表示指向前驱节点 //2. 如果rightType == 0 表示指向的是右子树，如果1表示指向后继节点 private int LeftType; private int RightType; public int getLeftType() &#123; return LeftType; &#125; public void setLeftType(int leftType) &#123; LeftType = leftType; &#125; public int getRightType() &#123; return RightType; &#125; public void setRightType(int rightType) &#123; RightType = rightType; &#125; public HeroNode(int no, String name) &#123; super(); this.no = no; this.name = name; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public HeroNode getLeft() &#123; return left; &#125; public void setLeft(HeroNode left) &#123; this.left = left; &#125; public HeroNode getRight() &#123; return right; &#125; public void setRight(HeroNode right) &#123; this.right = right; &#125; @Override public String toString() &#123; return \"HeroNode&#123;\" + \"no=\" + no + \", name='\" + name + '\\'' + '&#125;'; &#125; //递归删除节点 //1.如果删除的节点是叶子节点，则删除该节点 //2.如果删除的节点是非叶子节点，则删除该子树 public void delNode(int no) &#123; //思路 /** * 1、单向，判断当前节点的子节点是否需要删除节点，而不能去判断当前这个节点是不是需要删除节点 * 2、如果当前节点左子节点不为空，并且左子节点就是要删除节点，就将this.left=null,并且就返回（结束递归删除） * 3、如果当前节点右子节点不为空，并且右子节点就是要删除节点，就将this.right=null,并且就返回（结束递归删除） * 4、如果2和3没有删除，那么我们就需要向左子树进行递归删除 * 5、如果第4步也没有删除节点，则应该向右子树进行删除 */ //2、如果当前节点左子节点不为空，并且左子节点就是要删除节点，就将this.left=null,并且就返回（结束递归删除） if (this.left != null &amp;&amp; this.left.no == no) &#123; this.left = null; return; &#125; //3、如果当前节点右子节点不为空，并且右子节点就是要删除节点，就将this.right=null,并且就返回（结束递归删除） if (this.right != null &amp;&amp; this.right.no == no) &#123; this.right = null; return; &#125; //4、我们就需要向左子树进行递归删除 if (this.left != null) &#123; this.left.delNode(no); &#125; //5、应该向右子树进行删除 if (this.right != null) &#123; this.right.delNode(no); &#125; &#125; //编写前序遍历的方法 public void preOrder() &#123; System.out.println(this);//先输出父节点 //递归向左子树前序遍历 if (this.left != null) &#123; this.left.preOrder(); &#125; //递归向右子树前序遍历 if (this.right != null) &#123; this.right.preOrder(); &#125; &#125; //中序 public void infixOrder() &#123; //递归左子树终须遍历 if (this.left != null) &#123; this.left.infixOrder(); &#125; System.out.println(this); if (this.right != null) &#123; this.right.infixOrder(); &#125; &#125; // 后序 public void postOrder() &#123; //递归左子树终须遍历 if (this.left != null) &#123; this.left.postOrder(); &#125; if (this.right != null) &#123; this.right.postOrder(); &#125; System.out.println(this); &#125; //前序遍历查找 /** * @param no 查找no * @return 如果找到就返回该node，如果没有找到就返回null */ public HeroNode preOrderSearch(int no) &#123; System.out.println(\"进入前序遍历\"); //比较当前节点是不是 if (this.no == no) &#123; return this; &#125; //1.则判断当前节点的左子节点是否为空，如果不为空，则递归前序查找 //2.如果左递归前序查找，找到节点，则返回 HeroNode resNode = null; if (this.left != null) &#123; resNode = this.left.preOrderSearch(no); &#125; if (resNode != null) &#123; //说明我们左子树找到 return resNode; &#125; //1.左递归前序查找，找到结点，则返回，否继续判断 //2.当前的节点的右子节点是否为空，如果不空，则继续向右递归前序查找 if (this.right != null) &#123; resNode = this.right.preOrderSearch(no); &#125; return resNode; &#125; //中序遍历查找 public HeroNode infixOrderSearch(int no) &#123; //判断当前节点的左子节点是否为空，如果不为空，则递归中序查找 HeroNode resNode = null; if (this.left != null) &#123; resNode = this.left.infixOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; System.out.println(\"进入中序遍历\"); //如果找到，则返回，如果没有找到，就和当前节点比较，如果是则返回当前节点 if (this.no == no) &#123; return this; &#125; //否则继续进行有递归的中序查找 if (this.right != null) &#123; resNode = this.right.infixOrderSearch(no); &#125; return resNode; &#125; //后序遍历 public HeroNode postOrderSearch(int no) &#123; HeroNode resNode = null; if (this.left != null) &#123; resNode = this.left.postOrderSearch(no); &#125; if (resNode != null) &#123; //说明在左子树找到 return resNode; &#125; //如果右子树没有找到，则向右子树递归进行后序遍历查找 if (this.right != null) &#123; resNode = this.right.postOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; System.out.println(\"进入后序遍历\"); //如果左右子树都没有找到，就比较当前节点是不是 if (this.no == no) &#123; return this; &#125; return resNode; &#125;&#125; 1.3.4 遍历线索化二叉树线索化后，各个节点指向有变化，原来的遍历方式不能使用线型方式，无需使用递归，增加效率，与原来一样 代码：在class ThreadedBinaryTree中 12345678910111213141516171819202122232425//遍历线索化二叉树的方法 public void threadedList()&#123; //定义一个变量，存储当前遍历的节点，从root开始 HeroNode node =root; while(node != null)&#123; //循坏的找到leftType ==1 的结点，第一个找到就是8节点 //后面随着遍历而变化，因为当leftType==1时，说明该结点是按照线索化 //处理后的节点 while(node.getLeftType()==0)&#123; node = node.getLeft(); &#125; //打印当前这个节点 System.out.println(node); //如果当前节点的右指针指向的是后继节点，就一直输出 while(node.getRightType()==1)&#123; //获取到当前结点的后继节点 node = node.getRight(); System.out.println(node); &#125; //替换这个遍历的节点 node = node.getRight(); &#125; &#125; 1.3.5 课后作业前序和后序线索化二叉树前序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//遍历前序线索化二叉树的方法 public void threadedList1()&#123; //定义一个变量，存储当前遍历的节点，从root开始 HeroNode node =root; while(node != null)&#123; //打印当前这个节点 System.out.println(node); //循坏的找到leftType ==1 的结点，第一个找到就是8节点 //后面随着遍历而变化，因为当leftType==1时，说明该结点是按照线索化 //处理后的节点 while(node.getLeftType()==0)&#123; node = node.getLeft(); System.out.println(node); &#125; //如果当前节点的右指针指向的是后继节点，就一直输出 while(node.getRightType()==1)&#123; //获取到当前结点的后继节点 node = node.getRight(); System.out.println(node); &#125; //替换这个遍历的节点 node = node.getRight(); &#125; &#125; //编写对二叉树进行前序线索化的方法 /** * * @param node 就是当前需要线索化的结点 */ public void threadedNodes1(HeroNode node)&#123; //如果 node==null，不能线索化 if (node==null)&#123; return; &#125; // (一) 线索化当前结点[有点难度] //处理当前节点的前驱节点 //以8结点的left == null，8结点的leftType=1（相当于前驱节点，空） if (node.getLeft()==null)&#123; //让当前结点的左指针指向前驱节点(pre) node.setLeft(pre); //修改当前节点的左指针的类型，指向前驱节点 node.setLeftType(1);//8结点的leftType=1（相当于前驱节点，空） &#125; //处理后继节点 if (pre != null &amp;&amp; pre.getRight()==null)&#123;//如果本身有值就不能处理 //让前驱结点的右指针指向当前节点 pre.setRight(node); //修改前驱结点的右指针类型 pre.setRightType(1); &#125; //!!!每处理一个节点后，让当前节点是下一个节点的前驱节点 pre = node; // (二) 先线索化左子树 if(node.getLeftType()==0) &#123; threadedNodes1(node.getLeft()); &#125; // (三) 再线索化右子树 if(node.getRightType()==0) &#123; threadedNodes1(node.getRight()); &#125; &#125; 后序（较难，添加parent属性） 12345678910111213141516171819202122232425262728293031323334353637 public static void main(String[] args) &#123; HeroNode root &#x3D; new HeroNode(1, &quot;kang&quot;); HeroNode node2 &#x3D; new HeroNode(3, &quot;tom&quot;); HeroNode node3 &#x3D; new HeroNode(6, &quot;jack&quot;); HeroNode node4 &#x3D; new HeroNode(8, &quot;smith&quot;); HeroNode node5 &#x3D; new HeroNode(10, &quot;dim&quot;); HeroNode node6 &#x3D; new HeroNode(14, &quot;bb&quot;); root.setLeft(node2); root.setRight(node3); node2.setLeft(node4); node2.setRight(node5); node3.setLeft(node6); &#x2F;&#x2F;后序线索化 node2.setParent(root); node3.setParent(root); node4.setParent(node2); node5.setParent(node2); node6.setParent(node3); &#x2F;&#x2F;中序线索化 ThreadedBinaryTree threadedBinaryTree &#x3D; new ThreadedBinaryTree(); threadedBinaryTree.setRoot(root); threadedBinaryTree.threadedNodes2(); &#x2F;&#x2F;测试：以10号节点测试 HeroNode leftNode &#x3D; node5.getLeft(); HeroNode rightNode &#x3D; node5.getRight(); System.out.println(&quot;10号节点的前驱结点是&#x3D; &quot; + leftNode); System.out.println(&quot;10号结点的后继节点是&#x3D; &quot; + rightNode); &#x2F;&#x2F;当线索化二叉树后，bu能在使用原来的遍历方法&#x2F;&#x2F; threadedBinaryTree.infixOrder(); System.out.println(&quot;使用线索化的方式遍历 线索化二叉树&quot;); threadedBinaryTree.threadedList2(); &#125; class ThreadedBinaryTree 1234567891011121314151617181920212223242526272829303132333435363738394041//遍历后序线索化 方法1 public void threadedList22() &#123; HeroNode node = root; pre = null; //保存上一次访问的节点 while (node != null) &#123; //找最左边的节点 while (node.getLeftType() == 0 &amp;&amp; node.getLeft() != pre) //防止陷入死循环 &#123; node = node.getLeft(); &#125; //跳出循环的条件：node为最左边的节点 //访问节点的后继 while ( node.getRightType() == 1) // &#123; System.out.println(node); pre = node; //per记录已经访问过的节点 node = node.getRight(); &#125;//跳出循环的条件：node为空（即左单支情况） 节点有右子树，节点为根节点 //跳出循环，判断是否为根节点 if (node == root &amp;&amp; node.getRight() == pre) &#123; System.out.println(node); return; &#125; //不是根节点，访问当前节点的双亲节点 while ( node.getRight() == pre) // 注意 右单支情况 &#123; System.out.println(node); pre = node; node = node.getParent(); &#125; // 判断根节点是否有右子树 if ( node.getLeftType() == 0) &#123; node = node.getRight(); &#125; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//遍历后序线索化二叉树的方法2 public void threadedList2() &#123; //定义一个变量，存储当前遍历的节点，从root开始 HeroNode node = root; while (node.getLeftType() == 0 &amp;&amp; node != null) &#123; node = node.getLeft(); &#125; pre=null; while (node != null) &#123; //如果当前节点的右指针指向的是后继节点，就一直输出 if (node.getRightType() == 1) &#123; System.out.println(node); pre = node; node = node.getRight(); &#125; else &#123; if (node.getRight() == pre) &#123; System.out.println(node); if (node == root) &#123; return; &#125; pre = node; node = node.getParent(); &#125; else &#123; node = node.getRight(); while (node != null &amp;&amp; node.getLeftType() == 0) &#123; node = node.getLeft(); &#125; &#125; &#125; &#125; &#125; //编写对二叉树进行后序线索化的方法 /** * * @param node 就是当前需要线索化的结点 */ public void threadedNodes2(HeroNode node)&#123; //如果 node==null，不能线索化 if (node==null)&#123; return; &#125; // (一) 先线索化左子树 threadedNodes2(node.getLeft()); // (二) 再线索化右子树 threadedNodes2(node.getRight()); // (三) 线索化当前结点[有点难度] //处理当前节点的前驱节点 //以8结点的left == null，8结点的leftType=1（相当于前驱节点，空） if (node.getLeft()==null)&#123; //让当前结点的左指针指向前驱节点(pre) node.setLeft(pre); //修改当前节点的左指针的类型，指向前驱节点 node.setLeftType(1);//8结点的leftType=1（相当于前驱节点，空） &#125; //处理后继节点 if (pre != null &amp;&amp; pre.getRight()==null)&#123;//如果本身有值就不能处理 //让前驱结点的右指针指向当前节点 pre.setRight(node); //修改前驱结点的右指针类型 pre.setRightType(1); &#125; //!!!每处理一个节点后，让当前节点是下一个节点的前驱节点 pre = node; &#125; 总结： 前序线索化二叉树遍历相对最容易理解，实现起来也比较简单。由于前序遍历的顺序是：根左右，所以从根节点开始，沿着左子树进行处理，当子节点的left指针类型是线索时，说明到了最左子节点，然后处理子节点的right指针指向的节点，可能是右子树，也可能是后继节点，无论是哪种类型继续按照上面的方式（先沿着左子树处理，找到子树的最左子节点，然后处理right指针指向），以此类推，直到节点的right指针为空，说明是最后一个，遍历完成。 中序线索化二叉树的网上相关介绍最多。中序遍历的顺序是：左根右，因此第一个节点一定是最左子节点，先找到最左子节点，依次沿着right指针指向进行处理（无论是指向子节点还是指向后继节点），直到节点的right指针为空，说明是最后一个，遍历完成。 后序遍历线索化二叉树最为复杂，通用的二叉树数节点存储结构不能够满足后序线索化，因此我们扩展了节点的数据结构，增加了父节点的指针。后序的遍历顺序是：左右根，先找到最左子节点，沿着right后继指针处理，当right不是后继指针时，并且上一个处理节点是当前节点的右节点，则处理当前节点的右子树，遍历终止条件是：当前节点是root节点，并且上一个处理的节点是root的right节点。","categories":[{"name":"算法","slug":"算法","permalink":"https://lijiale96.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"树","slug":"树","permalink":"https://lijiale96.github.io/tags/%E6%A0%91/"}]},{"title":"每日一记1","slug":"每日一记1","date":"2020-03-23T12:00:22.000Z","updated":"2020-03-28T16:24:21.471Z","comments":true,"path":"2020/03/23/每日一记1/","link":"","permalink":"https://lijiale96.github.io/2020/03/23/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%AE%B01/","excerpt":"1、web编程基础1.JAVA应用服务器都有哪些？Tomcat 2.在什么情况下会使用assert?检查一个布尔型表达式，一个正确的程序必须保证boolean表达式的值为true，如果为false，程序不正确，系统给出警告或退出。assertion用于保证程序的最基本、最关键的正确性。 2.1分钟之内只能处理1000个请求，你怎么实现，手撕代码?计数器、滑动窗口、漏桶法、令牌桶a.Application 对所有用户访问的次数计数。同时定义一个计时器，单位为一分钟。如果Application 中的用户在单位时间内超出请求次数，就拒绝处理该请求。一分钟再刷新application的值为0.使用一个Map维护变量 1private Map&lt;String,List&lt;Long&gt;&gt; map &#x3D; new ConcurrentHashMap&lt;&gt;(); b.使用 aop 实现请求的限制，在需要限制的请求方法上加上 aop 逻辑。即可实现，思路如下：","text":"1、web编程基础1.JAVA应用服务器都有哪些？Tomcat 2.在什么情况下会使用assert?检查一个布尔型表达式，一个正确的程序必须保证boolean表达式的值为true，如果为false，程序不正确，系统给出警告或退出。assertion用于保证程序的最基本、最关键的正确性。 2.1分钟之内只能处理1000个请求，你怎么实现，手撕代码?计数器、滑动窗口、漏桶法、令牌桶a.Application 对所有用户访问的次数计数。同时定义一个计时器，单位为一分钟。如果Application 中的用户在单位时间内超出请求次数，就拒绝处理该请求。一分钟再刷新application的值为0.使用一个Map维护变量 1private Map&lt;String,List&lt;Long&gt;&gt; map &#x3D; new ConcurrentHashMap&lt;&gt;(); b.使用 aop 实现请求的限制，在需要限制的请求方法上加上 aop 逻辑。即可实现，思路如下： 3.如何在链接里不输入项目名称的情况下启动项目？可在Tomcat配置虚拟目录 4.说明一下JSP中的静态包含和动态包含的有哪些区别？静态包含是编译时包含动态包含是运行时包含 5.表达式语言（EL）的隐式对象以及该对象的作用EL的隐式对象包括：pageContext、initParam（访问上下文参数）、param（访问请求参数）、paramValues、header（访问请求头）、headerValues、cookie（访问cookie）、applicationScope（访问application作用域）、sessionScope（访问session作用域）、requestScope（访问request作用域）、pageScope（访问page作用域）。 6.谈一谈JSP有哪些内置对象？以及这些对象的作用分别是什么？JSP有9个内置对象： request：封装客户端的请求，其中包含来自GET或POST请求的参数； response：封装服务器对客户端的响应； pageContext：通过该对象可以获取其他对象； session：封装用户会话的对象； application：封装服务器运行环境的对象； out：输出服务器响应的输出流对象； config：Web应用的配置对象； page：JSP页面本身（相当于Java程序中的this）； exception：封装页面抛出异常的对象。如果用Servlet来生成网页中的动态内容无疑是非常繁琐的工作，另一方面，所有的文本和HTML标签都是硬编码，即使做出微小的修改，都需要进行重新编译。JSP解决了Servlet的这些问题，它是Servlet很好的补充，可以专门用作为用户呈现视图（View），而Servlet作为控制器（Controller）专门负责处理用户请求并转发或重定向到某个页面。基于Java的Web开发很多都同时使用了Servlet和JSP。JSP页面其实是一个Servlet，能够运行Servlet的服务器（Servlet容器）通常也是JSP容器，可以提供JSP页面的运行环境，Tomcat就是一个Servlet/JSP容器。第一次请求一个JSP页面时，Servlet/JSP容器首先将JSP页面转换成一个JSP页面的实现类，这是一个实现了JspPage接口或其子接口HttpJspPage的Java类。JspPage接口是Servlet的子接口，因此每个JSP页面都是一个Servlet。转换成功后，容器会编译Servlet类，之后容器加载和实例化Java字节码，并执行它通常对Servlet所做的生命周期操作。对同一个JSP页面的后续请求，容器会查看这个JSP页面是否被修改过，如果修改过就会重新转换并重新编译并执行。如果没有则执行内存中已经存在的Servlet实例。 7.说说weblogic中一个Domain的缺省目录结构?比如要将一个简单的helloWorld.jsp放入何目录下,然后在浏览器上就可打入主机Domain 目录服务器目录applications，将应用目录放在此目录下将可以作为应用访问，如果是Web应用，应用目录需要满足Web应用目录要求，jsp文件可以直接放在应用目录中，Javabean需要放在应用目录的WEB-INF目录的classes目录中，设置服务器的缺省应用将可以实现在浏览器上无需输入应用名。 8、说明一下jsp有哪些动作? 这些动作的作用又分别是什么JSP 共有以下6种基本动作 jsp:include：在页面被请求的时候引入一个文件。 jsp:useBean：寻找或者实例化一个JavaBean。jsp:setProperty：设置JavaBean的属性。 jsp:getProperty：输出某个JavaBean的属性。 jsp:forward：把请求转到一个新的页面。jsp:plugin：根据浏览器类型为Java插件生成OBJECT或EMBED标记。 9、Request对象的主要方法是什么setAttribute(String name,Object)：设置名字为name的request的参数值getAttribute(String name)：返回由name指定的属性值getAttributeNames()：返回request对象所有属性的名字集合，结果是一个枚举的实例getCookies()：返回客户端的所有Cookie对象，结果是一个Cookie数组getCharacterEncoding()：返回请求中的字符编码方式getContentLength()：返回请求的Body的长度getHeader(String name)：获得HTTP协议定义的文件头信息getHeaders(String name)：返回指定名字的request Header的所有值，结果是一个枚举的实例getHeaderNames()：返回所以request Header的名字，结果是一个枚举的实例getInputStream()：返回请求的输入流，用于获得请求中的数据getMethod()：获得客户端向服务器端传送数据的方法getParameter(String name)：获得客户端传送给服务器端的有name指定的参数值getParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例getParameterValues(String name)：获得有name指定的参数的所有值getProtocol()：获取客户端向服务器端传送数据所依据的协议名称getQueryString()：获得查询字符串getRequestURI()：获取发出请求字符串的客户端地址getRemoteAddr()：获取客户端的IP地址getRemoteHost()：获取客户端的名字getSession([Boolean create])：返回和请求相关SessiongetServerName()：获取服务器的名字getServletPath()：获取客户端所请求的脚本文件的路径getServerPort()：获取服务器的端口号removeAttribute(String name)：删除请求中的一个属性 10、四种会话跟踪技术分别是什么会话作用域ServletsJSP 页面描述page否是代表与一个页面相关的对象和属性。一个页面由一个编译好的 Java servlet 类（可以带有任何的 include 指令，但是没有 include 动作）表示。这既包括 servlet 又包括被编译成 servlet 的 JSP 页面request是是代表与 Web 客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件（由于forward 指令和 include 动作的关系）session是是代表与用于某个 Web 客户机的一个用户体验相关的对象和属性。一个 Web 会话可以也经常会跨越多个客户机请求application是是代表与整个 Web 应用程序相关的对象和属性。这实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域。 11、说明一下JSP和Servlet有哪些相同点和不同点？另外他们之间的联系又是什么呢？JSP 是Servlet技术的扩展，本质上是Servlet的简易方式，更强调应用的外表表达。JSP编译后是”类servlet”。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。JSP侧重于视图，Servlet主要用于控制逻辑 12、JSP的内置对象以及该对象的使用方法request表示HttpServletRequest对象。它包含了有关浏览器请求的信息，并且提供了几个用于获取cookie, header, 和session数据的有用的方法。response表示HttpServletResponse对象，并提供了几个用于设置送回浏览器的响应的方法（如cookies,头信息等）out对象是javax.jsp.JspWriter的一个实例，并提供了几个方法使你能用于向浏览器回送输出结果。pageContext表示一个javax.servlet.jsp.PageContext对象。它是用于方便存取各种范围的名字空间、servlet相关的对象的API，并且包装了通用的servlet相关功能的方法。session表示一个请求的javax.servlet.http.HttpSession对象。Session可以存贮用户的状态信息applicaton 表示一个javax.servle.ServletContext对象。这有助于查找有关servlet引擎和servlet环境的信息config表示一个javax.servlet.ServletConfig对象。该对象用于存取servlet实例的初始化参数。page表示从该页面产生的一个servlet实例 13、web.xml文件中可以配置哪些内容web.xml用于配置Web应用的相关信息，如：监听器（listener）、过滤器（filter）、 Servlet、相关参数、会话超时时间、安全验证方式、错误页面等，下面是一些开发中常见的配置： 14、你对Javaweb开发中的监听器的理解Java Web开发中的监听器（listener）就是application、session、request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件，如下所示：①ServletContextListener：对Servlet上下文的创建和销毁进行监听。②ServletContextAttributeListener：监听Servlet上下文属性的添加、删除和替换。③HttpSessionListener：对Session的创建和销毁进行监听。session的销毁有两种情况：1). session超时（可以在web.xml中通过/标签配置超时时间）；2). 通过调用session对象的invalidate()方法使session失效。④HttpSessionAttributeListener：对Session对象中属性的添加、删除和替换进行监听。⑤ServletRequestListener：对请求对象的初始化和销毁进行监听。⑥ServletRequestAttributeListener：对请求对象属性的添加、删除和替换进行监听。 15、请问过滤器有哪些作用？以及过滤器的用法又是什么呢Java Web开发中的过滤器（filter）是从Servlet 2.3规范开始增加的功能，并在Servlet 2.4规范中得到增强。对Web应用来说，过滤器是一个驻留在服务器端的Web组件，它可以截取客户端和服务器之间的请求与响应信息，并对这些信息进行过滤。当Web容器接受到一个对资源的请求时，它将判断是否有过滤器与这个资源相关联。如果有，那么容器将把请求交给过滤器进行处理。在过滤器中，你可以改变请求的内容，或者重新设置请求的报头信息，然后再将请求发送给目标资源。当目标资源对请求作出响应时候，容器同样会将响应先转发给过滤器，在过滤器中你可以对响应的内容进行转换，然后再将响应发送到客户端。 常见的过滤器用途主要包括：对用户请求进行统一认证、对用户的访问请求进行记录和审核、对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求或响应进行加解密处理、触发资源访问事件、对XML的输出应用XSLT等。和过滤器相关的接口主要有：Filter、FilterConfig和FilterChain。","categories":[{"name":"面试","slug":"面试","permalink":"https://lijiale96.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"Java web","slug":"Java-web","permalink":"https://lijiale96.github.io/tags/Java-web/"}]},{"title":"牛客综合8","slug":"牛客综合8","date":"2020-03-20T16:33:08.000Z","updated":"2020-03-20T16:35:35.655Z","comments":true,"path":"2020/03/21/牛客综合8/","link":"","permalink":"https://lijiale96.github.io/2020/03/21/%E7%89%9B%E5%AE%A2%E7%BB%BC%E5%90%888/","excerpt":"1、例如B:54132。5出来时里面必定是4321排好的。不可能出现升序132","text":"1、例如B:54132。5出来时里面必定是4321排好的。不可能出现升序132 2、数组是一种线性结构可以存储完全二叉树，完全二叉树按层序遍历，从上到下，从左到右的编号3、线性表长度的定义是它所包含的元素的个数。元素的类型决定了元素所占用存储空间的大小，但元素的个数不等价于元素的类型。4、线性链表中的各元素在存储空间中的位置不一定是连续的，且各元素的存储顺序也是任意的5、如果不是循环队列的话，那就应该是 r - f ， 但是如果是循环队列的话，那就算 ( n + r - f ) % n6、第一空是把a中的一个元素赋给max和min 此时i=0 即填a[i]第二空是判断max和a[j]的大小关系第三空是判断min和a[j]的大小关系7、某线性表中最常用的操作是在最后一个元素之后插入一个元素和删除第一个元素,则采用（仅有尾指针的单循环链表）存储方式最节省运算时间。8、s-&gt;left=p /把p赋值给s的前驱/ 前驱s-&gt;right=p-&gt;right /把p-&gt;right赋值给s的后继/ 后继p-&gt;right-&gt;left=s /把s赋值给p-&gt;right的前驱/ 前驱p-&gt;right=s /把s赋值给p的后驱/ 后驱9、ps为指针，ps+2为一个地址10、选项A：e2,e4,e3,e5,e1,e61、入栈e1，e2，出栈e2，然后e2入队列Q，此时栈S内容为e12、入栈e3，e4，分别出栈e4，e3，然后e4，e3依次入队列Q，此时栈内容为e13、入栈e5，分别出栈e5，e1，然后e5，e1依次入队列Q，此时栈内容为空4、入栈e6，出栈e6，然后e6入队列Q，此时栈内容为空 选项B：e2,e5,el,e3,e4,e61、入栈e1，e2，出栈e2，然后e2入队列Q，此时栈S内容为e12、入栈e3，e4，e5，分别出栈e5，e1，e3，e4，然后e5，e1，e3，e4依次入队列Q，此时队列为空3、入栈e6，出栈e6，然后e6入队列Q，此时栈内容为空 选项C：e5,e1,e6,e3,e2,e41、入栈e1，e2，e3，e4，e5，分别出栈e5，e1，然后e5，e1入队列Q，此时栈S内容为e2，e3，e42、入栈e6，出栈e6，然后e6入队列Q，此时栈内容为e2，e3，e43、栈内容为e2，e3，e4，此时想让e3出栈是不可能的，所以C不对 选项D：e4,el,e3,e5,e2,e61、入栈e1，e2，e3，e4，分别出栈e4，e1，e3，然后e4，e1，e3依次入队列Q，此时栈内容为e22、入栈e5，分别出栈e5，e2，然后e5，e2依次入队列Q，此时栈内容为空3、入栈e6，出栈e6，然后e6入队列Q，此时栈内容为空11、线性表是逻辑上的，顺序表是空间上的。而链表不具有顺序12、pa是执行1000次1000万连续地址的相加，pb是执行1000万次1000连续地址的相加，虽然相加次数是一样的，但是pa数组较长，跨的页较多，所以会产生较多次的缺页，导致执行速度较pb慢","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://lijiale96.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"https://lijiale96.github.io/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"算法笔记5","slug":"算法笔记5","date":"2020-03-20T15:33:36.000Z","updated":"2020-03-24T15:53:46.998Z","comments":true,"path":"2020/03/20/算法笔记5/","link":"","permalink":"https://lijiale96.github.io/2020/03/20/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B05/","excerpt":"1、排序1.1 介绍排序是将一组数据，依指定的顺序进行排列的过程 1.2 排序的分类 内部排序：所有数据加载到内部存储器（内存）中进行排序 插入排序 直接插入 希尔排序 选择排序 简单选择排序 堆排序 交换排序 冒泡排序 快速排序 归并排序 基数排序 外部排序：数据量过大，需要借助外部存储(文件等）进行排序","text":"1、排序1.1 介绍排序是将一组数据，依指定的顺序进行排列的过程 1.2 排序的分类 内部排序：所有数据加载到内部存储器（内存）中进行排序 插入排序 直接插入 希尔排序 选择排序 简单选择排序 堆排序 交换排序 冒泡排序 快速排序 归并排序 基数排序 外部排序：数据量过大，需要借助外部存储(文件等）进行排序 算法的时间复杂度1）事后统计法问题1: 先运行问题2：依赖于计算机的硬件、软件，要在同一台计算机的相同状态下运行 2）事前估算法通过分析某个算法的时间复杂度来判断哪个算法更优 1.3 算法的时间复杂度基本介绍时间频度：一个算法花费的时间与算法中的语句执行次数成正比例，哪个算法中语句执行次数多，它花费的时间就多。一个算法的语句执行次数称为语句频度或时间频度。记为T（n） 忽略常数项，多少次方是关键 1.3.1 时间复杂度一般情况下，算法的基本操作语句的重复执行次数是问题规模n的某个函数f(n)是T(n)的同数量级函数，记作 T(n)=O(f(n)),O(f(n)) 为算法的渐进时间复杂度 常见时间复杂度1）常数阶O（1）2）对数阶O（log2 n）3）线性阶O（n）4）线性对数阶O（nlog2 n）5）平方阶O（n ^2)6）立方阶O（n ^3)7）k次方阶O（n ^k)8）指数阶O（2 ^n) 由小到大：O（1）&lt;（log2 n）&lt;O（n）&lt;O（nlog2 n)&lt;O（n ^2)&lt;O（n ^3)&lt;O（n ^k)&lt;O（2 ^n) 常数阶O（1）没有循坏，小号的时间不随着某个变量的增长而增长 对数阶O（log2 n）while循坏 线性阶O（n）for循坏 线性对数阶O（nlog2 n）for+while循坏 平方阶O（n ^2)双层for循坏 平均时间复杂度和最坏时间复杂度1）平均时间复杂度：均已等概率出现的情况 2）最坏时间复杂度：界限，不会比它时间更长 3）平均时间复杂度和最坏时间复杂度算法一致，和算法有关 排序法 平均时间 最差情形 稳定度 额外空间 备注 冒泡 O(n^2) O(n^2) 稳定 O（1) n小时较好 交换 O(n^2) O(n^2) 不稳定 O（1) n小时较好 选择 O(n^2) O(n^2) 不稳定 O（1) n小时较好 插入 O(n^2) O(n^2) 稳定 O（1) 大部分已排序时较好 基数 O(logR B) O(logR B) 稳定 O（n) B是真数，R是基数 Shell O(nlogn) O(n^s) 不稳定 O（1) s是所选分组 快速 O(nlogn) O（n^2） 不稳定 O(nlogn) n大时较好 归并 O(nlogn) O(nlogn) 稳定 O（1) n大时较好 堆 O(nlogn) O(nlogn) 不稳定 O（1) n大时较好 1.4 算法空间复杂度1）所耗费的存储空间2）空间复杂度 是一个算法在运行过程中临时占用的存储空间大小的量度3）执行速度 空间换时间 1.5 冒泡排序1.5.1 基本介绍冒泡排序，依次比较相邻元素的值，若发现逆序则交换，较大的值从前往后移 1.5.2 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.atguigu.sort;import java.text.SimpleDateFormat;import java.util.Arrays;import java.util.Date;public class BubbleSort &#123; public static void main(String[] args) &#123; //int arr[] = &#123;3,9,-1,10,20&#125;;// int arr[] = &#123;1,2,3,4,5,6,7&#125;;// System.out.println(\"排序前\");// System.out.println(Arrays.toString(arr)); //为了容易理解，我们把冒泡排序的演变过程，给大家展示 //测试一下冒泡排序的速度O（n^2),给80000个数据，测试 //创建要给80000个随机的数组 int[] arr = new int[80000]; for (int i = 0; i &lt; 80000; i++) &#123; arr[i] = (int) (Math.random() * 8000000); //生成一个【0,8000000）数 &#125; // System.out.println(Arrays.toString(arr)); Date data1 = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyy-MM-dd HH:mm:ss\"); String date1Str = simpleDateFormat.format(data1); System.out.println(\"排序前的时间是=\" + date1Str); //测试冒泡排序 bubbleSort(arr); Date data2 = new Date(); String date2Str = simpleDateFormat.format(data1); System.out.println(\"排序后的时间是=\" + date2Str); &#125; //将前面的冒泡排序算法，封装成一个方法 public static void bubbleSort(int[] arr)&#123; int temp = 0;//临时变量 boolean flag =false;//标识变量；表示是否进行过交换 for (int i=0;i&lt;arr.length-1;i++) &#123; for (int j = 0; j &lt; arr.length - 1-i; j++) &#123; //如果前面的数比后面的数大，则交换 if (arr[j] &gt; arr[j + 1]) &#123; flag = true; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125;// System.out.println(\"第\"+(i+1)+\"趟排序后的数组\");// System.out.println(Arrays.toString(arr));// if (!flag)&#123; //在一趟排序中,一次交换都没有发生过 break; &#125;else&#123; flag=false;//重置flag，进行下次判断 &#125; &#125; &#125;&#125; 1.6 选择排序内部排序 按指定的规则选出某一元素，再依规定交换位置后达到排序的目的 说明：1、选择排序一共有数组大小-1轮排序2、每一轮排序，又是一共循坏，循坏的规则（代码）2.1 先假定当前这个数是最小数2.2 然后和后面的每个数进行比较，如果发现有比当前更小的数，就重新确定最小数，并得到下标2.3 当遍历到数组的最后时，就得到本轮最小数和下标2.4 交换[代码] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.atguigu.sort;import java.text.SimpleDateFormat;import java.util.Arrays;import java.util.Date;public class SelectSort &#123; public static void main(String[] args) &#123; //int [] arr=&#123;101,34,119,1,123,2132143,312&#125;; //创建要给800000个随机的数组 速度2-3秒，比冒泡排序快 int[] arr =new int[800000]; for (int i=0;i&lt;800000;i++)&#123; arr[i] =(int)(Math.random()*8000000);//生成一个【0,8000000）数 &#125; System.out.println(\"排序前\"); Date data1 = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyy-MM-dd HH:mm:ss\"); String date1Str = simpleDateFormat.format(data1); System.out.println(\"排序前的时间是=\" + date1Str); selectSort(arr); Date data2 = new Date(); String date2Str = simpleDateFormat.format(data1); System.out.println(\"排序后的时间是=\" + date2Str); &#125; //选择排序 public static void selectSort(int[] arr)&#123; //在推导的过程在，发现规律，用for循坏来解决 //在选择排序时间复杂度O（n^2) for (int i=0;i&lt;arr.length-1;i++) &#123; int minIndex = i; int min = arr[i]; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (min &gt; arr[j]) &#123; //说明假定的最小值，并不是最小 min = arr[j];//重置min minIndex = j;//重置minIndex &#125; &#125; //将最小值，放在arr[0],把arr[0],即交换 if (minIndex != i) &#123; arr[minIndex] = arr[i]; arr[i] = min; &#125; &#125; //使用逐步推导的方式来，讲解选择排序 //第一轮 //原始的数组： 101，34,119,1 //第一轮排序： 1,34,119,101 //算法 先简单————》做复杂，就是可以把一个复杂的算法，拆分成简单的问题-》逐步解决 &#125;&#125; 1.7 插入排序1.7.1 介绍内部排序 对于欲排序的元素以插入的方式寻找元素的适当位置，已达到排序的目的 1.7.2 思想把n个待排序的元素看成为一个有序表和一个无需表，开始时有序表只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置， 1.7.3 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package com.atguigu.sort;import java.text.SimpleDateFormat;import java.util.Arrays;import java.util.Date;public class InsertSort &#123; public static void main(String[] args) &#123; //int[] arr=&#123;101,34,119,1,-1,89&#125;; //创建要给800000个随机的数组 int[] arr =new int[80000]; for (int i=0;i&lt;80000;i++)&#123; arr[i] =(int)(Math.random()*8000000);//生成一个【0,8000000）数 &#125; System.out.println(\"排序前\"); Date data1 =new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); String data1Str = simpleDateFormat.format(data1); System.out.println(\"插入排序前的时间是=\"+data1Str); insertSort(arr);//调用插入排序 Date data2 = new Date(); // SimpleDateFormat simpleDateFormat1=new SimpleDateFormat(\"yyyy-MM-dd HH:\"); String data2Str = simpleDateFormat.format(data2); System.out.println(\"插入排序后的时间是=\"+data2Str);// System.out.println(Arrays.toString(arr)); &#125; //插入排序 public static void insertSort(int[] arr)&#123; int insertVal = 0; int insertIndex = 0; //使用for循坏来把代码简化 for (int i =1; i&lt;arr.length;i++) &#123; //定义待插入的数 insertVal = arr[i]; insertIndex = i - 1; //给insertVal 找到插入的位置 //1.insertIndex&gt;=0 保证在给insertVal 找插入位置，不越界 //2.insertVal&lt;arr[insertIndex] 待插入的数，还没有找到插入位置 //3. 就需要将 arr[insertIndex] 后移 while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123; arr[insertIndex + 1] = arr[insertIndex];//arr[insertIndex] insertIndex--; &#125; //当退出while循坏时，说明插入的位置找到，insertIndex+1 //举例：debug //这里我们判断是否需要赋值 if (insertIndex+1!=i)&#123; arr[insertIndex + 1] = insertVal; &#125;// System.out.println(\"第\"+i+\"轮插入\");// System.out.println(Arrays.toString(arr)); &#125;// //使用逐步推导// //第一轮 &#123;101,34,119,1&#125;;=》&#123;34,101,119,1&#125;//// //&#123;101,34,119,1&#125;=&gt;&#123;101,101,119,1&#125;;// //定义待插入的数// int insertVal = arr[1];// int insertIndex=1-1;//// //给insertVal 找到插入的位置// //1.insertIndex&gt;=0 保证在给insertVal 找插入位置，不越界// //2.insertVal&lt;arr[insertIndex] 待插入的数，还没有找到插入位置// //3. 就需要将 arr[insertIndex] 后移// while(insertIndex &gt;=0 &amp;&amp; insertVal&lt;arr[insertIndex])&#123;// arr[insertIndex+1] =arr[insertIndex];//arr[insertIndex]// insertIndex--;// &#125;// //当退出while循坏时，说明插入的位置找到，insertIndex+1// //举例：debug// arr[insertIndex+1]=insertVal;//// System.out.println(\"第一轮插入\");// System.out.println(Arrays.toString(arr));//// //第二轮// insertVal = arr[2];// insertIndex =2-1;// while(insertIndex&gt;=0&amp;&amp;insertVal&lt;arr[insertIndex])&#123;// arr[insertIndex+1]=arr[insertIndex];// insertIndex--;// &#125;// arr[insertIndex+1]=insertVal;// System.out.println(\"第二轮插入\");// System.out.println(Arrays.toString(arr));//// //第三轮// insertVal = arr[3];// insertIndex =3-1;// while(insertIndex&gt;=0&amp;&amp;insertVal&lt;arr[insertIndex])&#123;// arr[insertIndex+1]=arr[insertIndex];// insertIndex--;// &#125;// arr[insertIndex+1]=insertVal;// System.out.println(\"第三轮插入\");// System.out.println(Arrays.toString(arr)); &#125;&#125; 1.8 希尔排序1.8.1 介绍缩小增量排序 1.8.2 基本思想1.8.3 代码实现1) 逆序时，则交换2）移动法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package com.atguigu.sort;import java.text.SimpleDateFormat;import java.util.Arrays;import java.util.Date;public class ShellSort &#123; public static void main(String[] args) &#123; //int[] arr=&#123;8,9,1,7,2,3,5,4,6,0&#125;; //创建要给800000个随机的数组 int[] arr =new int[80000]; for (int i=0;i&lt;80000;i++)&#123; arr[i] =(int)(Math.random()*8000000);//生成一个【0,8000000）数 &#125; System.out.println(\"排序前\"); Date data1 =new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); String data1Str = simpleDateFormat.format(data1); System.out.println(\"希尔排序前的时间是=\"+data1Str);// shellSort(arr);//交换式 shellSort2(arr);//移位式 Date data2 = new Date(); // SimpleDateFormat simpleDateFormat1=new SimpleDateFormat(\"yyyy-MM-dd HH:\"); String data2Str = simpleDateFormat.format(data2); System.out.println(\"希尔排序后的时间是=\"+data2Str); &#125; //逐步推导 //希尔排序时，对有序序列在插入时采用交换法 public static void shellSort(int[] arr)&#123; int temp=0; int count=0; //根据前面的逐步分析，使用循坏处理 for (int gap=arr.length/2;gap&gt;0;gap/=2)&#123; for (int i=5;i&lt;arr.length;i++)&#123; //遍历各组中所有的元素（共5组,每组有2个元素），步长是gap for (int j=i-gap;j&gt;=0;j-=gap)&#123; //如果当前元素大于加上步长后的那个元素，说明交换 if (arr[j]&gt;arr[j+gap])&#123; temp =arr[j]; arr[j]=arr[j+gap]; arr[j+gap]=temp; &#125; &#125; &#125;// System.out.println(\"希尔排序第\"+(++count)+\"轮=\"+Arrays.toString(arr)); &#125;// //希尔排序第一轮排序// //因为第一轮排序，是将10个数据分成了5组// for (int i=5;i&lt;arr.length;i++)&#123;// //遍历各组中所有的元素（共5组,每组有2个元素），步长是5// for (int j=i-5;j&gt;=0;j-=5)&#123;// //如果当前元素大于加上步长后的那个元素，说明交换// if (arr[j]&gt;arr[j+5])&#123;// int temp =arr[j];// arr[j]=arr[j+5];// arr[j+5]=temp;// &#125;// &#125;// &#125;// System.out.println(\"希尔排序1轮后=\"+ Arrays.toString(arr));////// //希尔排序第二轮排序// //因为第二轮排序，是将10个数据分成了5/2=2组// for (int i=2;i&lt;arr.length;i++)&#123;// //遍历各组中所有的元素（共5组,每组有2个元素），步长是5// for (int j=i-2;j&gt;=0;j-=2)&#123;// //如果当前元素大于加上步长后的那个元素，说明交换// if (arr[j]&gt;arr[j+2])&#123;// int temp =arr[j];// arr[j]=arr[j+2];// arr[j+2]=temp;// &#125;// &#125;// &#125;// System.out.println(\"希尔排序2轮后=\"+ Arrays.toString(arr));////// //希尔排序第三轮排序// //因为第二轮排序，是将10个数据分成了2/2=1组// for (int i=1;i&lt;arr.length;i++)&#123;// //遍历各组中所有的元素（共5组,每组有2个元素），步长是5// for (int j=i-1;j&gt;=0;j-=1)&#123;// //如果当前元素大于加上步长后的那个元素，说明交换// if (arr[j]&gt;arr[j+1])&#123;// int temp =arr[j];// arr[j]=arr[j+1];// arr[j+1]=temp;// &#125;// &#125;// &#125;// System.out.println(\"希尔排序2轮后=\"+ Arrays.toString(arr));// &#125; //对交换式的希尔排序进行优化-》移位法 public static void shellSort2(int[] arr)&#123; //增量gap，并逐步缩小增量 for (int gap=arr.length/2;gap&gt;0;gap/=2)&#123; //从第gap个元素，逐个对其所在的组进行直接插入排序 for (int i =gap;i&lt;arr.length;i++)&#123; int j=i; int temp=arr[j]; if (arr[j]&lt;arr[j-gap])&#123; while(j-gap&gt;=0&amp;&amp;temp&lt;arr[j-gap])&#123; //移动 arr[j] =arr[j-gap]; j-=gap; &#125; //档推出while后，就给temp找到插入的位置 arr[j]=temp; &#125; &#125; &#125; &#125;&#125; 1.9 快速排序1.9.1 介绍快排是对冒泡排序的一种改进；通过一排排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快排，整个排序过程是可以递归进行。 1.9.2 思路见笔记本 1.9.3 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.atguigu.sort;import java.text.SimpleDateFormat;import java.util.Arrays;import java.util.Date;public class QuickSort &#123; public static void main(String[] args) &#123;// int[] arr =&#123;-9,78,0,23,-567,70&#125;; int[] arr =new int[80000]; for (int i=0;i&lt;80000;i++)&#123; arr[i] =(int)(Math.random()*8000000);//生成一个【0,8000000）数 &#125; System.out.println(\"排序前\"); Date data1 =new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); String data1Str = simpleDateFormat.format(data1); System.out.println(\"快速排序前的时间是=\"+data1Str); quickSort(arr,0,arr.length-1); Date data2 = new Date(); // SimpleDateFormat simpleDateFormat1=new SimpleDateFormat(\"yyyy-MM-dd HH:\"); String data2Str = simpleDateFormat.format(data2); System.out.println(\"快速排序后的时间是=\"+data2Str);// System.out.println(\"arr=\"+ Arrays.toString(arr)); &#125; // public static void quickSort(int[] arr,int left,int right)&#123; int l=left;//左下标 int r=right;//右下标 //pivot 中轴 int pivot = arr[(left+right)/2]; int temp=0; //临时变量，作为交换时使用 //while循坏的目的是让比pivot 值小放到左边 //比pivot 值放到右边 while(l&lt;r)&#123; //在pivot的左边一直找，找到大于等于pivot值，才退出 while(arr[l]&lt;pivot)&#123; l+=1; &#125; //在pivot的右边一直找，找到小于等于pivot值，才退出 while(arr[r]&gt;pivot)&#123; r-=1; &#125; //如果l &gt;= r 说明pivot 的左右两边的值，已经按照左边全部是小于等于pivot值，右边全部是大于等于pivot值 if (l&gt;=r)&#123; break; &#125; //交换 temp = arr[l]; arr[l]=arr[r]; arr[r]=temp; //如果交换完后，发现这个arr[l] == pivot值相等 -- 前移 if(arr[l] == pivot)&#123; r-=l; &#125; //如果交换完后，发现这个arr[r] == pivot值相等 ++ 后移 if(arr[r] == pivot)&#123; l+=l; &#125; &#125; //如果 l==r,必须l++，r--,否则为出现栈溢出 if (l == r) &#123; l+=1; r-=1; &#125; //向左递归 if (left &lt; r)&#123; quickSort(arr,left,r); &#125; //向右递归 if (right&gt;l)&#123; quickSort(arr,l,right); &#125; &#125;&#125; 1.10 归并排序1.10.1 介绍分治 分成一些小的问题然后递归求解 1.10.2 思路1.10.3 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.atguigu.sort;import java.text.SimpleDateFormat;import java.util.Arrays;import java.util.Date;public class MergeSort &#123; public static void main(String[] args) &#123;// int arr[] =&#123;8,4,5,7,1,3,6,2&#125;;//8-&gt;merge 7 int[] arr =new int[80000]; for (int i=0;i&lt;80000;i++)&#123; arr[i] =(int)(Math.random()*8000000);//生成一个【0,8000000）数 &#125; System.out.println(\"排序前\"); Date data1 =new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); String data1Str = simpleDateFormat.format(data1); System.out.println(\"归并排序前的时间是=\"+data1Str); int temp[] = new int[arr.length]; mergeSort(arr,0,arr.length-1,temp); Date data2 = new Date(); // SimpleDateFormat simpleDateFormat1=new SimpleDateFormat(\"yyyy-MM-dd HH:\"); String data2Str = simpleDateFormat.format(data2); System.out.println(\"归并排序后的时间是=\"+data2Str); &#125; //分＋合 方法 public static void mergeSort(int[] arr,int left,int right,int[] temp)&#123; if (left&lt;right)&#123; int mid = (left+right)/2; //中间索引 //向左递归进行分解 mergeSort(arr,left,mid,temp); //向右递归进行分解 mergeSort(arr,mid+1,right,temp); //合并 merge(arr,left,mid,right,temp); &#125; &#125; //合并的方法 /** * * @param arr 排序的原始数据 * @param left 左边有序序列的初始索引 * @param mid * @param right * @param temp */ public static void merge(int[] arr,int left,int mid,int right,int[] temp)&#123; int i = left;//初始化i,左边有序序列的初始索引 int j = mid+1;//初始化j， 右边有序序列的初始索引 int t=0;//指向temp数组的当前索引 //（一） //先把左右两边（有序）的数据按照规则填充到temp数组 //直到左右两边的有序序列，有一边处理完毕 while(i&lt;=mid&amp;&amp;j&lt;=right)&#123;//继续 //如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素 //即将左边的当前元素，填充拷贝到temp数组 //然后 t++，i++ if (arr[i]&lt;=arr[j])&#123; temp[t]=arr[i]; t+=1; i+=1; &#125;else&#123;//反之，将右边有序序列的当前元素，填充到temp数组 temp[t]=arr[j]; t+=1; j+=1; &#125; &#125; //（二） //把有剩余数据的一边的数据依次全部填充到temp while(i&lt;=mid)&#123; //左边的有序序列还有剩余的元素，就全部填充到temp temp[t]=arr[i]; t+=1; i+=1; &#125; while(j&lt;=right)&#123; //右边的有序序列还有剩余的元素，就全部填充到temp temp[t]=arr[j]; t+=1; j+=1; &#125; //(三） //将temp数组的元素拷贝到arr //注意，并不是每次都拷贝所有 t=0; int tempLeft =left;// //第一次合并 tempLeft=0，right = 1 //tempLeft=2，right = 3//tL=0，ri=3 //最后一次 tempLeft = 0 right=7// System.out.println(\"tempLeft=\"+tempLeft+\"right=\"+right); while(tempLeft&lt;=right)&#123; arr[tempLeft]=temp[t]; t+=1; tempLeft+=1; &#125; &#125;&#125; 1.11 基数排序1.11.1 介绍1） 分配式排序，桶子法2） 稳定性的排序，效率高3）桶排序的扩展4）将整数按位数切割成不同的数字，按每个数字进行比较 注：1）速度快，占用内存大，容易造成OutOfMemoryError，2）稳定：原序列在前面的数在前面，排序后，前面的数还在前面3）若含有负数，先求绝对值，再反转 1.11.2 思想较短的数补零 1.11.3 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158package com.atguigu.sort;import java.text.SimpleDateFormat;import java.util.Arrays;import java.util.Date;public class RadixSort &#123; public static void main(String[] args) &#123;// int arr[] =&#123;53,3,542,748,14,214&#125;; //80000000*11*4/1024/1024/1024 =3.3G int[] arr =new int[80000]; for (int i=0;i&lt;80000;i++)&#123; arr[i] =(int)(Math.random()*8000000);//生成一个【0,8000000）数 &#125; System.out.println(\"排序前\"); Date data1 =new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); String data1Str = simpleDateFormat.format(data1); System.out.println(\"基数排序前的时间是=\"+data1Str); int temp[] = new int[arr.length]; radixSort(arr); Date data2 = new Date(); // SimpleDateFormat simpleDateFormat1=new SimpleDateFormat(\"yyyy-MM-dd HH:\"); String data2Str = simpleDateFormat.format(data2); System.out.println(\"基数排序后的时间是=\"+data2Str); &#125; public static void radixSort(int[] arr)&#123; //根据推导 //1. 得到数组中最大的数的位数 int max =arr[0]; //假设第一数就是最大数 for (int i=1;i&lt;arr.length;i++)&#123; if (arr[i]&gt;max)&#123; max =arr[i]; &#125; &#125; //得到最大数的几位数 int maxLength =(max+\"\").length(); //定义一个二维数组，表示10个通，每个桶就是一个一维数组 //说明 //1.二维数组包含10个一维数组 //2.为了防止在放入数的时候，数据溢出，则每个一维数组（桶），大小定为arr，length //3.基数排序是使用空间换时间的经典算法 int [][] bucket = new int[10][arr.length]; //为了记录每个桶中，实际存放了多少数据，我们定义一个一维数组来记录各个桶的每次放入的数据个数 //bucketElementCounts[0],记录的就是bucket【0】桶的放入数据个数 int[] bucketElementCounts = new int[10]; //这里我们使用循坏将代码处理 for (int i=0,n=1;i&lt;maxLength;i++,n*=10) &#123; //（针对每个元素的对应位进行排序处理）第一次个位，第二次十位，第三次是百位 for (int j = 0; j &lt; arr.length; j++) &#123; //取出每个元素的对应位的值 int digitofElement = arr[j] /n % 10; //放入到对应的桶中 bucket[digitofElement][bucketElementCounts[digitofElement]] = arr[j]; bucketElementCounts[digitofElement]++; &#125; //按照这个桶的顺序（一维数组的下标依次取出数据，放入原来数组） int index = 0; //遍历每一桶，并将桶中数据，放入到原数组 for (int k = 0; k &lt; bucketElementCounts.length; k++) &#123; //如果桶中，有数据，我们才放到原数组 if (bucketElementCounts[k] != 0) &#123; //循坏该桶即第k个桶（即第k个一维数组），放入 for (int l = 0; l &lt; bucketElementCounts[k]; l++) &#123; //取出元素放入到arr arr[index++] = bucket[k][l]; &#125; &#125; //第i+1轮处理后，需要将每个bucketElementCounts[k]=0！！！ bucketElementCounts[k] = 0; &#125;// System.out.println(\"第\"+(i+1)+\"轮，对个位数的排序处理 arr =\" + Arrays.toString(arr)); &#125;// //第一轮（针对每个元素的个位进行排序处理）// for (int j=0;j&lt;arr.length;j++)&#123;// //取出每个元素的个位的值// int digitofElement= arr[j]%10;// //放入到对应的桶中// bucket[digitofElement][bucketElementCounts[digitofElement]] =arr[j];// bucketElementCounts[digitofElement]++;// &#125;// //按照这个桶的顺序（一维数组的下标依次取出数据，放入原来数组）// int index =0;// //遍历每一桶，并将桶中数据，放入到原数组// for (int k=0;k&lt;bucketElementCounts.length;k++)&#123;// //如果桶中，有数据，我们才放到原数组// if (bucketElementCounts[k]!=0)&#123;// //循坏该桶即第k个桶（即第k个一维数组），放入// for (int l=0;l&lt;bucketElementCounts[k];l++)&#123;// //取出元素放入到arr// arr[index++]=bucket[k][l];// &#125;// &#125;// //第一轮处理后，需要将每个bucketElementCounts[k]=0！！！// bucketElementCounts[k]=0;// &#125;// System.out.println(\"第一轮，对个位数的排序处理 arr =\"+ Arrays.toString(arr));////// //第二轮（针对每个元素的十位进行排序处理）// for (int j=0;j&lt;arr.length;j++)&#123;// //取出每个元素的十位的值// int digitofElement= arr[j]/10 %10;// //放入到对应的桶中// bucket[digitofElement][bucketElementCounts[digitofElement]] =arr[j];// bucketElementCounts[digitofElement]++;// &#125;// //按照这个桶的顺序（一维数组的下标依次取出数据，放入原来数组）// index =0;// //遍历每一桶，并将桶中数据，放入到原数组// for (int k=0;k&lt;bucketElementCounts.length;k++)&#123;// //如果桶中，有数据，我们才放到原数组// if (bucketElementCounts[k]!=0)&#123;// //循坏该桶即第k个桶（即第k个一维数组），放入// for (int l=0;l&lt;bucketElementCounts[k];l++)&#123;// //取出元素放入到arr// arr[index++]=bucket[k][l];// &#125;// &#125;// //第二轮处理后，需要将每个bucketElementCounts[k]=0！！！// bucketElementCounts[k]=0;// &#125;// System.out.println(\"第二轮，对十位数的排序处理 arr =\"+ Arrays.toString(arr));//// //第三轮（针对每个元素的百位进行排序处理）// for (int j=0;j&lt;arr.length;j++)&#123;// //取出每个元素的百位的值// int digitofElement= arr[j]/100 %10;// //放入到对应的桶中// bucket[digitofElement][bucketElementCounts[digitofElement]] =arr[j];// bucketElementCounts[digitofElement]++;// &#125;// //按照这个桶的顺序（一维数组的下标依次取出数据，放入原来数组）// index =0;// //遍历每一桶，并将桶中数据，放入到原数组// for (int k=0;k&lt;bucketElementCounts.length;k++)&#123;// //如果桶中，有数据，我们才放到原数组// if (bucketElementCounts[k]!=0)&#123;// //循坏该桶即第k个桶（即第k个一维数组），放入// for (int l=0;l&lt;bucketElementCounts[k];l++)&#123;// //取出元素放入到arr// arr[index++]=bucket[k][l];// &#125;// &#125;// //第三轮处理后，需要将每个bucketElementCounts[k]=0！！！// bucketElementCounts[k]=0;// &#125;// System.out.println(\"第三轮，对百位数的排序处理 arr =\"+ Arrays.toString(arr)); &#125;&#125; 1.12 常用排序算法的总结和对比 排序法 平均时间 最好情况 最差情形 稳定度 空间复杂度 冒泡 O(n^2) O(n) O(n^2) 稳定 O（1) 选择 O(n^2) O(n^2) O(n^2) 不稳定 O（1) 插入 O(n^2) O(n) O(n^2) 稳定 O（1) Shell O(nlogn) O(nlog^2 n) O(nlog^2 n) 不稳定 O（1) 快速 O(nlogn) O(nlogn) O（n^2） 不稳定 O(nlogn) 归并 O(nlogn) O(nlogn) O(nlogn) 稳定 O（1) 堆 O(nlogn) O(nlogn) O(nlogn) 不稳定 O（1) 基数 O(n*k) O(n*k) O(n*k) 稳定 O（n+k) 相关术语： 1）稳定：如果a原本在b前面，而a=b，排序之后，a仍然在b的前面 2）不稳定 3）内排序：在内存中完成 4）外排序：数据放在磁盘，通过磁盘和内存的数据传输 5）时间复杂度：一个算法执行所耗费的时间 6）空间复杂度：完成一个程序所需内存的大小 7）n：数据规模 8）k：”桶”的个数 9）In-place:不占用额外内存 10）Out-place：占用额外内存","categories":[{"name":"算法","slug":"算法","permalink":"https://lijiale96.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://lijiale96.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"算法笔记4","slug":"算法笔记4","date":"2020-03-18T09:33:36.000Z","updated":"2020-03-20T15:45:09.832Z","comments":true,"path":"2020/03/18/算法笔记4/","link":"","permalink":"https://lijiale96.github.io/2020/03/18/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B04/","excerpt":"1、递归1.1 递归的场景迷宫问题（回溯），递归（Recursion） 1.2 递归的概念递归就是方法自己调用自己，每次调用传入不同的变量。递归有助于编程者解决复杂的问题，同时代码变得简洁","text":"1、递归1.1 递归的场景迷宫问题（回溯），递归（Recursion） 1.2 递归的概念递归就是方法自己调用自己，每次调用传入不同的变量。递归有助于编程者解决复杂的问题，同时代码变得简洁 1.3 递归调用机制1）打印问题2） 阶乘问题3）图解方式递归调用规则1.当程序执行到一个方法时，就会开辟一个独立的空间（栈）2.每个空间的数据（局部变量），是独立的。4）代码 12345678910111213141516171819202122232425262728package com.atguigu.recursion;public class RecursionTest &#123; public static void main(String[] args) &#123; //通过打印问题，回顾递归调用机制 // test(4); int res = factorial(3); System.out.println(\"res=\"+res); &#125; //打印问题 public static void test(int n)&#123; if (n&gt;2)&#123; test(n-1); &#125; System.out.println(\"n=\"+n); &#125; //阶乘问题public static int factorial(int n)&#123; if (n==1)&#123; return 1; &#125;else&#123; return factorial(n-1)*n;//factorial(2-1)*2 &#125; &#125;&#125; 1.4 递归能解决什么样的问题1）八皇后问题，汉诺塔，阶乘问题，迷宫问题，球和篮子问题2）快排，归并排序，二分查找，分治算法3）用栈解决的问题–代码简洁 1.5 递归遵守的重要规则1）执行一个方法，创建一个新的受保护的独立空间（栈空间）2）方法的局部变量是独立的，不会相互影响，比如n变量3）如果方法中使用的是引用类型变量（比如数组），就会共享该引用类型的数据4）递归必须向退出递归的条件逼近，否则就是无限递归，出现StackOverflowError，死龟5）当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。 1.6 递归-迷宫问题1.6.1迷宫1.6.2代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113package com.atguigu.recursion;public class MiGong &#123; public static void main(String[] args) &#123; //先创建一个二维数组，模拟迷宫 //地图 int[][] map=new int[8][7]; //使用1表示墙 //上下全部置为1 for (int i=0;i&lt;7;i++)&#123; map[0][i]=1; map[7][i]=1; &#125; //左右全部置为1 for (int i=0;i&lt;8;i++)&#123; map[i][0]=1; map[i][6]=1; &#125; //设置挡板 1表示 map[3][1]=1; map[3][2]=1; // map[1][2]=1; // map[2][2]=1; //输出地图 System.out.println(\"地图的情况\"); for(int i =0;i&lt;8;i++)&#123; for (int j=0;j&lt;7;j++)&#123; System.out.print(map[i][j]+ \" \"); &#125; System.out.println(); &#125; //使用递归回溯 setWay2(map,1,1); //输出新的地图，小球走过，并标识过的递归 System.out.println(\"小球走过，并标识过的 地图的情况\"); for(int i =0;i&lt;8;i++)&#123; for (int j=0;j&lt;7;j++)&#123; System.out.print(map[i][j]+ \" \"); &#125; System.out.println(); &#125; &#125; //使用递归回溯来给小球找路 //说明 //1.map 表示地图 //2.i，j 表示从地图的哪个位置开始出发（1,1） //3.如果小球能到map【6】【5】位置，则说明通路找到 //4.约定：当map【i】【j】 为0表示该点没有走过 当为1表示墙，为2表示通路可以走；3表示该点已经走过，但是走不通 //5.走迷宫时，需要确定一个策略（方法) 下-》右-》上-》左，如果该点走不通，再回溯 /** * * @param map 表示地图 * @param i 从哪个位置开始找 * @param j * @return 如果找到通路，就返回true，否则返回false */ public static boolean setWay(int[][] map,int i,int j)&#123; if (map[6][5]==2)&#123; // 通路已经找到ok return true; &#125;else&#123; if (map[i][j]==0)&#123;//如果当前这个点还没有走过 //按照策略 下-》右-》上-》左 走 map[i][j]=2; //假定该点是可以走通 if (setWay(map, i+1, j))&#123;//向下走 return true; &#125;else if (setWay(map, i, j+1))&#123;//向右走 return true; &#125;else if (setWay(map, i-1, j))&#123;//向上走 return true; &#125;else if (setWay(map, i, j-1))&#123;//向左走 return true; &#125;else&#123; //说明该点是走不通的，是死路 map[i][j]=3; return false; &#125; &#125;else&#123; // 如果map[i][j]!=0,可能是1,2,3 return false; &#125; &#125;&#125;//修改找路的策略，改成 上——》右——》下——》左 public static boolean setWay2(int[][] map,int i,int j)&#123; if (map[6][5]==2)&#123; // 通路已经找到ok return true; &#125;else&#123; if (map[i][j]==0)&#123;//如果当前这个点还没有走过 //按照策略 上——》右——》下——》左走 map[i][j]=2; //假定该点是可以走通 if (setWay2(map, i-1, j))&#123;//向上 走 return true; &#125;else if (setWay2(map, i, j+1))&#123;//向右走 return true; &#125;else if (setWay2(map, i+1, j))&#123;//向下走 return true; &#125;else if (setWay2(map, i, j-1))&#123;//向左走 return true; &#125;else&#123; //说明该点是走不通的，是死路 map[i][j]=3; return false; &#125; &#125;else&#123; // 如果map[i][j]!=0,可能是1,2,3 return false; &#125; &#125; &#125;&#125; 1.6.3 对迷宫问题的讨论1）小球得到的路径，招路策略2）下右上左，在改成上右下左3）测试回溯现象4）思考：如何求出最短路径？思路：把所有的策略用一个数组的方式表示出来，用for循坏遍历，将2保存到一个集合中，最少的则为最短 1.7 八皇后1.7.1介绍不能再同一列，也不能在同一斜线 1.7.21）第一个皇后现放第一行第一列2）第二个皇后放在第二行第一列，然后判断是否OK（是否冲突），如果不OK，继续放在第二列、第三列、依次所有列都放完3）继续第三个皇后，。。。，直到第8个也能放在一个不冲突的位置，算是找到一个正确值4）当得到一个正确值，在栈会遇到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确值，全部得到5）然后回头继续第一个皇后放第二列，后面继续循坏执行1,2,3,4的步骤 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.atguigu.recursion;public class Queue8 &#123; //定义一个max表示共有多少个皇后 int max =8; //定义一个数组array,保存皇后放置的位置IDE结果，比如arr=&#123;0,4,7,5,2,6,1,3&#125; int[] array = new int[max]; static int count=0; static int judgeCount=0; public static void main(String[] args) &#123; //8皇后是否正确 Queue8 queue8 = new Queue8(); queue8.check(0); System.out.printf(\"一共有%d解法\",count); System.out.printf(\"一共判断的次数%d\",judgeCount); &#125; //编写一个方法，放置第n个皇后 //特别注意：check是每一次递归时，进入到check中都有 for (int i=0;i&lt;max;i++)，因此会有回溯 private void check(int n)&#123; if (n==max)&#123;//n=8，其实8个皇后就已然放好了 print(); return; &#125; //依次放入皇后，并判断是否冲突 for (int i=0;i&lt;max;i++)&#123; //先把当前这个皇后 n ，放到该行的第1列 array[n] =i; //判断当放置第n个皇后后到i列时，是否冲突 if (judge(n))&#123;//不冲突 //接着放n+1个皇后，即开始递归 check(n+1); //8个皇后 &#125; //如果冲突，就继续执行array[n]=i;即将第n个皇后，放置本行的后一个位置 &#125; &#125; //查看当我们放置第n个皇后，就去检测该皇后是否和前面已经摆放的皇后冲突 /** * * @param n 表示第n个皇后 * @return */ private boolean judge(int n)&#123; judgeCount++; for (int i=0;i&lt;n;i++)&#123; // 1.array[i]==array[n] 表示判断 第n个皇后是否和前面的n-1个皇后在同一列 // 2.Math.abs(n-i)==Math.abs(array[n]-array[i] 表示判断第n个皇后是否和第i个皇后是否在同一斜线 // n=1 放置第2列1 n = 1 array[1]=1 // Math.abs（1-0）==1 Math.abs（array[n]-array[i]）=Math.abs（1-0）=1 // 3.判断是否在同一行，没有必要，n每次都在递增 if (array[i]==array[n] || Math.abs(n-i)==Math.abs(array[n]-array[i]))&#123; return false; &#125; &#125; return true; &#125; //写一个方法，可以将皇后摆放的位置输出 private void print()&#123; count++; for (int i=0;i&lt;array.length;i++)&#123; System.out.print(array[i]+ \" \"); &#125; System.out.println(); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://lijiale96.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://lijiale96.github.io/tags/%E9%80%92%E5%BD%92/"}]},{"title":"牛客综合","slug":"牛客综合7","date":"2020-03-17T16:33:08.000Z","updated":"2020-03-18T16:34:10.965Z","comments":true,"path":"2020/03/18/牛客综合7/","link":"","permalink":"https://lijiale96.github.io/2020/03/18/%E7%89%9B%E5%AE%A2%E7%BB%BC%E5%90%887/","excerpt":"1、这种题目都有一种规律:先出来的序号后面一定不能有比他本身小的从小到大排列的序列。比如1234545321 正确43512（5后面有比它本身小且从小到大排序所以是错的）","text":"1、这种题目都有一种规律:先出来的序号后面一定不能有比他本身小的从小到大排列的序列。比如1234545321 正确43512（5后面有比它本身小且从小到大排序所以是错的） 2、在一个具有 n 个结点的有序单链表中插入一个新结点并仍然保持有序的时间复杂度是先遍历后插入。遍历O(n)，插入O(1)，加起来O(n)3、d为第1个出栈元素，则d之前的元素必定是进栈后在栈中停留。因而出栈顺序必为d_c_b_a_，e的顺序不定，在任一“_”上都有可能，一共有4种可能。【另解】d首先出栈，则abc停留在栈中，此时可以有如下4种操作：①e进栈后出栈，则出栈序列为decba；②c出栈，e进栈后出栈，出栈序列为dceba；③cb出栈，e进栈后出栈，出栈序列为dcbea；④cba出栈，e进栈后出栈，出栈序列为dcbae。4、顺序栈先要预定空间，而链式栈不需要预定空间5、栈、队列的插入和删除操作时间复杂度应该都是O(1)6、两个栈的栈底一个在数组第一个元素，朝着数组正方向增长另一个在数组最后一个元素，朝着数组索引减小的方向增长。当两个栈的栈顶相等是，表明数组满了，不能继续入栈7、广义表（ Lists ，又称列表） 是线性表的推广。线性表定义为 n&gt;=0 个元素 a1,a2,a3,…,an 的有限序列。线性表的元素仅限于原子项，原子是作为结构上不可分割的成分，它可以是一个数或一个结构，若放松对表元素的这种限制，容许它们具有其自身结构，这样就产生了广义表的概念 广义表的表头为空，并不代表该广义表为空表。例如：广义表()和(())不同。前者是长度为0的空表，对其不能做求表头和表尾的运算；而后者是长度为l的非空表(只不过该表中惟一的一个元素是空表)，对其可进行分解，得到的表头和表尾均是空表()广义表Ls(()); Ls 的元素为1，head(Ls)为空，但是Ls不为空。广义表Ls1();表示Ls1为空表。8、出栈顺序DCAB 不能出现AB表明D是第一个要出栈的，也就是ABCD都被压入栈内，那么出栈顺序为DCBA9、若某线性表最常用的操作是存取任一指定序号的元素和在最后进行插入和删除运算,则利用（）存储方式最节省时间。只要确定了顺序表的起始位置，线性表中任一元素都可以随机存取，所以线性表的顺序存储结构是一种随机存取的存储结构10、快速排序：关键节点前面的元素都比它小，后面的元素都比它大；选择排序：从剩余元素后面找最小元素和当前元素交换；插入排序：关键元素前面的元素已经排好序设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。一趟快速排序的算法是：1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。 11、栈的顺序存储空间为S(1: 50)，初始状态top=51，所以这个栈是50在栈底，1是开口向上的。经过一系列入栈、出栈之后，Top=50。那么此时栈中元素=51-50=1 12、邻接表指的是：为图的每个顶点建立一个单链表，第i个单链表中的结点表示依附于顶点Vi的边（对于有向图是以Vi为尾的弧）。13、T(N) = a*T(N/b) + O(N^d)T(N)是样本量为N的情况下的时间复杂度，a是子过程的部分，N/b是子过程的运行次数，N^d剩余其他的过程。 1) log(b,a) &gt; d -&gt; 复杂度为O(N^log(b,a))2) log(b,a) = d -&gt; 复杂度为O(N^d * logN)3) log(b,a) &lt; d -&gt; 复杂度为O(N^d)T（n）=1，n=1T(n)= 4T(n/2)+n,n&gt;1本题 a=4, b=2, d=1, case 1) O(n^2)","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://lijiale96.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"https://lijiale96.github.io/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"牛客综合6","slug":"牛客综合6","date":"2020-03-15T16:33:08.000Z","updated":"2020-03-16T16:47:40.138Z","comments":true,"path":"2020/03/16/牛客综合6/","link":"","permalink":"https://lijiale96.github.io/2020/03/16/%E7%89%9B%E5%AE%A2%E7%BB%BC%E5%90%886/","excerpt":"1、设用链表作为栈的存储结构则退栈操作：必须判别栈是否为空2、内层循环为O(N），外层也为O(N)，所以为O(N^2)3、首先折半查找，必须要求地址是连续的，数组，而且有明确的边界。然后还要求数组里面存放的数据是有序的，要不然无异于随机查找。4、用堆排序最好，因为堆排序不需要等整个排序结束就可挑出前50个最大元素，而快速排序和基数排序都需等待整个排序结束才能知道前50个最大元素。","text":"1、设用链表作为栈的存储结构则退栈操作：必须判别栈是否为空2、内层循环为O(N），外层也为O(N)，所以为O(N^2)3、首先折半查找，必须要求地址是连续的，数组，而且有明确的边界。然后还要求数组里面存放的数据是有序的，要不然无异于随机查找。4、用堆排序最好，因为堆排序不需要等整个排序结束就可挑出前50个最大元素，而快速排序和基数排序都需等待整个排序结束才能知道前50个最大元素。 5、一个长度为 n 的正整数数列，先递减再递增，如果要找到数列中最小的正整数，最优算法的平均时间复杂度是：O(log(n))6、先序：根 左 右中序：左 根 右后序：左 右 根 由先序 a b d e c f g ，可知根为 a 由中序 d b e a f c g ，可知左树为d b e ，右树为 f c g 于是，左树的后序为 d e b ，右树的后序为 f g c 因此，这棵树的后序为 d e b f g c a7、H(38)=38mod11=5但与addr(16)冲突。线性散列H(38)=(5+1)mod11=6但与addr(28)冲突。继续线性散列H(38)=(6+1)mod11=7但与addr(84)冲突。直到H(38)=9mod11=9成功8、栈可以用来消除递归，但消除递归不一定用栈，例如尾递归9、各种排序算法的时间复杂度：插入排序思想：将n个元素的数列分为已有序和无序两个部分，每次处理就是讲无序数列中的第一个元素与有序数列的元素从后往前逐个进行比较，找到插入位置，将该元素插入到有序数列的合适位置。希尔排序思想：希尔排序，也称为递减增量排序算法，是插入排序的一种高速而稳定的改进版本。 希尔排序是基于插入排序的以下两点性质而提出改进方法的：（1）插入排序在对几乎已经排好序的数据操作时，效率高，即可达到线性排序的效率；（2）但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；选择排序思想：首先在未排序的序列中找到最大（小）元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最大（小）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。堆排序的时间复杂不会超过n*lgn10、问题：给定一个整数序列，按照从小到大的顺序（确切地说，是非递减的顺序）排列序列中的整数。输入：一个整数序列。输出：整数序列，其中的整数升序排列。插入排序的思想：插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。 插入排序的C语言实现如下（a为数组首地址， size为数组中的元素个数）： 1234567891011void insertion_sort(int *a, size_t size) &#123; int i, j, t; for(i &#x3D; 1; i &lt; size; i++)&#123; t &#x3D; a[i]; j &#x3D; i - 1; while(j &gt;&#x3D; 0)&#123; if(a[j] &gt; t)&#123; a[j + 1] &#x3D; a[j]; &#125; else break; j--; &#125; j +&#x3D; 1; a[j] &#x3D; t; &#125;&#125; 插入排序的时间复杂度分析。在最坏情况下，数组完全逆序，插入第2个元素时要考察前1个元素，插入第3个元素时，要考虑前2个元素，……，插入第N个元素，要考虑前N - 1个元素。因此，最坏情况下的比较次数是1 + 2 + 3 + … + (N - 1)，等差数列求和，结果为N^2 / 2，所以最坏情况下的复杂度为O(N^2)。 最好情况下，数组已经是有序的，每插入一个元素，只需要考查前一个元素，因此最好情况下，插入排序的时间复杂度为O(N)。 11、资源的调度与分配用到了多种分配方式，其中最简单的就是，先来先服务，后面又根据实际情况在此基础上综合了优先权和短进程等方面的考虑。所以像栈这种后进先出的就不合适了 12、广度和深度遍历是遍历算法，目的是遍历所有节点而不是获得最短路径，Dijkstra、A*等算法才是描述最短路径的方法 13、有向无环图G中的有向边集合E={＜V1，V2＞，＜V2，V3＞，＜V3，V4＞，＜V1，V4＞}，则下列属于该有向无环图G的一种拓扑排序序列的是（V1,V2,V3,V4） 14、二分查找的基本思想是将n个元素分成大致相等的两部分，去a[n/2]与x做比较，如果x=a[n/2],则找到x,算法中止；如果x&lt;a[n/2],则只要在数组a的左半部分继续搜索x,如果x&gt;a[n/2],则只要在数组a的右半部搜索x.时间复杂度无非就是while循环的次数！总共有n个元素，渐渐跟下去就是n,n/2,n/4,….n/2^k，其中k就是循环的次数由于你n/2^k取整后&gt;=1即令n/2^k=1可得k=log2n,（是以2为底，n的对数）所以时间复杂度可以表示O()=O(logn) 15、二叉排序树的中序遍历一定有序将整数序列（7-2-4-6-3-1-5）按所示顺序构建一棵二叉排序树a（亦称二叉搜索树），之后将整数8按照二叉排序树规则插入树a中，请问插入之后的树a中序遍历结果是1-2-3-4-5-6-7-8。 16、如果六个字母不同则有A66 种方法但有两个字母重复，一个字母重复是除以2，两个就是A66 /4=180 17、初始森林中的n棵二叉树，每棵树有一个孤立的结点，它们既是根，又是叶子。 n个叶子的哈夫曼树要经过n-1次合并，产生n-1个新结点。最终求得的哈夫曼树有2n-1个结点。 18、A. 应该用｛｝， 而不是（）int a[] = {0， 0，0，0，0}；B. int a[10] = {}; 在C++11 中可以 以在大括号内不包含任何东西这种方式初始化数组，这将把所有元素都设置为0C.可以用int a[] = {0}; 这种方式，编译器就会计算元素个数D. int a[10] = {10*a}; a的值不可知 19、数组从栈中分配空间，链表从堆中分配空间数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://lijiale96.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"https://lijiale96.github.io/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"算法笔记3","slug":"算法笔记3","date":"2020-03-15T09:33:36.000Z","updated":"2020-03-18T14:26:53.063Z","comments":true,"path":"2020/03/15/算法笔记3/","link":"","permalink":"https://lijiale96.github.io/2020/03/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B03/","excerpt":"1、栈1.1 实际需求计算【7*2*2-5+1-5+3-3】计算机接收到的是一个字符串，底层怎么计算 1.2 栈的介绍1）stack2）先入后出3）栈顶：允许插入和删除的一端，为变化的一端 栈底：固定的一端4）加入和删除5）出栈pop、入栈push 1.3 应用场景1）子程序的调用2）处理递归调用3）表达式的转换【中缀表达式后缀表达式】与求值4）二叉树的遍历5）图形的深度优先（depth-first）搜索法","text":"1、栈1.1 实际需求计算【7*2*2-5+1-5+3-3】计算机接收到的是一个字符串，底层怎么计算 1.2 栈的介绍1）stack2）先入后出3）栈顶：允许插入和删除的一端，为变化的一端 栈底：固定的一端4）加入和删除5）出栈pop、入栈push 1.3 应用场景1）子程序的调用2）处理递归调用3）表达式的转换【中缀表达式后缀表达式】与求值4）二叉树的遍历5）图形的深度优先（depth-first）搜索法 1.4 思路1、使用数组来模拟栈2、定义一个top来表示栈顶，初始化为-13、入栈的操作，当有数据加入到栈时，top++，stack[top]=data;4、出栈的操作，int value =stack[top];top–,return value; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package com.atguigu.stack;import java.util.Scanner;public class ArrayStackDemo &#123; public static void main(String[] args) &#123; //测试一下ArrayStack 是否正确 //先创建一个ArrayStack 对象 -&gt;表示栈 ArrayStack stack = new ArrayStack(4); String key =\"\"; boolean loop = true;//控制是否退出菜单 Scanner scanner = new Scanner(System.in); while(loop)&#123; System.out.println(\"show: 表示显示栈\"); System.out.println(\"exit: 退出程序\"); System.out.println(\"push: 表示添加数据到栈（入栈）\"); System.out.println(\"pop: 表示从栈中取出数据（出栈）\"); System.out.println(\"请输入你的选择\"); key =scanner.next(); switch(key)&#123; case \"show\": stack.list(); break; case \"push\": System.out.println(\"请输入一个数\"); int value = scanner.nextInt(); stack.push(value); break; case \"pop\": try&#123; int res = stack.pop(); System.out.printf(\"出栈的数据是%d\\n\",res); &#125;catch(Exception e)&#123; System.out.println(e.getMessage()); &#125; break; case \"exit\": scanner.close(); loop =false; break; default: break; &#125; &#125; System.out.println(\"程序退出了\"); &#125;&#125;//定义一个ArrayStack 表示栈class ArrayStack&#123; private int maxSize; //栈的大小 private int[] stack; //数组，数组模拟栈，数据就放在该数组 private int top = -1; //构造器 public ArrayStack(int maxSize)&#123; this.maxSize=maxSize; stack = new int[this.maxSize]; &#125; //栈满 public boolean isFull()&#123; return top == maxSize-1; &#125; //栈空 public boolean isEmpty()&#123; return top==-1; &#125; //入栈-push public void push(int value)&#123; //先判断栈是否满 if (isFull())&#123; System.out.println(\"栈满\"); return; &#125; top++; stack[top] =value; &#125; //出栈-pop 将栈顶的数据返回 public int pop()&#123; //先判断栈是否空 if (isEmpty())&#123; //抛出异常 throw new RuntimeException(\"栈空，没有数据\"); &#125; int value =stack[top]; top--; return value; &#125; //显示栈的情况[遍历栈],遍历时，需要从栈顶开始显示数据 public void list()&#123; if (isEmpty())&#123; System.out.println(\"栈空，没有数据\"); return; &#125; //需要从栈顶开始显示数据 for (int i=top; i&gt;=0;i--)&#123; System.out.printf(\"stack[%d]=%d\\n\",i,stack[i]); &#125; &#125;&#125; HomeWork:使用链表来模拟栈（反转） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package com.atguigu.linkedlist;public class Homework2 &#123;public static class LLNode &#123; private Object data;&#x2F;&#x2F;存放数据 private LLNode next;&#x2F;&#x2F;指向下一个节点 public LLNode()&#123; &#125; public LLNode(Object data)&#123; this.data&#x3D;data; &#125; public Object getData() &#123; return data; &#125; public void setData(Object data) &#123; this.data &#x3D; data; &#125; public LLNode getNext() &#123; return next; &#125; public void setNext(LLNode next) &#123; this.next &#x3D; next; &#125;&#125;public static class LLStack &#123; LLNode headnode&#x3D;null; public LLStack()&#123; headnode&#x3D;new LLNode(null);&#x2F;&#x2F;先初始化 &#125; public boolean isEmpty()&#123;&#x2F;&#x2F;判断是否为空的 return headnode&#x3D;&#x3D;null; &#125; public void push(Object data)&#123;&#x2F;&#x2F;入栈 if(headnode.getData()&#x3D;&#x3D;null)&#123;&#x2F;&#x2F;判断头结点的值为空的时候 headnode.setData(data); &#125; else if(headnode&#x3D;&#x3D;null)&#123; headnode&#x3D;new LLNode(data); &#125; else &#123; LLNode newnode&#x3D;new LLNode(data); newnode.setNext(headnode); headnode&#x3D;newnode; &#125; &#125; public Object pop()&#123;&#x2F;&#x2F;出栈(返回栈顶的值，并且删除) Object data&#x3D;null; if(isEmpty())&#123; System.out.println(&quot;栈为空，返回值为0&quot;); return 0; &#125; data&#x3D;headnode.getData(); headnode&#x3D;headnode.getNext(); return data; &#125; public Object top()&#123;&#x2F;&#x2F;返回栈顶的值，但是不删除 Object data&#x3D;null; if(isEmpty())&#123; System.out.println(&quot;栈为空，返回值为0&quot;); return 0; &#125; data&#x3D;headnode.getData(); return data; &#125; public int getLength()&#123;&#x2F;&#x2F;得到栈里面值的个数 int count&#x3D;0; LLNode tempnode&#x3D;headnode; if(isEmpty()||tempnode.getData()&#x3D;&#x3D;null)&#x2F;&#x2F;当头结点为空，并且值也为空的时候就返回0 &#123; count&#x3D;0; &#125; else &#123; while(tempnode!&#x3D;null) &#123; count++; tempnode&#x3D;tempnode.getNext(); &#125; &#125; return count; &#125;&#125; public static void main(String[] args) &#123; LLStack llStack &#x3D; new LLStack(); llStack.push(1); llStack.push(2); llStack.push(3); llStack.push(4); llStack.push(5); llStack.push(6); System.out.println(&quot;栈里面值的个数为：&quot; + llStack.getLength()); llStack.pop(); llStack.pop(); llStack.pop(); llStack.pop(); System.out.println(&quot;pop4个之后，栈里面的个数 为 ：&quot; + llStack.getLength()); System.out.println(&quot;pop4个之后，栈顶的值为：&quot; + llStack.top()); &#125;&#125; 1.5 使用栈完成表达式的计算器(中缀表达式)1、通过一个index值（索引），来遍历我们的表达式2、如果我们发现是一个数字，就直接入数栈3、如果发现扫描是一个符号，就分如下情况 如果当前符号栈为空，就直接入栈 如果符号栈有操作符，就进行比较，如果当前的操作符的优先级小于或者等于栈中的操作符，就需要从数栈中pop出两个数，在从符号栈中pop出一个符 号，进行运算，得到结果，入数栈，然后当前的操作符入符号栈，如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈。4、当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并运行5、最后再数栈只有一个数字，就是表达式的结果 验证：3+2*6-2=？ 代码实现1、一位数的运算2、扩展多位数的运输选 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193package com.atguigu.stack;public class Calculator &#123; public static void main(String[] args) &#123; //表达式运算 String expression = \"(30+2)*6-2\";//创建两个栈，数栈，一个符号栈 ArrayStack2 numStack = new ArrayStack2(10); ArrayStack2 operStack = new ArrayStack2(10); //定义需要的相关变量 int index =0; //用于扫描 int num1 =0; int num2 =0; int oper =0; int res =0; char ch =' ';//将每次扫描得到char保存到ch String keepNum = \"\"; //开始while循坏的扫描expression while(true)&#123; //依次得到expression的，每一个字符 ch = expression.substring(index,index+1).charAt(0); //判断ch是什么，然后相应处理 if (operStack.isOper(ch))&#123;//如果是运算符 //判断当前的符号栈是否为空 if (!operStack.isEmpty())&#123; //如果符号栈有操作符，就进行比较，如果当前的操作符的优先级小于或者等于栈中的操作符，就需要从数栈中pop出两个数， // 在从符号栈中pop出一个符号，进行运算，得到结果，入数栈，然后当前的操作符入符号栈， if (operStack.priority(ch)&lt;=operStack.priority(operStack.peek()))&#123; num1 = numStack.pop(); num2 = numStack.pop(); oper=operStack.pop(); res=numStack.cal(num1,num2,oper); //运算结果入数栈 numStack.push(res); //当前的操作符入符号栈 operStack.push(ch); &#125;else &#123; // 如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈。 operStack.push(ch); &#125; &#125;else&#123; //如果为空直接入栈 operStack.push(ch);//1 + 3 &#125; &#125;else&#123; //如果是数，则直接入数栈 //numStack.push(ch-48); //? \"1+3+ '1'=&gt;1 //分析思路 //1、当处理多位数时，不能发现是一个数立即入栈，因为它可能是多位数 //2、在处理数，需要向expression的表达式index 后再看一位，如果是数就进行扫描，如果是符号才入栈 //3、因此我们需要定义一个变量字符串，用于拼接 //处理多位数 keepNum +=ch; //如果ch已经是expression 的最后一位，就直接入栈 if (index == expression.length()-1)&#123; numStack.push(Integer.parseInt(keepNum)); &#125;else &#123; //判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈 //注意是看后一位，不是index++ if (operStack.isOper(expression.substring(index + 1, index + 2).charAt(0))) &#123; //如果最后一位是运算符，则入栈 keepNum =“1” 或者“123” numStack.push(Integer.parseInt(keepNum)); //重要！！！清空keepNum keepNum = \"\"; &#125; &#125; &#125; //index+1，并判断是否扫描到expression最后 index++; if (index&gt;=expression.length())&#123; break; &#125; &#125; //当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并运行 while(true)&#123; //如果符号栈为空，则计算得到最后的结果，数栈中只有一个数字 if (operStack.isEmpty())&#123; break; &#125; num1 = numStack.pop(); num2 = numStack.pop(); oper= operStack.pop(); res =numStack.cal(num1,num2,oper); numStack.push(res); &#125; //将数栈的最后数，pop出，就是结果 int res2 = numStack.pop(); System.out.printf(\"表达式 %s =%d\", expression,res2); &#125;&#125;//先创建一个栈，直接使用前面创建好//定义一个ArrayStack2 表示栈，需要扩展功能class ArrayStack2&#123; private int maxSize; //栈的大小 private int[] stack; //数组，数组模拟栈，数据就放在该数组 private int top = -1; //构造器 public ArrayStack2(int maxSize)&#123; this.maxSize=maxSize; stack = new int[this.maxSize]; &#125; //可以返回当前栈顶的值，不是真正的pop public int peek()&#123; return stack[top]; &#125; //栈满 public boolean isFull()&#123; return top == maxSize-1; &#125; //栈空 public boolean isEmpty()&#123; return top==-1; &#125; //入栈-push public void push(int value)&#123; //先判断栈是否满 if (isFull())&#123; System.out.println(\"栈满\"); return; &#125; top++; stack[top] =value; &#125; //出栈-pop 将栈顶的数据返回 public int pop()&#123; //先判断栈是否空 if (isEmpty())&#123; //抛出异常 throw new RuntimeException(\"栈空，没有数据\"); &#125; int value =stack[top]; top--; return value; &#125; //显示栈的情况[遍历栈],遍历时，需要从栈顶开始显示数据 public void list()&#123; if (isEmpty())&#123; System.out.println(\"栈空，没有数据\"); return; &#125; //需要从栈顶开始显示数据 for (int i=top; i&gt;=0;i--)&#123; System.out.printf(\"stack[%d]=%d\\n\",i,stack[i]); &#125; &#125; //返回运算符的优先级，优先级是程序员来确定，优先级使用数字表示 //数字越大，则优先级越高 public int priority(int oper)&#123; if (oper=='(' || oper == ')')&#123; return 2; &#125; if (oper == '*'||oper=='/')&#123; return 1; &#125;else if (oper=='*'||oper=='/')&#123; return 0; &#125;else&#123; return -1; &#125; &#125; //判断是不是一个运算符 public boolean isOper(char val)&#123; return val == '+'||val=='-'||val =='*'||val=='/'; &#125; //计算方法 public int cal(int num1,int num2,int oper)&#123; int res =0; //res存放计算的结果 switch (oper)&#123; case '+': res=num1+num2; break; case '-': res=num2-num1; break; case '*': res=num2*num1; break; case '/': res=num2/num1; break; default: break; &#125; return res; &#125;&#125; 课后练习：给表达式加入小括号(见逆波兰计算器) 1.6 逆波兰计算器例如：（3+4）*5-61）前缀： - * + 3456从右至左 2）中缀：人类常用，计算机不好操作 3）后缀：逆波兰表达式 与前缀相似，运算符位于操作符之后从左至右 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.atguigu.stack;import java.util.ArrayList;import java.util.List;import java.util.Stack;public class PolandNotation &#123; public static void main(String[] args) &#123; //先定义一个逆波兰表达式 //(3+4)*5-6 =》 3 4 +5*6 - //4*5 -8 +60 +8/2 =&gt; 4 5* 8 - 60 + 8 2/ + //说明为了方便，逆波兰表达式的数字和符号使用空格隔开 String suffixExpression = \"30 4 + 5 * 6 - \"; String suffixExpression1 = \"4 5 * 8 - 60 + 8 2 / +\"; //思路 //1、先将\"3 4 + 5 * 6 - \" =&gt;放到ArrayList中 //2、将ArrayList 传递给一个方法，遍历ArrayList 配合栈 完成计算 // List&lt;String&gt; rpnList = getListString(suffixExpression); List&lt;String&gt; rpnList1 = getListString(suffixExpression1); // System.out.println(\"rpnList=\" + rpnList); System.out.println(\"rpnList1=\" + rpnList1); // int res = calculate(rpnList); int res1 = calculate(rpnList1); // System.out.println(\"计算的结果是=\"+res); System.out.println(\"计算的结果是=\"+res1); &#125; //将一个逆波兰表达式，依次将数据和运算符放入到ArrayList中 public static List&lt;String&gt; getListString(String suffixExpresssion)&#123; //将suffixExpression 分割 String[] split = suffixExpresssion.split(\" \"); List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (String ele: split)&#123; list.add(ele); &#125; return list; &#125; //完成对逆波兰表达式的计算 /** * 1)从左至右扫描，将3和4入堆栈； * 2）遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈 * 3）将5入栈 * 4）接下来是x运算符，因此弹出5和7，计算出7*5=35，将35入栈 * 5） 将6入栈 * 6）最后是-运算符，计算出35-6的值，即29，由此得出最终结果 */ public static int calculate(List&lt;String&gt; ls)&#123; //创建给栈，只需要一个栈即可 Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); //遍历 ls for (String item :ls)&#123; //这里使用正则表达式来取出数 if (item.matches(\"\\\\d+\"))&#123;//匹配的是多位数 //入栈 stack.push(item); &#125;else&#123; //pop出两个数，并运算，再入栈 int num2 = Integer.parseInt(stack.pop()); int num1 = Integer.parseInt(stack.pop()); int res = 0; if (item.equals(\"+\"))&#123; res = num1+num2; &#125;else if(item.equals(\"-\"))&#123; res = num1-num2; &#125;else if (item.equals(\"*\"))&#123; res =num1 *num2; &#125;else if (item.equals(\"/\"))&#123; res = num1 /num2; &#125;else&#123; throw new RuntimeException(\"运算符有误\"); &#125; //把res 入栈 stack.push(\"\"+ res ); &#125; &#125; //最后留在stack中的数据是运算结果 return Integer.parseInt(stack.pop()); &#125;&#125; 1.7 中缀表达式转换为后缀表达式中缀：人类常用，计算机不好操作后缀：逆波兰表达式 与前缀相似，运算符位于操作符之后 1.7.1 步骤：1）初始化两个栈，运算符栈s1和存储中间结果的栈s2；2）从左至右扫描中缀表达式3）遇到操作数，将其压入s2；4）遇到运算符时，比较其与s1栈顶运算符的优先级：（1）如果s1为空，或栈顶运算符为左括号“（”，则直接将此运算符入栈（2）否则，若优先级比栈顶运算符的高，也将运算符压入s1；（3）否则，将s1栈顶的运算符弹出并压入到s2中，再次转到（4-1）与s1中新的栈顶运算符相比较；5）遇到括号时：（1）如果是左括号“（”，直接压入s1（2）如果是右括号“）”，则依次弹出s1的栈顶运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃6）重复步骤2至5，直到表达式的最右边7）将s1中剩余的运算符依次弹出并压入s28）依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式 1.7.2 举例说明将中缀表达式”1+((2+3)*4)-5”转换为后缀表达式的过程如下 “1 2 3 + 4 * + 5 -“ 1.7.3 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195package com.atguigu.stack;import java.util.ArrayList;import java.util.List;import java.util.Stack;public class PolandNotation &#123; public static void main(String[] args) &#123; //完成将一个中缀表达式转成后缀表达式的功能 //说明 //1. 1+((2+3)*4)-5 =&gt;转成 1 2 3 + 4 * + 5 - //2. 因为直接对str进行操作，不方便，因此 先将“ 1+((2+3)*4)-5 ” =》 中缀表达式对应的List //即 “1+((2+3)*4)-5” =》ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] //3.将得到的中缀表达式对应的List =》 后缀表达式对应的List //即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] =》 ArrayList [1,2,3,+,4,*,+,5,-] String expression = \"1+((2+3)*4)-5\"; List&lt;String&gt; infixExpressionList = toInfixExpressionList(expression); System.out.println(\"中缀表达式对应的List=\"+infixExpressionList); //[1,+,(,(,2,+,3,),*,4,),-,5] List&lt;String&gt; suffixExpressionList = parseSuffixExpressionList(infixExpressionList); System.out.println(\"后缀表达式对应的List\"+suffixExpressionList);// ArrayList [1,2,3,+,4,*,+,5,-] System.out.printf(\"expression=%d\",calculate(suffixExpressionList)); //? //先定义一个逆波兰表达式 //(3+4)*5-6 =》 3 4 +5*6 - //4*5 -8 +60 +8/2 =&gt; 4 5* 8 - 60 + 8 2/ +s //说明为了方便，逆波兰表达式的数字和符号使用空格隔开// String suffixExpression = \"30 4 + 5 * 6 - \";// String suffixExpression1 = \"4 5 * 8 - 60 + 8 2 / +\"; //思路 //1、先将\"3 4 + 5 * 6 - \" =&gt;放到ArrayList中 //2、将ArrayList 传递给一个方法，遍历ArrayList 配合栈 完成计算 // List&lt;String&gt; rpnList = getListString(suffixExpression);// List&lt;String&gt; rpnList1 = getListString(suffixExpression1); // System.out.println(\"rpnList=\" + rpnList);// System.out.println(\"rpnList1=\" + rpnList1); // int res = calculate(rpnList);// int res1 = calculate(rpnList1); // System.out.println(\"计算的结果是=\"+res);// System.out.println(\"计算的结果是=\"+res1); &#125; //即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] =》 ArrayList [1,2,3,+,4,*,+,5,-] //方法.将得到的中缀表达式对应的List =》 后缀表达式对应的List public static List&lt;String&gt; parseSuffixExpressionList(List&lt;String&gt; ls)&#123; //定义两个栈 Stack&lt;String&gt; s1 = new Stack&lt;String&gt;(); //符号栈 //因为s2这个栈 在整个转换过程中，没有pop操作，而且后面我们还需要逆序输出 //因此比较麻烦，这里我们就不用Stack&lt;String&gt; 直接使用List&lt;String&gt; s2 //Stack&lt;String&gt; s2 = new Stack&lt;String&gt;(); //存储中间结果德1栈s2 List&lt;String&gt; s2 = new ArrayList&lt;String&gt;(); //存储中间结果的List2 //遍历ls for (String item:ls)&#123; //如果是一个数，加入s2 if (item.matches(\"\\\\d+\"))&#123; s2.add(item); &#125;else if (item.equals(\"(\"))&#123; s1.push(item); &#125;else if (item.equals(\")\"))&#123; //如果是右括号“）”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃 while(!s1.peek().equals(\"(\"))&#123; s2.add(s1.pop()); &#125; s1.pop();//!!!将（弹出 s1栈，消除小括号 &#125;else&#123; //当item的优先级小于等于s1栈顶运算符，将s1栈顶的运算符弹出并加入到s2中，再次转到（4.1）与s1中新栈顶运算符相比较 //问题：我们缺少一个比较优先级高低的方法 while(s1.size()!= 0 &amp;&amp; Operation.getValue(s1.peek()) &gt;= Operation.getValue(item))&#123; s2.add(s1.pop()); &#125; //还需要将item压入栈 s1.push(item); &#125; &#125; //将s1中剩余的运算符依次弹出并加入s2 while(s1.size()!=0)&#123; s2.add(s1.pop()); &#125; return s2; //注意因为是存放到List，因此按顺序输出就是对应的后缀表达式对应的List &#125; //方法： 将中缀表达式转成对应的List // s = 1+((2+3)*4)-5 public static List&lt;String&gt; toInfixExpressionList(String s)&#123; //定义一个List，存放中缀表达式对应的内容 List&lt;String&gt; ls = new ArrayList&lt;String&gt;(); int i=0;//这时是一个指针，用于遍历中缀表达式字符串 String str; //对多位数的拼接 char c;//每遍历一个字符，就放入到c do &#123; // 如果c是一个非数字，需要加入到ls if( (c=s.charAt(i))&lt;48 || (c=s.charAt(i)) &gt;57)&#123; ls.add(\"\"+c); i++; //i需要后移 &#125;else&#123; //如果是一个数，需要考虑多位数 str = \"\"; //先将str 置成\"\" '0'[48] -&gt; '9'[57] while(i&lt;s.length() &amp;&amp; (c=s.charAt(i))&gt;=48 &amp;&amp; (c=s.charAt(i))&lt;=57)&#123; str +=c;//拼接 i++; &#125; ls.add(str); &#125; &#125;while(i&lt;s.length()); return ls;//返回 &#125; //将一个逆波兰表达式，依次将数据和运算符放入到ArrayList中 public static List&lt;String&gt; getListString(String suffixExpresssion)&#123; //将suffixExpression 分割 String[] split = suffixExpresssion.split(\" \"); List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (String ele: split)&#123; list.add(ele); &#125; return list; &#125; //完成对逆波兰表达式的计算 /** * 1)从左至右扫描，将3和4入堆栈； * 2）遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈 * 3）将5入栈 * 4）接下来是x运算符，因此弹出5和7，计算出7*5=35，将35入栈 * 5） 将6入栈 * 6）最后是-运算符，计算出35-6的值，即29，由此得出最终结果 */ public static int calculate(List&lt;String&gt; ls)&#123; //创建给栈，只需要一个栈即可 Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); //遍历 ls for (String item :ls)&#123; //这里使用正则表达式来取出数 if (item.matches(\"\\\\d+\"))&#123;//匹配的是多位数 //入栈 stack.push(item); &#125;else&#123; //pop出两个数，并运算，再入栈 int num2 = Integer.parseInt(stack.pop()); int num1 = Integer.parseInt(stack.pop()); int res = 0; if (item.equals(\"+\"))&#123; res = num1+num2; &#125;else if(item.equals(\"-\"))&#123; res = num1-num2; &#125;else if (item.equals(\"*\"))&#123; res =num1 *num2; &#125;else if (item.equals(\"/\"))&#123; res = num1 /num2; &#125;else&#123; throw new RuntimeException(\"运算符有误\"); &#125; //把res 入栈 stack.push(\"\"+ res ); &#125; &#125; //最后留在stack中的数据是运算结果 return Integer.parseInt(stack.pop()); &#125;&#125;//编写一个类Operation 可以返回一个运算符 对应的优先级class Operation&#123; private static int ADD =1; private static int SUB =1; private static int MUL =2; private static int DIV =2; //写一个方法，返回对应的优先级数字 public static int getValue(String operation)&#123; int result =0; switch(operation)&#123; case \"+\": result=ADD; break; case \"-\": result=SUB; break; case \"*\": result=MUL; break; case \"/\": result=DIV; break; default: System.out.println(\"不存在该运算符\"); break; &#125; return result; &#125;&#125; 注：toInfixExpressionList、parseSuffixExpressionList 1.7.4 逆波兰计算器完整版1）支持 +-*/()2) 多位数，支持小数3） 兼容处理 过滤任何空白字符，包括空格、制表符、换页符","categories":[{"name":"算法","slug":"算法","permalink":"https://lijiale96.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://lijiale96.github.io/tags/%E6%A0%88/"}]},{"title":"牛客综合5","slug":"牛客综合5","date":"2020-03-14T16:33:08.000Z","updated":"2020-03-15T03:56:21.565Z","comments":true,"path":"2020/03/15/牛客综合5/","link":"","permalink":"https://lijiale96.github.io/2020/03/15/%E7%89%9B%E5%AE%A2%E7%BB%BC%E5%90%885/","excerpt":"1、一个二叉树,前序遍历结果是:a b d g c e f h;中序遍历结果是:d g b a e c f h 求后序遍历结果是:g d b e h f c a解析：已知二叉树的中序遍历和前序遍历，如何求后序遍历第一步，root最简单，前序遍历的第一节点就是root。第二步，对于前序遍历，除了G是root外，剩下的结点都是root的左右子树。没有其它信息第三步，观察中序遍历，其中root结点a左侧的dgb必然是root的左子树，a右侧的ecfh必然是root的右子树。第四步，观察左子树dgb，左子树的中的根节点必然是大树root的leftchild。一定是先把root和root的所有左子树节点遍历完之后才会遍历右子树，并且遍历的右子树的第一个节点就是右子树的根节点。 第五步，root的右子树的结点ecfh也可以通过前序遍历求得。在前序遍历中，一定是先把root和root的所有左子树节点遍历完之后才会遍历右子树，并且遍历的右子树的第一个节点就是右子树的根节点。 如何知道哪里是前序遍历中的左子树和右子树的分界线呢？通过中序遍历去数节点的个数。 在上一次中序遍历中，root左侧是dgb，所以有3个节点位于root左侧。那么在前序遍历中，必然是第1个是a，第2到第4个由dgb过程，第6个就是root的右子树的根节点了，是c。 第六步，观察发现，上面的过程是递归的。先找到当前树的根节点，然后划分为左子树，右子树，然后进入左子树重复上面的过程，然后进入右子树重复上面的过程。最后就可以还原一棵树了。 第七步，其实，如果仅仅要求写后续遍历，甚至不要专门占用空间保存还原后的树。只需要稍微改动第六步，就能实现要求。仅需要把第六步的递归的过程改动为如下: 1) 确定根,确定左子树，确定右子树。 2) 在左子树中递归。 3)在右子树中递归。 4) 打印当前根。","text":"1、一个二叉树,前序遍历结果是:a b d g c e f h;中序遍历结果是:d g b a e c f h 求后序遍历结果是:g d b e h f c a解析：已知二叉树的中序遍历和前序遍历，如何求后序遍历第一步，root最简单，前序遍历的第一节点就是root。第二步，对于前序遍历，除了G是root外，剩下的结点都是root的左右子树。没有其它信息第三步，观察中序遍历，其中root结点a左侧的dgb必然是root的左子树，a右侧的ecfh必然是root的右子树。第四步，观察左子树dgb，左子树的中的根节点必然是大树root的leftchild。一定是先把root和root的所有左子树节点遍历完之后才会遍历右子树，并且遍历的右子树的第一个节点就是右子树的根节点。 第五步，root的右子树的结点ecfh也可以通过前序遍历求得。在前序遍历中，一定是先把root和root的所有左子树节点遍历完之后才会遍历右子树，并且遍历的右子树的第一个节点就是右子树的根节点。 如何知道哪里是前序遍历中的左子树和右子树的分界线呢？通过中序遍历去数节点的个数。 在上一次中序遍历中，root左侧是dgb，所以有3个节点位于root左侧。那么在前序遍历中，必然是第1个是a，第2到第4个由dgb过程，第6个就是root的右子树的根节点了，是c。 第六步，观察发现，上面的过程是递归的。先找到当前树的根节点，然后划分为左子树，右子树，然后进入左子树重复上面的过程，然后进入右子树重复上面的过程。最后就可以还原一棵树了。 第七步，其实，如果仅仅要求写后续遍历，甚至不要专门占用空间保存还原后的树。只需要稍微改动第六步，就能实现要求。仅需要把第六步的递归的过程改动为如下: 1) 确定根,确定左子树，确定右子树。 2) 在左子树中递归。 3)在右子树中递归。 4) 打印当前根。 2、设该森林共有m棵树，每棵树有ni(1≤i≤m)个节点，依据树的性质有N=N1+N2+…+NmM=(N1-1)+(N2-1)+…+(Nm-1)上面两式相减得N-M=1+1+…+1=m而m就是树的个数，所以该森林共有N-M棵树。3、冒泡排序法的平均时间复杂度为O(n^2)二分法的平均时间复杂度度是O（logn）,好于顺序表查找的O(n).快速排序法的最坏的情况下时间复杂度等于冒泡排序法，都为O(n^2)4、有向无环图才存在拓扑序列，两条弧&lt;Vi, Vj&gt;和&lt;Vj, Vi&gt;形成环，后面与前面矛盾。5、哈佛曼编码：左小右大；左0右1；同值即另起炉灶6、快速排序 12345678910111213141516171819202122232425262728291：左指针：49 （不小于49）右指针：50, 27（不大于49）交换（49,27）27，38, 65, 97, 76, 13, 49, 502：左指针：27, 38, 65（不小于49）右指针：49（不大于49）交换（65,49）27，38, 49, 97, 76, 13, 65, 503：左指针：49（不小于49）右指针：65， 13（不大于49）交换（49,13）27，38, 13, 97, 76, 49, 65, 504：左指针：13， 97（不小于49）右指针：49（不大于49）交换（97,49）27，38, 13, 49, 76, 97, 65, 505：左指针：49（不小于49）右指针：97， 76， 49（不大于49）左右指针相等，第一趟结束&#123;27，38, 13&#125; 49 &#123;76, 97, 65, 50&#125; 7、程序的环路复杂性给出了程序基本路径集中的独立路径条数，这是确保程序中每个可执行语句至少执行一次所必需的测试用例数目的上界McCabe复杂性程序的环路复杂性，简单的定义为控制流图的区域数。从程序的环路复杂性可导出程序基本路径集合中的独立路径条数，这是确保程序中每个可执行语句至少执行一次所必需的最少测试用例数。判定节点法通过控制流图中判定节点数计算。若P为控制流图中的判定节点数，则V(G)=P+1。控制流图中有3 个判定节点，因此其环路复杂性V(G)=P+1=2+1=3，所以该程序段的环路复杂性为3。 流图G的环形复杂度V(G)=E-N+2，其中，E是流图中边的条数，N是结点数8、我觉得要看这50个块之间是否是有序的。要是有序，可以二分查找，然后确定在那一个块中((n+1)log2(n+1))/n - 1 ，然后在这个块中查找要是无序，则顺序查找，平均查找长度就是 （1+50）/2=25.5，然后块中查找(1+4)/2=2.5 总共289、注意是按列存储的,所以地址应该是： (行长度 * (所在列 - 1) + 所在行 - 1) * 单元长度 + 起始地址 (6 * (6 - 1) + 6 - 1) * 5 + 1000 = 1175 是要替换. 所在行就是所求元素在行或列中的位置. a[5][5]是第6行第6个元素（下标从0开始的）所在行所在列都是6. 公式不用记的,第6行第6个元素按列存储前面有5列完整的列,加上第6列上前面有5个元素,所以前面一共有6 * (6 - 1) + 6 - 1个元素.10、一趟快速排序意思是：寻找一个支点，将该序列位置整个调整一边，可以看到M是支撑点，左边都是比M小的，右边都是比M大的，注意：支点不一定是左边第一个数，可以任意选的。11、考察的是完全二叉树的性质以及公式推导。完全二叉树的节点个数可以看作满二叉树的基础上从叶子节点最右端逐渐删除叶子节点的树。计算等比数列求和：Sn=a1(1-qn)/(1-q) n相当于树的高度。代入当n=7时为一颗高度7的满二叉树，节点总数为128。根据题干节点总数从右依次去除5个节点构成总数为123的完全二叉树。其中从右依次去除第3、4节点（编号为125，126）的父结点为最小叶子节点。对于i&gt;0，其父节点的编号为(i-1)/2 得出为62。12、无向图特有:连接多重表。有向图特有:十字链表，边集数组。二者共有:邻接表，邻接矩阵。13、顺序表是 随机访问 找到是o(1),删除是o(n).线性表是顺序访问，找到是o(n),删除是o(1)仔细看了题目（删除值X），所以不管是顺序表还是链表都需要先查找这个X,所以时间是O(N)，之后链表O(1)删除，顺序表是O(N),所以最终答案是O(N)。14、首先说明一点,我们平时一般所说的哈夫曼树是指最优二叉树,也叫做严格二叉树（注意不是完全二叉树）,但是哈夫曼树完全不局限于二叉树,也存在于多叉树中,即度为m的哈夫曼树,也叫最优m叉树,严格m叉树（注意不是完全m叉树）. 这题表示哈夫曼树的节点 的度要么是0要么是m设度不为0（即非叶结点 ）的个数为X则总的结点数为：X+n除根结点外，其余的每一个结点都有一个分支连向一个结点，对于度为m的每个结点都有m个分支，而度为0的结点是没有分支的，所以从分支的情况来看总的结点数位：Xm + 1（这里的1为根结点）两者相等，所以答案是 （n-1) / （m-1）15、KMP为线性算法，处理主和匹配串的复杂度都为o（N），o(n+m)16、1.根节点：首先确定“-”为根节点2.分隔左右子树：先序和后序不能确定二叉树的序列，可根据四个选项知道abdc+为左子树节点，e/f为有字数节点。3.右子树：根据先序和后序确定右子树中，e为/的根节点，f为e的左子树。4.左子树：确定+为左边元素的根节点。5.再看四个选项，四个选项中的先序排列中，ab在+的左侧，dc在+的右侧。6.+的左子树：根据先序中ab的顺序，知b为a的有节点。7.+的右子树：根据先序确定c为+的右子节点，再由先序和后序知道d为的左子节点，*为c的左子节点。17、在无向图中，如果从顶点vi到顶点vj有路径，则称vi和vj连通。如果图中任意两个顶点之间都连通，则称该图为连通图，否则，称该图为非连通图，则其中的极大连通子图称为连通分量，这里所谓的极大是指子图中包含的顶点个数极大。 A,边的条数为C（n,2）=n(n-1)/2B,G是完全图，必定是连通图。所以连通分量只有其自身C，G是完全图，必定是连通图D，每个顶点都与其余n-1个顶点相连，则n个顶点度的和为n(n-1)","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://lijiale96.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"https://lijiale96.github.io/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"IEEE认证收条","slug":"IEEE认证收条","date":"2020-03-13T05:58:49.000Z","updated":"2020-03-13T11:19:52.770Z","comments":true,"path":"2020/03/13/IEEE认证收条/","link":"","permalink":"https://lijiale96.github.io/2020/03/13/IEEE%E8%AE%A4%E8%AF%81%E6%94%B6%E6%9D%A1/","excerpt":"提交IEEE会议论文， 但是在检测PDF格式的时候被通知说PDF不合格，由于 Font Helvetica is not embedded x85 page5-6. 我的PDF是由Latex直接生成的，不知道为什么会出现这种情况。在网上搜了一下，说是 IEEE 为了能够在任何地方打印文档，要求投稿的 PDF 文档一定要嵌入所有的字体。而根据邮件当中的报告，我的 pdf 文档当中没有嵌入 Helvetica 字体。 解决这个问题废了些时间，特此写个文档以做记录。","text":"提交IEEE会议论文， 但是在检测PDF格式的时候被通知说PDF不合格，由于 Font Helvetica is not embedded x85 page5-6. 我的PDF是由Latex直接生成的，不知道为什么会出现这种情况。在网上搜了一下，说是 IEEE 为了能够在任何地方打印文档，要求投稿的 PDF 文档一定要嵌入所有的字体。而根据邮件当中的报告，我的 pdf 文档当中没有嵌入 Helvetica 字体。 解决这个问题废了些时间，特此写个文档以做记录。 1.怎样查看自己的pdf文档嵌入了哪些字体？用 Adobe Reader 中打开对应的 pdf 文档，然后在菜单栏上选择：文件–&gt;属性–&gt;字体，在打开的窗口当中如果所有的字体都说“已嵌入子集”则表明字体成功嵌入。否则就说明有未嵌入的字体。我查看了一下，我的 pdf 文档中，字体 Helvetica 确实是没有嵌入。 2.Pdf 文档中的 Helvetica 字体从何而来？ 这是由于我的论文当中包含了用matlab画出来的eps图形文件，matlab用plot画出来的图中字体默认就是Helvetica。 3.解决办法：将论文中使用的 eps 图形文件用 写字板 或 记事本 或 Ultraledit 或 Matlab Editor 窗口 等等打开，我用的是VScode，打开后是一些字符文本，将这些文字当中的 Helvetica 全部替换成为 Arial，然后重新由 CTEX 生成 PDF 文件，这样所有的字体就都能够嵌入了。 这样操作之后，我重新在 IEEE PDF eXpress 上面上传论文，之后收到了检测成功的确认邮件:Congratulations! The following PDF has passed the PDF Check:The approved file is attached to this message, and is labeled within its document properties as being “Certified by IEEE PDF eXpress”, with an exact date and time stamp. The file attached to this message is the file that you should submit to your conference’s final paper collection site. Please remember that ANY changes made to your PDF at this point could impact Xplore compatibility. PDF eXpress has examined and passed only the file version submitted to the site. This email serves as the official confirmation. Follow your conference guidelines for submitting your final paper to the conference. The deadline is 10 April 2020. A Reminder: PDF eXpress is NOT the final collection site. Thank you for using PDF eXpress!","categories":[{"name":"科研","slug":"科研","permalink":"https://lijiale96.github.io/categories/%E7%A7%91%E7%A0%94/"}],"tags":[{"name":"IEEE认证收条","slug":"IEEE认证收条","permalink":"https://lijiale96.github.io/tags/IEEE%E8%AE%A4%E8%AF%81%E6%94%B6%E6%9D%A1/"}]},{"title":"牛客综合4","slug":"牛客综合4","date":"2020-03-12T16:33:08.000Z","updated":"2020-03-12T17:00:54.203Z","comments":true,"path":"2020/03/13/牛客综合4/","link":"","permalink":"https://lijiale96.github.io/2020/03/13/%E7%89%9B%E5%AE%A2%E7%BB%BC%E5%90%884/","excerpt":"1、按顺序ABCD进栈，则出栈顺序不可能存在的是CABD，B再A的前面 2、中序遍历二叉排序树得到的才是有序的序列 3、前序遍历：先根，后左，再右；中序遍历：先左，后根，再右；后序遍历：先左，后右，再根；因为前序遍历和中序遍历分别为ABDEGCFH和DBGEACHF，可得二叉树为：DGEBHFCA","text":"1、按顺序ABCD进栈，则出栈顺序不可能存在的是CABD，B再A的前面 2、中序遍历二叉排序树得到的才是有序的序列 3、前序遍历：先根，后左，再右；中序遍历：先左，后根，再右；后序遍历：先左，后右，再根；因为前序遍历和中序遍历分别为ABDEGCFH和DBGEACHF，可得二叉树为：DGEBHFCA 4、数据库完整性（Database Integrity）是指数据库中数据在逻辑上的一致性、正确性、有效性和相容性。数据库完整性由各种各样的完整性约束来保证，因此可以说数据库完整性设计就是数据库完整性约束的设计。数据库完整性约束可以通过DBMS或应用程序来实现，基于DBMS的完整性约束作为模式的一部分存入数据库中。通过DBMS实现的数据库完整性按照数据库设计步骤进行设计，而由应用软件实现的数据库完整性则纳入应用软件设计5、（哈希表）散列表的一个重要参数是负载因子a，a=散列表中结点的数目/基本区域能容纳的结点数。负载因子的大小体现散列表的装满程度。a越大，发生碰撞的可能性越大，一般取a＜1。题目中的散列表结点的数目为7，基本区域能容纳的结点数为19，因此a=7/19≈0.37。6、散列的基本思想是以结点的关键码作为自变量，通过散列函数将其映射到记录的存储地址。建立一个散列表之前需要解决两个主要问题:⑴构造一个合适的哈希函数H(key)的值同等均匀分布在哈希表中，提高地址计算的速度。⑵冲突的处理冲突:在散列表中，不同的关键字值对应到同一个存储位置的现象。即关键字K1≠K2，但 H(K1)=H(K2)。均匀同等的哈希函数可以减少冲突（不能避免冲突，发生冲突后，必须寻 找下一个可用地址）。7、平衡二叉树是根节点的左右子树高度差小于等于1的二叉排序树，二叉排序树要求根节点的左子树上的值都要比它小，右子树上的值都要比它大。所以堆是完全二叉树但不是平衡二叉树堆：对于一个数组中的关键字，如果按照完全二叉树的结点来造树，则 完全二叉树中的非终端结点关键字值不大于（不小于）其左右孩子的值。8、1NF：关系中的每个属性都不可分。2NF：消除了非主属性对于码（键）的部分函数依赖。3NF：消除了非主属性对于码（键）的传递函数依赖。BCNF：消除了主属性对于码（键）的部分或传递函数依赖。9、视图的定义强于表，视图可以包含多个表，所以应该是选择。而更新等操作就显得力有不逮了10、I的反例：计算斐波拉契数列迭代实现只需要一个循环即可实现。Ⅲ的反例：入栈序列为1、2，进行如下操作PUSH、PUSH、POP、POP，出栈次序为2、1；进行如下操作PUSH、POP、PUSH、POP，出栈次序为1、2。Ⅳ，栈是一种受限的线性表，只允许在一端进行操作。Ⅱ正确。11、层次模型:有且仅有一个节点无父节点，此节点为根节点，其他节点有且仅有一个父节点网状模型：允许有一个以上的无双亲的节点，一个节点可以有多于一个的双亲12、下三角矩阵A，A[5][5]的地址：1+2+3+4+5+6=21A[5][4]地址：21-1=20A[5][4]-A[0][0]=20-1=1913、step1. mid=(left+right)//2=5 num[5]=97 13&lt;97 right=mid-1=4step2. mid=(left+right)//2=2 num[2]=33 13&lt;33 right=mid-1=1step3. mid=(left+right)//2=0 num[0]=7 13&gt;7 left=mid+1=1step4. mid=(left+right)//2=1 num[1]=13 13==13 break注意最后确定的时候还要判断一次。14、truncate删除表数据的同时将自动ID置1，delete删除表数据是ID不会置1，说明delete不释放空间15、交换左右子树，然后回溯到它们的根，“左右根”正好是后序遍历的顺序16、 首先要理解为穿越问题。然后如下分析： 所有球离开的最长时间，就可以等效为最后离开的那个球的时间，也就变成找哪个球离左边或右边出口的距离最远，显然5个球中，第一个球离右端出口（33-3）=30是距离最远的，故最后答案是30； 若求最短时间，同上，找每个球离左右出口最小的值中的最大值即可。最后是（33-19）=1417、RDBMS 即关系数据库管理系统(Relational Database Management System)RDBMS 是SQL 的基础，同样也是所有现代数据库系统的基础，比如MS SQL Server, IBM DB2, Oracle, MySQL 以及Microsoft Access。hadoop是分布式数据库18、有一颗二叉树的前序遍历和后续遍历分别是1,2,3,4和4,3,2,1，则该二叉树的中序遍历可能是123423414321","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://lijiale96.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://lijiale96.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"https://lijiale96.github.io/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"算法笔记2","slug":"算法笔记2","date":"2020-03-12T09:33:36.000Z","updated":"2020-03-14T09:11:51.819Z","comments":true,"path":"2020/03/12/算法笔记2/","link":"","permalink":"https://lijiale96.github.io/2020/03/12/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B02/","excerpt":"1、链表1.1 链表介绍链表是有序的列表，内存存储含data域及next域小结：1）链表是以节点的方式来存储的，是链式存储2）每个节点包含data域，next域：指向下一节点3）各个节点不一定是连续存储的4）链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定","text":"1、链表1.1 链表介绍链表是有序的列表，内存存储含data域及next域小结：1）链表是以节点的方式来存储的，是链式存储2）每个节点包含data域，next域：指向下一节点3）各个节点不一定是连续存储的4）链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定 单链表（带头节点）逻辑结构示意图类似羊肉串 1.2 单链表的应用实例使用带head头的单向链表实现 -水浒传英雄排行榜管理完成对英雄人物的增删改查 1) 第一种方法添加英雄，直接添加到链表的尾部 2）第二种，考虑排名 3）修改节点功能思路 先找到改节点，通过遍历 temp.name=newHeroNode.name;temp.nickname=newHeroNode.nickname; 4）删除节点思路: 先找到需要删除的真个节点的前一个节点temp temp.next=temp.next.next 被删除的节点，将不会有其他引用指向，会被垃圾回收机制回收 5）代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203package com.atguigu.linkedlist;public class SingleLinkedListDemo &#123; public static void main(String[] args) &#123; //进行测试 //先创建节点 HeroNode hero1 = new HeroNode(1,\"宋江\",\"及时雨\"); HeroNode hero2 = new HeroNode(2,\"卢俊义\",\"玉麒麟\"); HeroNode hero3 = new HeroNode(3,\"吴用\",\"智多星\"); HeroNode hero4 = new HeroNode(4,\"林冲\",\"豹子头\"); //创建要给链表 SingleLinkedList singleLinkedList = new SingleLinkedList(); //加入// singleLinkedList.add(hero1);// singleLinkedList.add(hero2);// singleLinkedList.add(hero3);// singleLinkedList.add(hero4); //加入按照编号的顺序 singleLinkedList.addByteOrder(hero1); singleLinkedList.addByteOrder(hero3); singleLinkedList.addByteOrder(hero4); singleLinkedList.addByteOrder(hero2); singleLinkedList.addByteOrder(hero2); singleLinkedList.addByteOrder(hero2); //显示 singleLinkedList.list(); //测试修改节点的代码 HeroNode newHeroNode = new HeroNode(2,\"小卢\",\"玉麒麟\"); singleLinkedList.update(newHeroNode); System.out.println(\"修改后的链表情况\"); singleLinkedList.list(); //删除一个节点 singleLinkedList.del(1); singleLinkedList.del(4); singleLinkedList.del(2); singleLinkedList.del(3); System.out.println(\"删除后的链表的情况\"); singleLinkedList.list(); &#125;&#125;//定义SingleLinkedList 管理我们的英雄class SingleLinkedList&#123; //先初始化一个头节点，头结点不要动 private HeroNode head = new HeroNode(0,\"\",\"\"); //添加节点到单向链表 //思路：当不考虑编号顺序时 //1.找到当前链表的最后节点 //2.将最后这个节点的next 指向新的节点 public void add(HeroNode heroNode)&#123; //因为head节点不能动，因此我们需要一个辅助temp HeroNode temp = head; //遍历链表，扎到最后 while(true)&#123; // if (temp.next==null)&#123;// break; &#125; //如果没有找到最后，最后temp后移 temp=temp.next; &#125; //当退出循环时，temp就指向了链表的最后 //将最后这个节点的next 指向新的节点 temp.next = heroNode; &#125; //第二种方式在添加英雄时，根据排名将英雄插入到指定位置 //（如果有这个排名，则添加失败，并给出提出） public void addByteOrder(HeroNode heroNode)&#123; //因为头结点不能动，因此我们仍然通过一个辅助指针（变量）来帮助找到添加的位置 //因为单链表，因为我们找到的temp是位于添加位置的前一个节点，否则插入不了 HeroNode temp = head; boolean flag = false;//flag标志添加的编号是否存在，默认为false while(true)&#123; if (temp.next==null)&#123;//说明temp已经在链表的最后 break; &#125; if(temp.next.no &gt; heroNode.no)&#123; //位置找到，就在temp的后面插入 break; &#125;else if (temp.next.no==heroNode.no)&#123;//说明希望添加的heroNode的编号已然存在 flag = true;//说明编号存在 break; &#125; temp =temp.next;//后移，遍历当前链表 &#125; //判断flag的值 if (flag)&#123; //不能添加，说明编号存在 System.out.printf(\"准备插入的英雄编号 %d 已经存在了，不能加入 \\n\",heroNode.no); &#125;else&#123; //插入到链表中，temp的后面 heroNode.next=temp.next; //后面一条线 temp.next=heroNode;//前面的线 &#125; &#125; //修改节点信息，根据编号来修改，即no编号不能改 //说明 //1.根据newHeroNode的no来修改即可 public void update(HeroNode newHeroNode)&#123; //判断是否为空 if (head.next==null)&#123; System.out.println(\"链表为空\"); return; &#125; //找到需要修改的节点，根据no编号 //定义一个辅助变量 HeroNode temp = head.next; boolean flag = false;//表示是否找到该节点 while(true)&#123; if (temp==null)&#123; break;//已经遍历完链表 &#125; if(temp.no==newHeroNode.no)&#123; //找到 flag = true; break; &#125; temp=temp.next;&#125; //根据flag 判断是否找到要修改的节点 if (flag)&#123; temp.name=newHeroNode.name; temp.nickname=newHeroNode.nickname; &#125;else&#123; //没有找到 System.out.printf(\"没有找到 编号%d的节点，不能修改\\n\",newHeroNode.no); &#125; &#125; //删除节点 //思路 //1.head 不能动 因此我们需要一个temp辅助节点找到待删除节点的前一个节点 //2.说明我们在比较时，是temp.next.no和需要删除的节点的no比较 public void del(int no)&#123; HeroNode temp = head; boolean flag = false;//标志是否找到待删除节点的 while(true)&#123; if (temp.next==null)&#123; //已经到链表的最后 break; &#125; if (temp.next.no == no )&#123; //找到的待删除节点的前一个节点temp flag = true; break; &#125; temp =temp.next; //temp后移，遍历 &#125; //判断flag if (flag)&#123;//找到 //可以删除 temp.next = temp.next.next; &#125;else&#123; System.out.printf(\"要删除的%d 节点不存在\\n\",no); &#125; &#125; //显示链表【遍历】 public void list()&#123; //判断链表是否为空 if (head.next==null)&#123; System.out.println(\"链表为空\"); return; &#125; //因为头节点，不能动，因此我们需要一个辅助变量来遍历 HeroNode temp = head.next; while(true)&#123; //判断是否到链表最后 if (temp ==null)&#123; break; &#125; //输出节点信息 System.out.println(temp); //将temp后移 temp =temp.next; &#125; &#125;&#125;//定义HeroNode，每个HeroNode对象就是一个节点class HeroNode&#123; public int no; public String name; public String nickname; public HeroNode next; //指向下一个节点 //构造器 public HeroNode(int no,String name,String nickname)&#123; this.no=no; this.name=name; this.nickname=nickname; &#125; //为了显示方便，我们重写toString @Override public String toString() &#123; return \"HeroNode&#123;\" + \"no=\" + no + \", name='\" + name + '\\'' + \", nickname='\" + nickname + '\\'' + '&#125;'; &#125;&#125; 1.3、面试题1.3.1 查找单链表中的倒数第k个节点【新浪】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//测试 单链表中有效节点的个数 System.out.println(\"有效的节点个数=\"+ getLength(singleLinkedList.getHead()));//测试倒数第k个节点 HeroNode res =findLastIndexNode(singleLinkedList.getHead(),1); System.out.println(\"res\"+res); &#125; //查找单链表中的倒数第k个节点【新浪面试题】 //思路 //1.编写一个方法，接收head节点，同时接收一个index //2.index 表示是倒数第index个节点 //3.先把链表从头到尾遍历，得到链表的总的长度 //4.得到size后，我们从链表的第一个开始遍历（size-index）个，就可以得到 //5.如果找到了，则返回该节点，否则返回null public static HeroNode findLastIndexNode(HeroNode head,int index)&#123; //判断如果链表为空，返回null if (head.next==null)&#123; return null;//没有找到 &#125; //第一个遍历得到链表的长度（节点个数） int size = getLength(head); //第二次遍历 size-index 位置，就是我们倒数的第k个节点 //先做一个index的校验 if (index &lt;=0 || index &gt;size)&#123; return null; &#125; //定义个辅助变量,for 循坏定位到倒数的index HeroNode cur = head.next;//3 for (int i=0;i&lt;size-index;i++)&#123; cur = cur.next; &#125; return cur; &#125; //方法：获取单链表的节点的个数（如果是带头节点的链表，需求不统计头节点） /** * * @param head 链表的头节点 * @return 返回的是有效节点的个数 */ public static int getLength(HeroNode head)&#123; if (head.next==null)&#123; //空链表 return 0; &#125; int length =0; //定义一个辅助变量,这里没有统计头节点 HeroNode cur = head.next; while(cur!=null)&#123; length++; cur = cur.next;//遍历 &#125; return length; &#125; 1.3.2 单链表反转【腾讯】思路：1、先定义一个节点reverseHead = new HeroNode();2、从头到尾遍历原来的链表，每遍历一个节点，就将其取出，并放在3、原来的链表的head.next=reverseHead.next 代码： 123456789101112131415161718192021//将单链表反转 public static void reversetList(HeroNode head)&#123; //如果当前链表为空，或者只有一个节点，无需反转，直接返回 if (head.next ==null|| head.next.next==null)&#123; return; &#125; //定义一个辅助的指针（变量），帮助我们遍历原来的链表 HeroNode cur = head.next; HeroNode next =null;//指向当前节点【cur】的下一个节点 HeroNode reverseHead = new HeroNode(0,\"\",\"\"); //遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端 //动脑筋 while(cur!=null)&#123; next = cur.next;//先暂时保存当前节点的下一个节点，因为后面需要使用 cur.next=reverseHead.next;//将cur的下一个节点指向新的链表的最前端 reverseHead.next=cur;//将cur连接到新的链表上 cur=next;//让cur后移 &#125; //将head.next指向reverseHead.next,实现单链表的反转 head.next=reverseHead.next; &#125; 1.3.3 从尾到头打印单链表【百度】思路：1、逆序2、方式1：反转；遍历（破坏原单链表的结构） 123456789101112131415161718192021//将单链表反转 public static void reversetList(HeroNode head)&#123; //如果当前链表为空，或者只有一个节点，无需反转，直接返回 if (head.next ==null|| head.next.next==null)&#123; return; &#125; //定义一个辅助的指针（变量），帮助我们遍历原来的链表 HeroNode cur = head.next; HeroNode next =null;//指向当前节点【cur】的下一个节点 HeroNode reverseHead = new HeroNode(0,\"\",\"\"); //遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端 //动脑筋 while(cur!=null)&#123; next = cur.next;//先暂时保存当前节点的下一个节点，因为后面需要使用 cur.next=reverseHead.next;//将cur的下一个节点指向新的链表的最前端 reverseHead.next=cur;//将cur连接到新的链表上 cur=next;//让cur后移 &#125; //将head.next指向reverseHead.next,实现单链表的反转 head.next=reverseHead.next; &#125; 3、方式2：利用栈这个数据结构，将各个节点压入到栈中，然后利用先进后出，实现逆序打印 12345678910111213141516171819//方式2： // 可以利用栈这个数据结构，将各个节点压入栈中，利用先进后出的特点，就实现逆序打印 public static void reversePrint(HeroNode head)&#123; if (head.next==null)&#123; return;//空链表，不能打印 &#125; //创建要给要给栈，将各个节点压入栈 Stack&lt;HeroNode&gt; stack = new Stack&lt;HeroNode&gt;(); HeroNode cur = head.next; //将链表的所有节点压入栈 while(cur!=null)&#123; stack.push(cur); cur=cur.next; //cur后移，这样就可以压入下一个节点 &#125; //将栈中的节点进行打印，pop出栈 while(stack.size()&gt;0) &#123; System.out.println(stack.pop()); &#125; &#125; 课后作业：合并两个有序的单链表，合并之后的链表依然有序 2、双向链表2.1 双向链表的遍历，增删改思路1）遍历和单链表一样，可向前、向后查找2）添加（默认添加到双向链表的最后）（1）先找到双向链表的最后这个节点（2）temp.next=newHeroNode（3）newHeroNode.pre=temp;3）修改和单链表一样4）删除（1）因为是双向链表，可实现自我删除某个节点（2）直接找到要删除的这个节点，比如temp（3）temp.pre.next=temp.next（4）temp.next.pre=temp.pre","categories":[{"name":"算法","slug":"算法","permalink":"https://lijiale96.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://lijiale96.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"牛客综合3","slug":"牛客综合3","date":"2020-03-11T15:32:47.000Z","updated":"2020-03-11T15:42:03.715Z","comments":true,"path":"2020/03/11/牛客综合3/","link":"","permalink":"https://lijiale96.github.io/2020/03/11/%E7%89%9B%E5%AE%A2%E7%BB%BC%E5%90%883/","excerpt":"1、物理结构即存储结构，在不同的计算机上使用都会产生不同的结果，因此与所使用的计算机有关。而逻辑结构是通用的，在任何不同的计算机上所进行的运算操作都是统一的。 2、-1,2,7,28,,126请问28和126中间那个数是什么对于这样的选择题，如果能看出规律更好，如果不能看出规律要根据选项做答。题目中的数可以从0开始数，即n=0,1,2…当n为偶数时，通项为：n^3-1当n为奇数时，通项为：n^3+1","text":"1、物理结构即存储结构，在不同的计算机上使用都会产生不同的结果，因此与所使用的计算机有关。而逻辑结构是通用的，在任何不同的计算机上所进行的运算操作都是统一的。 2、-1,2,7,28,,126请问28和126中间那个数是什么对于这样的选择题，如果能看出规律更好，如果不能看出规律要根据选项做答。题目中的数可以从0开始数，即n=0,1,2…当n为偶数时，通项为：n^3-1当n为奇数时，通项为：n^3+1 3、从左到右进行运算的，先计算1+5，因为都是int型相加，所以结果是6，再计算6+” bottles of milk”，因为是int型与string进行运算，所以结果是“6 bottles of milk”，转换成String类型的结果 4、对象之间进行通信的构造叫做消息， A 正确。多态性是指同一个操作可以是不同对象的行为， D 错误。对象不一定必须有继承性， C 错误。封装性是指从外面看只能看到对象的外部特征，而不知道也无须知道数据的具体结构以及实现操作， B 错误 5、在数据库系统中建立索引主要有以下作用：(1)快速取数据，主要是用来检索数据，而对于数据的增删改等没有性能上的提升。——B正确，D错误。(2)保证数据记录的唯一性;——A正确。主索引:可确保字段中输入值的唯一性并决定了处理记录的顺序。可以为数据库中的每一个表建立一个主索引。如果某个表已经有了一个主索引，可以继续添加候选索引候选索引:像主索引一样要求字段值的唯一性并决定了处理记录的顺序。在数据库表和自由表中均可为每个表建立多个候选索引表可以有多个候选索引， 数据库表和自由表都可以建立候选索引，只有数据库表才能建立主索引，自由表不能。——C错误。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://lijiale96.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"编程基础","slug":"编程基础","permalink":"https://lijiale96.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}]},{"title":"字节跳动面经","slug":"字节跳动面经","date":"2020-03-11T14:52:22.000Z","updated":"2020-03-23T11:57:11.585Z","comments":true,"path":"2020/03/11/字节跳动面经/","link":"","permalink":"https://lijiale96.github.io/2020/03/11/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E7%BB%8F/","excerpt":"高频问题高频问题后面面经挺长的，嫌太长的可以只看这部分。基本上你在简历的技能树上写了以下关键词，那这些高频问题你会特别眼熟，有些会附上解答，有写错的地方欢迎指正~（敲黑板，这都是要考的重点） 设计模式单例模式懒汉、饿汉、双重校验锁、静态内部类工厂模式JAVA基础抽象类和接口区别集合类的结构Iterator、Collection（List、Set、Queue）、MapArrayList和LinkedList的区别HashMap底层结构数组 + 链表Put 的过程为什么长度是2的倍数找索引时 key 的 hash 值与数组的长度值减 1 进行与运算，长度为 2 的倍数时能减少碰撞JDK 1.7 和 1.8 中 HashMap 的区别1.8 增加红黑树、头插变为尾插、扩容后元素位置要么在原位置，要么在原位置 + 扩容前旧容量为什么线程不安全扩容时链表可能形成闭环ConcurrentHashMap 怎么保证线程安全ConcurrentHashMap 和 HashMap 区别线程池线程池常用参数核心线程数、最大线程数、阻塞队列、线程最大存活时间线程池工作流程线程池的类别和区别阻塞队列的类别和区别","text":"高频问题高频问题后面面经挺长的，嫌太长的可以只看这部分。基本上你在简历的技能树上写了以下关键词，那这些高频问题你会特别眼熟，有些会附上解答，有写错的地方欢迎指正~（敲黑板，这都是要考的重点） 设计模式单例模式懒汉、饿汉、双重校验锁、静态内部类工厂模式JAVA基础抽象类和接口区别集合类的结构Iterator、Collection（List、Set、Queue）、MapArrayList和LinkedList的区别HashMap底层结构数组 + 链表Put 的过程为什么长度是2的倍数找索引时 key 的 hash 值与数组的长度值减 1 进行与运算，长度为 2 的倍数时能减少碰撞JDK 1.7 和 1.8 中 HashMap 的区别1.8 增加红黑树、头插变为尾插、扩容后元素位置要么在原位置，要么在原位置 + 扩容前旧容量为什么线程不安全扩容时链表可能形成闭环ConcurrentHashMap 怎么保证线程安全ConcurrentHashMap 和 HashMap 区别线程池线程池常用参数核心线程数、最大线程数、阻塞队列、线程最大存活时间线程池工作流程线程池的类别和区别阻塞队列的类别和区别 JVM内存结构和各自存放的内容方法区、堆、虚拟机栈、本地方法栈、程序计数器新生代和老年代垃圾回收算法新生代 -&gt; 复制，老年代 -&gt; 标记-整理（CMS用的标记-清除）CMS/G1的流程初始标记 -&gt; 并发标记 -&gt; 重新标记 -&gt; 并发清除CMS/G1的特点和区别CMS：尽可能减少停顿时间，采用标记-清除，会造成内存碎片化G1：可以预测停顿时间，采用标记-整理，减少内存碎片化， 将内存划分为 region 粒度判断垃圾是否可以回收的方法引用计数法、可达性分析法哪些对象可以作为GC ROOT SpringIOC 和 AOP 的含义和原理Spring、SpringBoot、SpringMVC 的区别SpringBoot 的启动流程Bean 的生命周期SpringMVC 的流程 ＭySQL事务什么是事务事务的特性（ACID），详细说明各个特性的含义原子性、一致性、隔离性、持久性事务隔离级别未提交读 -&gt; 已提交读 -&gt; 可重复读 -&gt; 串行化脏读、不可重复读、幻读的区别事务隔离级别怎么实现预防上述问题（eg: 可重复读怎么实现预防不可重复读）索引常用索引（B树、Hash）聚簇索引和非聚簇索引的区别联合索引和单个索引的区别，联合索引的最左匹配原则B树和B+树的区别B+树的非叶子节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”B+树查询必须查找到叶子节点，B树只要匹配到即可不用管元素位置，因此B+树查找更稳定（也不慢）对于范围查找来说，B+树只需遍历叶子节点链表即可，B树却需要重复地中序遍历 RedisRedis 的五种数据结构String、Hash、List、Set、Zset（SortSet）Redis 为什么快纯内存、单线程、IO多路复用（一般会继续问IO多路复用相关问题）Redis 持久化RDB、AOFRedis 高可用哨兵机制、Redis Cluster、持久化（上面那个） 计算机网络点击一个URL到页面返回，发生了什么客户端传给服务端时经过 TCP/IP 四层模型，中途依次加入HTTP报文、TCP报文、IP报文、MAC报文，然后逆序依次拆包OSI 七层模型 &amp; TCP/IP 四层模型cookie 和 session 的区别TCP &amp; UDPTCP 三次握手,四次挥手的流程（最好能画图，说明各阶段状态）为什么需要三次握手防止已过期的连接再次传到被连接的主机为什么需要四次挥手 / 断开连接时为什么比建立连接多一次服务端的 ACK 和 FIN 一般都会分开发送，ACK 表示自己收到了客户端的断开请求（但还有数据没传输完），FIN 表示自己传输完了数据TCP 和 UDP 的区别TIME_WAIT 的作用保证客户端发送的最后一个ACK报文能够到达服务器防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失HTTPSHTTPS的优势CA证书认证、加密传输HTTPS建立连接流程为什么传输过程中采用对称加密，协商时采用非对称加密对称加密快 操作系统进程 &amp; 线程进程和线程的区别进程间通信方式管道、消息队列、信号量、共享内存线程间通信方式消息队列、全局变量Linux（几乎为Linux命令）查找某个进程（ps aux |grep threadId）杀掉某个进程（kill，参数添加-9表示强制执行）查看某个端口是否被占用（netstat -anp |grep threadId）实时查看进程状态（top） 算法最大子序列和反转链表 见算法笔记2数组中查找两数之和为K的序列对 Test1C++的三个特性面向对象跟面向过程区别面向对象有什么好处简单介绍下你的项目，数据库如何设计的，如果数据库插入的时候碰到两个主键一样的如何处理，（正确应该是写一个更新的sql语句？）写sql语句，查一下借过某同一本书的人的信息MVC中的controller层可以去掉吗，为什么你的项目中mvc三个层次是如何通信的，谁可以调用谁，以添加为例Java中函数的回调是什么描述一下输入url到刷新到网页的整个过程TCP四层模型分别是什么网络层有哪些协议TCP的三次握手过程描述一下，四次挥手描述一下，为什么建立连接的时候是三次握手，断开连接是四次Java的内存机制了解吗，不了解就没往下问Java的锁机制了解吗，不了解就没往下问Java线程的基本状态进程同步的方法进程和线程的区别读锁跟写锁，详细解释一下，读的时候可不可以写或读，写的时候可不可以读或写，如果要操作一个数组，共有五个进程，四个正在读，现在剩下一个进程要写，现在会怎么样Java抽象函数跟接口的区别，什么时候适合用抽象函数什么时候适合用接口，你在平时有用过吗如果要想c加加那样一个类继承多个类，在java中该怎么做最后编程题， 判断字符串交错给定三个字符串a, b, c, 判断c是否可以通过字符串a, b的子串按顺序交错组成.例如:a: “btdne” b: “yeac” c: “bytedance”返回: Truea: “bytece” b: “dan” c: “bytedance”返回: Truea: “bytec” b: “dan” c: “bytedance”返回: Falsea: “byte” b: “danced” c: “bytedance”返回: False Test2自我介绍项目介绍Java线程池原理介绍一下匿名内部类介绍一下，为什么传入的变量要是final的volatile关键字的原理和作用，能否保证对共享变量正确控制设计模式常用哪些，三个工厂模式介绍一下redis的数据结构，String和list的底层实现redis 主从架构 + 哨兵机制mysql的RR隔离级别介绍一下介绍聚簇索引和非聚簇索引介绍底层B+树结构，叶子节点存储的内容介绍最左前缀。以及字符串的最左查询 在 4 5 6 7 1 2 3 这种螺旋排序数组中进行查找日志文件找出现最频繁的k个word，以及考虑大文件分割处理StingBuilder 和 StringBuffer 的区别mysql 隔离级别mysql 索引B+树，为什么不用 HashMapTCP 四次挥手 作者：offer怎么这么难链接：https://www.nowcoder.com/discuss/378926?type=2&amp;order=0&amp;pos=3&amp;page=1来源：牛客网 没有自我介绍(直接拉十分钟的家常)介绍实习和项目对RPC和缓存了解吗，讲一下跳表https 和 http 区别算法1：一个数组，等概率获取m个不同的元素算法2：排序数组 -3, -2,-2,1,1,2,2,3,4 输出每个元素平方后有多少个不同的元素 空间O(1) Test3介绍项目项目出现超卖如何解决 你的项目是限定一人秒杀一个商品，那如果一人可以购买两件商品，如何建表，如何保证不超卖？可以用原来的表吗？（需要新建一个表，乐观锁）如何使用乐观锁 版本号怎么唯一，说了利用数据库自增id，太慢，接着说了雪花算法，还有其他吗，说了zookeeper，可是我不会这个… 为什么需要新建表，有什么字段，新建表后可能出现什么问题（查询关联表过多） 那如何解决关联表过多（给关联表增加相应索引，引入redis） redis如何解决缓存一致性 减库存过程，为什么不先减库存再查询是否存在订单 减库存命令，redis 如何保证这个命令原子性（redis的单线程模型） 如果有一个用户发起大量请求，这个他第一个请求还没有写入数据库，也就是他可以一直减库存，如何解决？一开始想的是接口限流，但是面试官说现在要对某个用户限流怎么办，在面试官提示下说了用redis来记录用户访问次数 redis分布式锁，实现过程，命令，可能出现的问题 进程与线程关系 进程通信 进程fork子进程，两个进程占用内存情况 用户访问你的服务经过哪些网络协议 一个数据先递增再递减，找出数组不重复的个数，比如 [1, 3, 9, 1]，结果为3，不能使用额外空间，复杂度o(n) 二面（1h）redis 缓存穿透，布隆过滤器 项目中redis用了什么数据结构，字符串，内部原理 redis整数存储有什么优化 redis故障转移过程 https公钥哪里来的，握手过程 jvm垃圾回收，三色标记算法 垃圾回收时间使用过多怎么解决 tcp和udp区别 客户端和服务端可以开启多少个tcp连接 新建一个线程消耗的资源 高考成绩2000万数据，分数0-700，如何快速知道你的排名，如何知道任一分数排名，刚开始想到按照快排思路进行查找，后来想到桶排序 一硬币，一面向上概率0.7，一面0.3，如何公平 两根香，一根烧完1小时，如何测量15分钟 两个链表，可能相交，找出相交的节点，给出证明 写一个函数，求平方根，函数参数为目标数字和精度，测试案例 fn(4.1,0.001) fn(501.1,0.001) fn(0.045,0.001) 三面（1h）给定m个不重复的字符 [a, b, c, d]，以及一个长度为n的字符串tbcacbdata，问能否在这个字符串中找到一个长度为m的连续子串，使得这个子串刚好由上面m个字符组成，顺序无所谓，返回任意满足条件的一个子串的起始位置，未找到返回-1。比如上面这个例子，acbd，3。 Test4一面：进程和线程，区别，哪个效率高，为什么事务的特性，具体介绍隔离级别，具体介绍幻读死锁的条件，如何解决java的基本数据类型和字节数Java，volatile关键字进程如何同步mysql索引结构，特点，为什么使用这个如果查询比较高效查询学生成绩大于等于60的所有人的姓名和编号聚集索引和非聚集索引String，StringBuffer，StringBuilder区别HashMap，为什么使用红黑树垃圾回收机制GC，cms，G1，垃圾回收的算法TCP连接和释放 编程题：36进制由0-9，a-z，共36个字符表示，最小为’0’‘0’‘9’对应十进制的09，’a’‘z’对应十进制的1035例如：’1b’ 换算成10进制等于 1 36^1 + 11 36^0 = 36 + 11 = 47要求按照加法规则计算出任意两个36进制正整数的和如：按照加法规则，计算’1b’ + ‘2x’ = ‘48’要求：不允许把36进制数字整体转为10进制数字，计算出10进制累加结果再转回为36进制 二面：谈谈项目？？？mongodb底层原理或者数据结构是什么，事务处理，插入和mysql有什么区别，为什么会慢类加载过程（Java），每一步做了什么子类和父类的实例变量和方法有什么区别重载和覆盖区别，返回值类型不同，可以重载吗，为什么，底层如何实现的java多线程，状态图，画出来，阻塞的状态有哪几种，运行顺序，多线程的一些方法java泛型ThreadLocal，Concurrent下面的包，原理是什么，AtomicInteger，原理是什么，如何做到高效率的，有什么优化措施悲观锁和乐观锁@Transaction的原理，还有比如在一个类中两个方法，一个是B方法，一个是C方法，B上没有注解，C上有那么在外面调用B方***有事务，为什么，根据底层原理能不能推断出来（给提示问你能不能推断出来）查询学生成绩不及格的所有人的姓名和编号，根据这个语句，如何建立索引，为什么，mysql底层是什么，为什么效率高，主键能不能太大，为什么，如果太大，底层数据结构会不会变化，为什么linux查询tcp连接处理CLOSE_WAIT的状态的数目了不了解RabbitMQ，kafka，RocketMQ，ActiveMQ，以及其他消息中间件redis为什么效率高，线程，数据结构，网络模型，aio，nio，bio，为什么这么设计？如何处理高并发 编程题：这是一个多叉树，Node应该是这样，当时并没有给，这是我觉得是这样的，当时只给了方法和说明是多叉树Node {T value;Node[] children;}public Integer getValue(Node root, int level, int index){}找到第 i 层的第 index 个结点的值，如果没有，返回null，时间复杂度是多少 三面：数据仓库，雪花模型和星型模型区别和用处，数据仓库的过程（分层），如何设计数据仓库和数据湖的区别分布系统的设计，分布式系统CAP，分布式系统的模型linux环境下的线上业务管理 有没有，如何管理redis的集合有没有限制，限制是多少redis的1w条的插入和更新有什么区别mysql join的底层原理是什么，有哪几种（不是左右连接这种）linux命令查询一个文件内出现重复最多的数字的linux命令查询一个文件的行数 编程题：使用程序如何查询一个文件内的重复最多的次数的数字，如何高效实现，时间复杂度，空间复杂度镜像二叉树快排或堆排还一个智力，也很简单，就不写了 总体来说第三面有点难呀，前两面还行，但是编程题也太简单了。。。。。没想到肯定还有一些我可能没记住，而且还有一些我就要根本没听懂的问题。。。。 Test5一面数据库隔离级别数据库事务特性select epoll poll三连java运行时内存区域（整个面试就问了这么一个java相关）free命令下的cache和buffer的区别（说了说cache和buffer的概念就白给了）避免死锁方式（就说了个先来先服务）手撕代码：最长上升子序列的个数二面手撕代码：最长的不包含重复字符的子串长度设计题：学生成绩表（设计表+查询平均成绩大于60的学生的姓名和平均成绩（写SQL语句））设计题：爬虫时如何判断url是否访问过。大致说了两种思路：前缀树和hash+链表的处理方式浏览器输入url后的过程DNS解析过程hr面都是常规问题，就不具体写了。就说一两天后出结果求问大家字节的内容审查部门咋样？ Test6作者：指定没你滴好果汁吃链接：https://www.nowcoder.com/discuss/377804?type=2&amp;order=0&amp;pos=8&amp;page=1来源：牛客网 一面：1.算法：快排大概5分钟2.算法：二叉树的前序遍历非递归开始没仔细看题目，写了个递归的（1分钟），然后面试官尴尬一笑，我赶紧改成非递归了3.算法：二叉树的后序遍历非递归大概说了一下，没让我写4.算法：求数组的最长连续递增数列，如：4， 200， 3， 1， 100， 2。结果是1 2 3 4，也就是说顺序可以打乱。这道题之前面试官问我学没学过动态规划，我说刷题的时候自己学过，怕他出的太难，我说只会做简单的，然后他出了这题。我的思路是先排序，然后从前往后，if(array[i]-array[i-1]==1) then dp[i]=dp[i-1]+1; else dp[i]=1。说实话，我感觉这题拍完序就跟动态规划没什么关系了……他问我复杂度，我说nlogn吧，要排个序。他说太高了，让我再像个办法。我说，找个很大的数组，把所有的数字都以数值为下标放在这个数组上，然后从前往后遍历，找到最长连续的，如这题a[4]=1,a[200]=1,a[3]=1,a[1]=1……不过这样空间复杂度很大。面试官给的思路是用一个hashtable，hash到4的时候，看看hash（3）和hash（5）是否存在，类似这样的思路5.socket编程和netty不会6.http三次握手，如果第三次客户端发出的信息服务器没收到怎么办？7.操作系统有哪些调度方式？8.如果让你实现按照优先级的抢占式调度，你会如何实现？有0-15个优先级，0是最高的优先级我回答是，把所有任务放在一个小根堆里，堆顶的自然就是目前的任务队列优先级最高的任务，拿出来即可。面试官说可以用十六个任务队列，每次从优先级最高的任务队列头取出即可9.java的hashmap如何实现的？我首先回答了一下hash冲突是什么，有哪些解决办法（拉链、线性探测、平方探测、再hash），然后说java是数组+下面挂着的链表实现的，顺口说了一句：实际中很多地方都是拉链法，比如redis的hashtable也是这么做的。接下来开始了长达十几分钟的redis环节10.redis基本数据类型以及如何实现的11.redis的三种集群我讲的很多很长，如何配置，遇到的坑，还有bind_ip是什么意思（监听网卡，而不是外部机器访问的ip），cluster模式的slot，在线迁移数据reshard，去中心化设计的原因12.如果让你实现redis的负载均衡，你如何实现hash、一致性hash、加一个代理服务器13.redis的通信协议是什么？gossip14.说几个常用的linux命令15.mysql索引结构？为什么用B树？16.智力题，海盗分金币。一开始不会，后来他提示我，从后往前想，如果只剩两个人了会怎么样，如果只剩三个？……最后答出来了 二面：1.算法：接雨水（leetcode 42）大概15分钟，跑了5个用例。然后面试官说：嗯，我们再来一道难一点的…2.算法：有一个IP地址库，假设有几十万条ip，如何判断某个ip地址是否在这个库中？开始我还以为这是设计题，结果是算法。蒙了…完全不知道什么意思，和面试官扯了十分钟还是不知道什么意思。中间我还说了，要不换道题吧，我实在是不知道怎么做，但面试官还在引导我，我还是不会，没办法，最后简化了很多，做出来了，思路是二分查找的变体，不过把数组换成了存储对象的有序List。3.https如何实现对称加密+非对称加密4.用户态和内核态5.类加载过程6.mybatis优缺点优点是灵活好用，缺点不知道7.重载和重写区别8.get和post区别我只说到了一个在url可见，另一个不可见，常用于发送大量数据。事后查了一下，好像远不止这么简单9.你还有什么擅长的地方？不知道…感觉都差不多（脑海略过一大堆，spring家族、mysql、不敢说擅长），redis？“一面面试官反映你redis还不错，我就不问了”10.问问题，结束 最大的感受：这两个月大部分内容都白复习了……字节跳动很看重计算机基础学科的知识，以及算法。简历上的Spring家族、微服务、消息队列、设计模式、还有项目相关的，这些一句都没问我。甚至JAVA两面加起来都只问了3个问题 最后我想问下为啥面经看到的都是三面，怎么我只有两面？？？后端开发开发者平台这个岗位是干啥的？ Test7作者：shallin链接：https://www.nowcoder.com/discuss/372001?type=2&amp;order=0&amp;pos=9&amp;page=2来源：牛客网 1、 先介绍下你自己 2、 一题算法题 找出数组中出现频率占数组长度一半的方法（我用了先排序然后如果存在那么中间的数必然是所求，在计算其遍历排完序的数组求出这个中间这个数的频率，面试官觉得要排序复杂度太高） 3、 你比较擅长什么（比较了解java基础，了解java虚拟机，设计模式了解单例工厂和代理，数据库，redis，rabbitmq） 4、 Java反射在虚拟机上是怎么实现的。（我说了怎么使用反射，反射的作用。然后说这个类似于浅拷贝，拷贝了地址） 5、 Jvm的垃圾回收机制（分代） 6、 为什么要分代回收（针对标记清理，复制算法的优缺点） 7、 Mysql有几种存储引擎（我只了解的是innodb和myISAM） 8、 Innodb用索引用的是什么数据结构 9、InnodbB+树有什么特点 10、为什么不用其他的数据结构（我结合了硬盘读取的特点，预读，节点大小等于一个预读的数据大小，所以不使用二叉树等，又从原理上讲了为什么B+树比B树更加的稳定，效率更高） 11、redis的跳表(这个我不知道，没用过) 12、redis为什么性能高 13、这个我忘记问了什么（我不知道） 14、redis有多少种持久化方式（AOF和RDB） 15、RDB和AOF的实现步骤是怎样的。（首先讲了RDB如何从配置文件去改他的保存的方式，然后面试官打断我，他不准备听如何配置了） 16、数据库的事务是什么（相当于两个用户进行两个会话） 17、事务的特性（讲了四个特性，具体指什么） 18、什么是脏读，什么是幻读（我详细解释了脏读和幻读） 19、你还有什么要问的吗？ 20、还有什么你会的我没问到吗？ Test8作者：肥羊E_hirta链接：https://www.nowcoder.com/discuss/371292?type=2&amp;order=0&amp;pos=20&amp;page=1来源：牛客网 自我介绍JVM是做什么的？你的理解？接口和抽象类的区别有种东西叫抽象接口类，在抽象类中实现接口，你实现过这样的代码吗，有什么用（我：强制子类也实现接口）设计模式，我讲了单例：饿汉懒汉、双检锁、静态内部类写代码：实现一个抽象类，要求继承它的子类可以不用自己再实现单例模式，而自动可以利用父类的机制来获取到单例我在父类里弄了个饿汉式，子类直接调用super的getInstance()返回单例实例面试官：一般单例不是不应该允许new去创建新实例的吗，那样就破坏单例了，怎么实现这个限制？我：那就把子类的构造方法设成private面试官：那父类呢？要是创建了父类对象怎么办？我：那就父类也设成private然后运行发现报错了面试官：为什么会这样？我：（思考）因为子类默认构造函数要调用父类构造函数，然后父类只有一个private的构造函数，它对子类不可见后面不记得了。。记得折腾了一番最后没继续往下问了 数据结构：堆、栈、队列、链表、数组，有没有哪个没听过的？（我：没有）算法题：两个栈实现最大栈，要求pop, push, get_max都为O(1)（很经典了）我依稀记得有两种做法，一种辅助栈仅压入比栈顶大的元素（单调栈），一种是辅助栈每次都要压入，压入的是当前累计最大值我用的第一种，注意一下判断边界条件，如辅助栈为空的时候无需比较直接压入、栈为空的时候pop()应该返回None或其他特殊值、主栈要压入的元素等于辅助栈栈顶元素时，辅助栈是否要压入等 数据库，你觉得自己学到了什么程度？我：CRUD，索引多少了解一点面试官：那索引为什么能使查询变快？你描述一下索引是做什么的我：B+树，类似于如果数组无序，我们只能遍历，但如果建了多叉树（B+树），我们就可以快速搜索，复杂度log(m)n，m为分叉数面试官：复杂度是log(m)n？你怎么得出来的我：就像二叉树logn一样嘛面试官：你要注意在每个内部节点里面，决定走哪个分叉的时候，你平均情况下要检查m/2个值的，复杂度O(m)，所以总共并不是log(m)n我：是的，我算错了——3.1更新，感谢评论区老哥给出的思路，我自己尝试推了一遍，大家感兴趣可以戳 https://zhuanlan.zhihu.com/p/110202102 面试官：性别上建索引会怎么样？我：可选项太少，查完之后只能排除一半，还要继续扫描。如果用在联合索引里面，应该放最右边面试官：解释一下最左匹配原则（略）思考题：如果有A,B两个字段，两个都很常用，你是建联合索引（A,B）好，还是单独建（A）、(B)好？ 10分钟后二面二面：介绍一下你在上一家公司做的项目你用到了Elasticsearch，底层了解吗？（不了解）ES底层是什么引擎你知道吗？（Lucene）我实在是不懂ES，没有继续聊下去 算法题：马踏棋盘有44的棋盘，给定马的起点坐标i,j，可走步数N（起点算0步），走过的点可以重复走，求长度为N的所有可能路径数我：递归深搜，暴力写了十几分钟，成功运行了面试官：分析复杂度？我：如果不管棋盘大小，是O(8^N)，如果44，那么每个点最多只能有四个位置可走，O(4^N)面试官：为什么这么高复杂度？（我：有重复解）如何优化？我：可能剪枝或者DP吧，没想出来（实际上应该可以保存走过的状态，如对于(p, q, k)表示(p,q)这个坐标上还剩k步时这个子问题的解，后面可以复用） Python args *kwargs区别？我说我Java比Python熟写代码：Java中如何实现一个swap函数，交换数组中两个整数的值（略）原地实现？（a=a+b, b=a-b, a=a-b)你这个原地实现有一个缺陷，你知道是什么吗（两数相加可能会溢出）如何解决溢出？（没想到）——3.1更新 感谢评论区老哥提示，可以用异或交换整型或字符类型等可以表示为二进制串的变量，且不需要额外空间（原地）思路类似上面的原地交换，首先a和b异或（第一步肯定是这么干，不然没别的操作可做了），然后试图由a^b反推a：如果异或后的位是1，那么a的原位肯定和b的原位不一样；异或后为0，一定和b原位一样所以可以反推a，赋值给b最后再反推b的原值，赋值给a为什么用异或：位操作中，只有异或可以做到由异或后的值和其中一个原值反推另外一个原值（可以想想为什么） 如果是泛型，如何实现（我一开始只把类型换了，其他按原样）面试官：如果是两个Integer呢，你能成功交换它们的值么，运行试试我：发现并没有交换成功面试官：为什么（复制了引用，赋值修改的是引用，没能动到原来的值）面试官：怎么解决？（没想到）——2.29更新，用反射通过参数里的引用强行访问私有字段，可以实现参数为对象引用类型的swap。不过还有一个问题：如果对象字段除了基本类型外，还含有其他类型的对象呢？写一个深搜去递归拷贝？用序列化/clone方法？大家有想法可以贴在评论区 123456789101112public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123; Integer[] arr = new Integer[]&#123;1, 2&#125;; StringDemo.swap(arr[0], arr[1]); System.out.println(Arrays.toString(arr)); //[2,1]，交换成功 &#125; private static void swap(Integer a, Integer b) throws NoSuchFieldException, IllegalAccessException &#123; Class c = Integer.class; Field f = c.getDeclaredField(\"value\"); f.setAccessible(true); f.setInt(a, 2); f.setInt(b, 1); &#125; Java中使用枚举类有什么好处？我当时只讲了方便管理常量，比如一个表示星期几的枚举类enum Week{Monday, …, Sunday}可以通过Week week = Week.Monday的形式来调用，如果自己去定义final Monday=1的话，无法对week的取值作出限制，如果取了week=9可能会出现难以检查的错误，而枚举类的话不允许取枚举集合以外的值（除了null） Java在运行时有几个进程？提示一下吧，你说说Java线程，Java进程，Java在运行时在Linux中体现为什么进程，JVM又体现为什么？我：讲了一下线程和进程的区别，说没试过top去看执行java命令后会有哪些进程面试官：你说线程共享进程地址空间，这地址空间里面有什么？（我只想到了堆和方法区）进程通信的方式？（我：信号、管道、共享内存、socket）你说了信号，那信号有哪几种？分别怎么用？不知道，那你kill的时候用的是什么信号？ over，你有什么想问我的吗？我：求反馈和建议，您觉得我哪里不足该多学学面试官：你想学什么就去学，多学没坏处（2333） 两个面试官都挺和善的，我觉得要是挂了也有个教训，看面经不能光背答案，得看深看扎实一点等通知ing，感觉二面有点悬啊 Test9每个之间差不多隔5-10minTimeline：2.2投都简历 2.6电话约了2.19面试 2.24offer call一面：上来先问了之前实习的经历 让我具体讲讲项目 内容问的不是很细 就每个项目都大概问了一点 二面项目内容问的很细然后计算机网络 ，操作系统，linux，数据库 都问了 因为我主攻java 也问了java 我记得问过的问题如下：进程 线程的区别 以及各自的通信方式 内核对它们有区分吗？如何实现？ 在操作系统中 线程进程内部存储结构是怎么样的Linux进程调度算法主要有哪些 CFS高优先级进程可以被抢占吗fork操作具体执行了哪些事情 系统空间如何开辟的TCP与UDP的区别 TCP如何可靠传输 滑动窗口Http报问头部内容POST和GET区别Tcp特点 如何做的 三次握手 四次握手具体过程 还问了个拓展的 timeout 就是如果客户端数据还没发完 服务器以及关闭了通信 会发生什么情况如何处理高并发redis有用过吗 简单讲一下常见的服务器返回的状态码含义java虚拟机 java各个变量存储在什么位置然后就是字节的经典环节 手撕代码1.股票问题系列 dp 2.实现一个LRU leetcode刷过 3.3sum 二面：上来就是怼项目 问的非常细。。。 先让我讲了Rxjava原理 处理数据过程 然后让我讲讲base64编码然后问了项目里的spring IOC spring mvc然后问了 http请求 request内容具体放在什么位置session和cookie的区别服务器如何识别客户端的请求 如何识别不同的用户 这题我答了一堆。。。。但好像面试官给我的反馈不太对。应该是打错了。。。当时还以为凉了java的gc算法 gc回收机制 类的加载机制hashmap具体如何实现的 算法：单向链表，对折成1 -&gt;n-&gt;2-&gt;n-1-&gt;3……字节流中的中位数 （大小堆） hr面： 没有问啥技术问题就大概问了能实习的时间 然后聊了聊生活。。。。问生活中我是个怎样的人。。。身边的人如何看自己。。。自己在团队中作用差不多hr面了大概20min左右 就结束了 让我回去等结果 Test10 自我介绍。 介绍项目是怎么设计的，如何实现。 微信扫码登录有了解吗？如何实现。 如何上锁？java方面sychronized和reentrylock，数据库for update加互斥锁。 数据库事务类型？ Mysql支持事务吗？我说看存储引擎，innodb支持，myisam不支持。 innodb索引存储结构？B+树 B+树和B树区别？ 有联合索引a_b_c，查询条件where b=1 and a=1，走不走索引？我说最左匹配原则，可以使用索引。 redis几种数据结构？ zset的底层？字典和跳表。 zset添加元素的时间复杂度，为什么？我说logn，n是节点的个数（感觉好像不太对）。 计算机网络结构介绍一下？tcp/ip协议的分层概念。 ip协议是干嘛的？我说找主机用的（我也不知道。。。。）。 挥手为什么要比握手多一次？我说握手的时候服务器是准备好的，没有必要多发一次tcp消息，因为握手挥手阶段基本没有数据传输，加大了信道负载。 get和post的区别？get和post都是http1.0版本的方法，get用于查询，post用于修改，get传输数据小于post。 springboot是干吗的？springboot可以简化spring的配置，避免写大量的xml。 spring你觉得解决了什么问题？我说用来管理对象，避免自己手动管理。 hashtable和hashmap有什么区别？前者继承dictionary，后者继承abstractmap，巴拉巴拉。20 最关键的区别是什么？线程安全。21 hashtable和concurrentmap的区别。前者锁力度大，锁整个对象，后者只锁头结点。22 只锁头结点？1.7之前锁segment，1.8之后锁头结点。23 hashmap的实现？ 数组+链表。 陆续记起来的一些问题： 分布式锁了解吗？我说了一下redis里面通过setnx，比如说10台机器，获取一半机器的锁就认为获得锁了，但是可能存在一些问题，比如每个机器时间是不同步（这里主要涉及锁的释放问题，比如客户端宕机了，自己说了一堆感觉越说越不对，不过面试官也没说什么） session和cookie的区别？我说http是无状态的，但是一些需求比如购物车需要保存数据，巴拉巴拉的（面试官说这跟问题没有关系)，后面我就说服务器保存session，客户端的cookie中保存sessionid，服务器根据sessionid获取用户信息。算法题：有n(n&lt;=10^8)个整数的无序数组 [1, 8, 6, 5, 3, 2, 9, 7]，找出每个元素右边最近大于当前元素的数, 不存在则输出-1，要求时间复杂度O(N)。输入：[1, 8, 6, 5, 3, 2, 9, 7]输出：[8, 9, 9, 9, 9, 9, -1, -1] 第一时间以为是找右边大于当前元素数量，心想怎么是个hard题。后来发现不是。又以为是循环数组，后来发现又不是。最后说用stack来解决，面试官就说你写一下吧，10分钟。 Test111.数据库索引结构2.B树和B+树的区别3.进程和线程区别4.线程状态5.进程间通信方式6.未命名管道和命名管道区别7.讲讲共享内存8.讲讲Hashmap9.Hashmap线程安全吗？举例说明，特别是在扩容时会出现什么情况10.单例模式(写了一个双重锁的)11.TCP和UDP的区别12.TCP可以提供哪些可靠传输13.拥塞控制机制和流量控制14.synchronized是基于什么实现的15.算法题(紧张，没思路，主要是刷题太少)给一个不重复数组，列举出它的全排列 Test121.首先撕了两道算法题：第一题：最长不重复子序列长度第一题想到是用动态规划奈何打不出来，我真是菜的一批 然后面试官说你和我说说思路我就把思路告诉他了 应该是力扣上的题但是我只刷了剑指offer，看来以后还是要多刷题然后他说再出一道简单的吧第二题是将数组中所有的零都放到数组末尾 一看挺简单的我直接用冒泡写了 可能当时太紧张了就是编译不过去 面试官问了我思路就过了（两道算法题大概用了43分钟）2.聚集索引和非聚集索引的区别(我结合了mysql的两个引擎来说的)3.innodb索引的数据结构,b+树的优点4.建表主键怎么决定（我不太确定他的意思，我就说设的自增，然后他问为什么要用自增，我想了一下说因为自增排好序了，所以方便查找）5.事务隔离级别6.幻读的概念，幻读和不可重复读区别（一个是update,一个是insert）7.说一下mvcc的概念，实现的原理，解决的问题8.写了一个sql，查询所有平均成绩大于60的同学9.问了如果不用where student.id=score.id会发生什么情况10.redis常用数据类型及底层11.redis持久化方式及区别（aof和rdb）12.tcp四次挥手，为什么等待2msl13.https的加密过程（对称+非对称）,为什么传输的时候要用对称加密（我不太确定，说因为非对称要不断解密加密会浪费资源）14.说一下springcloud的注册中心15.负载均衡策略，ribbon用到的是哪种（轮询）16.如果运行过程中有一个实例挂掉了会出现什么情况（我一开始以为是服务雪崩，后来发现他问的不是这个意思，然后我说eureka有失效剔除+心跳续约）17.服务熔断和服务降级18.注册中心怎么保证自己的高可用，怎么保证一致性，一致性算法面了80分钟，然后就问我还有什么要问他的，我本来以为自己两道算法没写出来肯定是挂了，后来问面试官什么时候能给我答复，他说一会hr会联系我二面，过了大概二十分钟就开始二面了 二面二面的问题很少而且都挺基础，因为我没有录音所以有些忘了1.hashmap 我想往深了说，面试官没往深了问2.深拷贝浅拷贝3.值传递和引用传递4.gc5.死锁6.线程之间的同步方式7.java基本数据类型和他们的占用空间大小8.算法（又是算法）题目：三十六进制加法，要求不能转化成十进制 因为感冒+头疼+之前算法没写出来心里还是很慌，结果就是这道算法又没能跑起来 后来面试官问我思路我说我用的asc11码-’a‘来确定每个字母的值，然后我开了一个数组保存结果，两个字符串转化为字符数组，从最后一个数字开始加，大于36进位，结果数组保存余数（没实现出来但是后来百度发现我的思路好像能解出来）最后说他的问题问完了，hr会在几天内给我回复我觉得我三道算法题没写出来，大概率是凉了，有时候就觉得为什么别人面试的算法我都会，轮到自己就写不出来呢，我觉得运气是一部分，但是更主要的还是因为自己的基础不够好吧，从现在开始好好刷题，明年再战头条！！ 把0放到数组尾部应该是双指针，一个头一个尾同时往中间走，如果a[i] == 0 并且a[j] != 0 就交换如果前面等于0后面也等于0，j–，如果前面不等于0，无论后面值为多少，前面的i就++#includeusing namespace std;const int N = 100010;int a[N];int main(){ int n; cin &gt;&gt; n; for(int i = 0;i &lt; n;i++ ) cin &gt;&gt; a[i]; int i = 0,j = n - 1; while(i &lt; j){ if(a[i] == 0){ if(a[j] != 0){ swap(a[i],a[j]); i++; j–; } if(a[j] == 0) j–; } if(a[i] != 0) i++; } for(int i = 0;i &lt; n;i++ )cout &lt;&lt; a[i] &lt;&lt; “ “; }！","categories":[{"name":"面试","slug":"面试","permalink":"https://lijiale96.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"字节跳动","slug":"字节跳动","permalink":"https://lijiale96.github.io/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/"}]},{"title":"牛客综合整理2","slug":"牛客综合2","date":"2020-03-11T14:12:00.000Z","updated":"2020-03-10T17:16:11.902Z","comments":true,"path":"2020/03/11/牛客综合2/","link":"","permalink":"https://lijiale96.github.io/2020/03/11/%E7%89%9B%E5%AE%A2%E7%BB%BC%E5%90%882/","excerpt":"2020/3/10综合第2套1、应用层的协议有：文件传送协议 FTP超文本传送协议HTTP简单电子邮件传送协议SMTP邮件读取协议POP3/IMAP动态主机配置协议DHCP简单网络配置协议SNMP 运输层的协议有:用户数据报协议UDP传输控制协议TCP停止等待协议连续ARQ协议","text":"2020/3/10综合第2套1、应用层的协议有：文件传送协议 FTP超文本传送协议HTTP简单电子邮件传送协议SMTP邮件读取协议POP3/IMAP动态主机配置协议DHCP简单网络配置协议SNMP 运输层的协议有:用户数据报协议UDP传输控制协议TCP停止等待协议连续ARQ协议 网络层的协议有：网际协议IP地址解析协议ARP国际控制报文协议ICMP内部网关协议RIP /OSPF外部网关协议BGP 数据链路层协议有：点对点协议PPPCSMA/CD协议 2、TCP四次握手由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。（2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。 URG：urgent，意思是优先级高，发送端优先发送，而不是在缓存中排队。ACK：acknowledge，1意味着确认建立了会话，0代表确认好无效。PSH：1意味着接收端优先读取，而不是在缓存中排队。RST：reset，1意味着TCP会话出现严重错误，必须释放和重新连接。SYN：同步。1意味着要发起会话。FIN：finish，1意味着释放连接。 3、%和都为通配符，而 “%”表示0个或多个字符 ，“_”则表示一个字符，查倒数第三个字符W，所以应该是W__，但是要求要至少包含4个字符，所以在W前面添加%，又必须有一个所以就多加了一个”“。 4、一种适用于外查找的树，它是一种平衡的多叉树，称为B树（或B-树、B_树）。一棵m阶B树(balanced tree of order m)是一棵平衡的m路搜索树。它或者是空树，或者是满足下列性质的树： 根结点至少有两个子女； 每个非根节点所包含的关键字个数 j 满足：┌m/2┐ - 1 &lt;= j &lt;= m - 1； 除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故内部子树个数 k 满足：┌m/2┐ &lt;= k &lt;= m ； 所有的叶子结点都位于同一层 5、数据库中删除约束的方法： sql server中删除约束的语句是：alter table 表名 drop constraint 约束名sp_helpconstraint 表名 找到数据表中的所有列的约束 oracle中删除约束的语句：先找到表的约束名称，执行：select * from user_constraints； 其中 CONSTRAINT_NAME 为表的约束名称然后删除约束：alter table 表名 drop constraint 约束名 cascade; mysql中删除约束的语句是：1）删除主键约束：alter table 表名 drop primary key;2）删除外键约束：alter table 表名 drop foreign key 外键（区分大小写）; 6、在多道程序系统中，系统的现有空闲可用资源能否满足后备作业J的资源要求，是选择作业J进入内存的充分不必要条件 7、A类地址中的私有地址和保留地址：①10.0.0.0到10.255.255.255是私有地址（所谓的私有地址就是在互联网上不使用，而被用在局域网络中的地址）。 ② 127.0.0.0到127.255.255.255是保留地址，用做循环测试用的。 B类地址的私有地址和保留地址 ① 172.16.0.0到172.31.255.255是私有地址 ②169.254.0.0到169.254.255.255是保留地址。 C类地址中的私有地址：192.168.0.0到192.168.255.255是私有地址8、无向图： 完全无向图： 最多n(n-1)/2条边， 顶点表结点： n个顶点就有n个表结点 边表节点： n(n-1)个 表结点： n + n(n-1)=n^2个 有n个顶点的无向图最多有n(n-1)/2条边，此时为完全无向图，而在邻接表中每条边存储两次，所以有n（n-1)个结点9、算法的时间复杂度是指执行算法所需要的计算工作量。为了能够比较客观地反映出一个算法的效率，在度量一个算法的工作量时，不仅应该与所使用的计算机、程序设计语言以及程序编制者无关，而且还应该与算法实现过程中的许多细节无关。为此，可以用算法在执行过程中所需基本运算的执行次数来度量算法的工作量。算法所执行的基本运算次数还与问题的规模有关；*对应一个固定的规模，算法所执行的基本运算次数还可能与特定的输入有关。**10、关于物理层、数据链路层、网络层设备对于隔离冲突域的总结： 设备名称 能否隔离冲突域 集线器 不 中继器 不 j交换机 能 网桥 能 路由器 能 交换机（Switch）可以隔离冲突域，但集线器（Hub）无法隔离冲突域，因此从物理层上能够收到该确认帧的主机仅H2、H311、射频技术是非接触式的自动识别技术，通过射频信号自动识别目标对象并获取相关数据。12、全1的地址只在本网络上进行广播。目的地址为全1代表的是本机所在网络的全部主机。源地址不能用全1的地址，因为如果用的话无法知晓数据报究竟是哪台主机发送来的。在IP地址中全1的地址表示仅在本网络上（就是发送这个IP数据报的主机所连接的局域网）进行广播，这种广播也叫受限的广播。而不是向整个因特网进行广播，假设如果真的是向整个因特网进行广播，那么一定会在网络上产生巨大的通信量，会严重影响因特网的正常工作。13、树: 确定树的根节点：“先序的首字符” 和 “后序的尾字符”相同，为树的根节点； 判断树的左、右子树节点集合：设先序顺序为 “根 - 左右(A)”，后序顺序为 “左右(B) - 根”，则 A 的首字符A-Head为某子树的根节点（如果两子树均存在，它是左树的根，但是如果有一棵子树不存在，那边我们就无法判断它是谁的根），在B序列中找出A-Head的位置，若B中A-Head位于尾部，则说明有一棵子树为空（但是我们无法判断是左还是右，画图时需要以竖直向下的边连接根与子树，表明子树的左右位置无法确定），而若A-Head位于B中间的某个位置，则该位置便是左右子树序列的分界点，左右子树的节点序列由此确定； 递归判断：左右子树的序列与主序列具有相同性质，递归直至确定了叶子节点；本题还原出来的二叉树结构如下图所示，它的层次遍历序列是确定的，但是中序遍历序列由于无法确定节点b关于a的左右位置，b在左，则b先输出，b在右，则a先输出，所以本题选项A、B均正确：14、系统中独占设备的数量有限，往往不能满足系统中多个进程的需要，从而成为系统的瓶颈，使许多进程因等待而阻塞。另一方面分配到独占设备的进程，在整个运行期间往往占有但不经常使用设备，使设备利用率偏低。为了克服这种缺点，人们通过共享设备来虚拟独占设备，讲独占设备改造成共享设备，从而提高设备的利用率和系统的效率，该技术威假脱机技术。所以需要用到共享设备，虚拟设备，独占设备。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://lijiale96.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lijiale96.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"操作系统","slug":"操作系统","permalink":"https://lijiale96.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"编程基础","slug":"编程基础","permalink":"https://lijiale96.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"数据结构","slug":"数据结构","permalink":"https://lijiale96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"数据库","slug":"数据库","permalink":"https://lijiale96.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://lijiale96.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://lijiale96.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"牛客综合整理1","slug":"牛客综合1","date":"2020-03-10T14:12:00.000Z","updated":"2020-03-10T17:16:13.544Z","comments":true,"path":"2020/03/10/牛客综合1/","link":"","permalink":"https://lijiale96.github.io/2020/03/10/%E7%89%9B%E5%AE%A2%E7%BB%BC%E5%90%881/","excerpt":"2020/3/9综合第1套1、一种排序算法适合于某种特定的数据环境，有时对排序的稳定性没有要求。常见的不稳定排序算法有：快速排序、希尔排序、选择排序、堆排序（速记方法：快些选堆）。eg：①假设有5000个元素，希望用最快速度挑出10个最大元素，这个时候堆排序就可以很好地解决问题。②快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；因此不能说不稳定的排序方法没有实际意义。","text":"2020/3/9综合第1套1、一种排序算法适合于某种特定的数据环境，有时对排序的稳定性没有要求。常见的不稳定排序算法有：快速排序、希尔排序、选择排序、堆排序（速记方法：快些选堆）。eg：①假设有5000个元素，希望用最快速度挑出10个最大元素，这个时候堆排序就可以很好地解决问题。②快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；因此不能说不稳定的排序方法没有实际意义。 2、活锁就是事务T有可能永远等待，而死锁是指T1和T2 两个事务永远不能结束3、wait、signal 初值为3，，当前值为-1，有多少等待进程信号量表示的是可用的资源数。初值为3，表示初始时有3个可用的资源。现在为-1，说明这3个可用资源已经被占用了，而且有一个进程在等待资源，所以就为-1了4、文件目录项中包括文件控制块，但是不存放文件控制块的物理位置，是实体5、双端口存储器同一个存储器具有两组相互独立的读写控制线路,由于进行并行的独立操作，是一种高速工作的存储器。相联存储器是一种不根据地址而是根据存储内容来进行存取的存储器，可以实现快速地查找块表。既可以按照地址寻址也可以按照内容寻址(通常是某些字段)，为了与传统寄存器作区别，称为按内容寻址的存储器。交叉存储器其存储模块都有相同的容量和存储速度，各模块都有各自独立地址寄存器(MAR)、数据寄存器(MDR)、地址译码、驱动电路和读/写电路。串行存储器，串行EEPROM存储器，支持I2C（中间的2是平方）总线数据传输协议。EEPROM是电可擦除只读存储器。6、只有出现并发操作时，才有可能出现死锁7、你首先要明白的是什么是长度：数组元素的个数称之为数组的长度。 现在再看问题 第一个是 字符串，第二个是字符数组 ，字符串以’\\0’为结束符号，字符数组不用。 要说明的是，虽然他们长度相同，不过占的内存字节数是不一样的，第一个占7个字节（后面的’\\0’占一个。）第二个占6个字节。8、ACID A原子 C一致 I隔离 D持久9、（1） 互斥条件：一个资源每次只能被一个进程使用。 不可破坏（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 一次性分配：要么全给，要么啥也不给。（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。 设置优先级，高优先级可要求低优先级让出资源。（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 对资源进行编号，按照编号顺序申请访问10、总线的带宽是数据在总线传输的速度，是用字节每秒做单位的。总线的频率的大小决定着总线的带宽，不过一般上还有个位宽的概念。总线的频率 * 位宽 /8 = 总线的带宽总线带宽是主板南北桥的数据传输速度，是数据在主板上每秒钟传送的信息量。11、/bin 存放普通用户可以使用的指令。/usr 这个目录中包含了命令库文件和在通常操作中不会修改的文件，其地位类似Windows上面的”Program Files”目录（安装程序的时候，默认就是安装在此文件内部某个子文件夹内。输入命令后系统默认执行/usr/bin下的程序。/etc 全局的配置文件存放目录。存放系统和软件的配置。/boot 引导程序，内核等存放的目录12、最先适应算法：依次判定后找到第一个满足要求的哈最佳适应算法：对空闲区按从小到大排序，第一个满足的就是啦最差适应算法：对空闲区按从大到小排序，第一个满足的就是啦固定式分区算法：是分区的13、点阵就是一个二进制位表示一个点,于是2424点阵需要2424个二进制位,一个字节是8个位,所以一个汉字需要2424/8=72字节, 你有1024个汉字,那当然就是((2424)/8)*102414、fork(); //执行后有2个进程printf(“-\\n”); //打印2次fork(); //2翻倍为4printf(“-\\n”); //打印4次fork(); //4翻倍为8printf(“-\\n”); //打印8次fork(); //8翻倍为16printf(“-\\n”); //打印16次2+4+8+16 = 3015、 12345678910111213void foo(int n, int x, int y)&#123; int z = 0; if (n &lt;= 0) &#123; z = x + y; &#125; else &#123; foo(n - 1, x + 1, y); foo(n - 1, x, y + 1); &#125;&#125; T(n)=T(n-1)+T(n-1)=2T(n-1)=…=2^n * T(1)16、表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。数据结构标准，EBCDIC（extended binary coded decimal interchange code）、ASCII（Amercia Standard Code for Information Interchange）；图像标准：JPEG（Joint Photographic Experts Group）、TIFF（Tagged Image File Format）、GIF、PICT；视频标准：MIDI（Musical Instrument Digital Interface）、MPEG（Motion Picture Experts Group）、QuickTime、 等。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://lijiale96.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lijiale96.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"操作系统","slug":"操作系统","permalink":"https://lijiale96.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"编程基础","slug":"编程基础","permalink":"https://lijiale96.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"数据结构","slug":"数据结构","permalink":"https://lijiale96.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"数据库","slug":"数据库","permalink":"https://lijiale96.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://lijiale96.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://lijiale96.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"算法笔记1","slug":"算法笔记1","date":"2020-03-10T13:00:15.000Z","updated":"2020-03-14T14:22:40.848Z","comments":true,"path":"2020/03/10/算法笔记1/","link":"","permalink":"https://lijiale96.github.io/2020/03/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B01/","excerpt":"1、第一章 经典算法1 字符串匹配问题 1） str1=“李李李家乐”和str2=“李家乐” 2） str1是否含有str2，若存在，若不存在，则返回-1 3） 最快速度 4） 思路 暴力匹配（简单，效率低） KMP算法 部分匹配表 汉诺塔 分治算法 八皇后问题 引出递归（回溯算法） 8*8 不能同一列或斜线 92——&gt;分治算法","text":"1、第一章 经典算法1 字符串匹配问题 1） str1=“李李李家乐”和str2=“李家乐” 2） str1是否含有str2，若存在，若不存在，则返回-1 3） 最快速度 4） 思路 暴力匹配（简单，效率低） KMP算法 部分匹配表 汉诺塔 分治算法 八皇后问题 引出递归（回溯算法） 8*8 不能同一列或斜线 92——&gt;分治算法 2、经典算法2 马踏算法 图的深度优化遍历算法DFS + 贪心算法优化 3、内容4、第二章 数据结构和算法的关系程序=数据结构+算法数据结构是算法的基础 5、实际问题修路问题 ——&gt; 最小生成树（普利姆算法）最短路径问题 ——&gt; 佛洛伊德算法 6、线性、非线性结构线性结构1） 元素之间一对一2） 顺序和链式存储结构 ，顺序存储结构（数组） 存储元素连续3） 链式存储的线性表是链表，存储元素不一定连续4） 数组、队列、链表和栈 非线性结构二维数组，多为数组，广义表，树结构、图结构 7、 第三章 稀疏数组应用场景基本介绍大部分为0，或者同一个值得数组 处理方法 几行几列，多少不同的值 把不同的元素行列及值记录咋有个小规模的数组中，缩小程序 8、稀疏数组转换思路1 使用稀疏数组，来保留类似前面的二维数组2 把稀数组存盘，并且可以从新恢复原来的二维数组数3 整体思路分析 二维数组转稀疏数组思路1、遍历原始，得到有效数据的个数sum2、根据sum就可以创建稀疏数组 sparseArr int【sum+1】【3】3、将二维数组的有效数据存入到稀疏数组 稀疏数组转原始的二维数组的思路1、先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组2、在读取稀疏数组后几行的数据，并赋给原始的二维数组 9、稀疏数组的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.atguigu.sparsearray;public class SparseArray &#123; public static void main(String[] args) &#123; //创建一个原始的二维数组 11*11 //0：表示满意棋子，1表示黑子，2表示蓝子 int chessArr1[][] = new int[11][11]; chessArr1[1][2] = 1; chessArr1[2][3] = 1; chessArr1[4][5] = 2; //输出原始的二维数组 System.out.println(\"原始的二维数组\"); for (int[] row : chessArr1) &#123; for (int data : row) &#123; System.out.printf(\"%d\\t\", data); &#125; System.out.println(); &#125; //将二维数组 转 稀疏数组的思路 int sum = 0; for (int i = 0; i &lt; 11; i++) &#123; for (int j = 0; j &lt; 11; j++) &#123; if (chessArr1[i][j] != 0) &#123; sum++; &#125; &#125; &#125; System.out.println(\"sum=\" + sum); //2、创建对应的稀疏数组 int sparseArr[][] = new int[sum + 1][3]; //给稀疏数组赋值 sparseArr[0][0] = 11; sparseArr[0][1] = 11; sparseArr[0][2] = sum; // 遍历二维数组，将非0的值存放到sparseArr中 int count = 0; //count 用于记录是第几个非0数据 for (int i = 0; i &lt; 11; i++) &#123; for (int j = 0; j &lt; 11; j++) &#123; if (chessArr1[i][j] != 0) &#123; count++; sparseArr[count][0] = i; sparseArr[count][1] = j; sparseArr[count][2] = chessArr1[i][j]; &#125; &#125; &#125; //输出稀疏数组的形式 System.out.println(); System.out.println(\"得到稀疏数组为~~~~~~\"); for (int i = 0; i &lt; sparseArr.length; i++) &#123; System.out.printf(\"%d\\t%d\\t%d\\t\\n\", sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]); &#125; System.out.println(); /** * 稀疏数组转原始的二维数组的思路 * 1、先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组 * 2、在读取稀疏数组后几行的数据，并赋给原始的二维数组 */ //1、先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组 int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]]; //2. 在读取稀数组后几行的数据(从第二行开始），并赋给原始的二维数组即可 for (int i=1;i&lt;sparseArr.length;i++)&#123; chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2]; &#125; //输出恢复后的二维数组 System.out.println(); System.out.println(\"恢复后的二维数组\"); for (int[] row : chessArr2) &#123; for (int data : row) &#123; System.out.printf(\"%d\\t\", data); &#125; System.out.println(); &#125; &#125;&#125; 课后作业： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160package com.atguigu.sparsearray;import java.io.*;import java.util.ArrayList;public class SparseArray &#123; public static void main(String[] args) throws FileNotFoundException &#123; //创建一个原始的二维数组 11*11 //0：表示满意棋子，1表示黑子，2表示蓝子 int chessArr1[][] = new int[11][11]; chessArr1[1][2] = 1; chessArr1[2][3] = 1; chessArr1[4][5] = 2; chessArr1[1][5] = 1; chessArr1[5][5] = 1; chessArr1[2][5] = 2; //输出原始的二维数组 System.out.println(\"原始的二维数组\"); for (int[] row : chessArr1) &#123; for (int data : row) &#123; System.out.printf(\"%d\\t\", data); &#125; System.out.println(); &#125; //将二维数组 转 稀疏数组的思路 int sum = 0; for (int i = 0; i &lt; 11; i++) &#123; for (int j = 0; j &lt; 11; j++) &#123; if (chessArr1[i][j] != 0) &#123; sum++; &#125; &#125; &#125; System.out.println(\"sum=\" + sum); //2、创建对应的稀疏数组 int sparseArr[][] = new int[sum + 1][3]; //给稀疏数组赋值 sparseArr[0][0] = 11; sparseArr[0][1] = 11; sparseArr[0][2] = sum; // 遍历二维数组，将非0的值存放到sparseArr中 int count = 0; //count 用于记录是第几个非0数据 for (int i = 0; i &lt; 11; i++) &#123; for (int j = 0; j &lt; 11; j++) &#123; if (chessArr1[i][j] != 0) &#123; count++; sparseArr[count][0] = i; sparseArr[count][1] = j; sparseArr[count][2] = chessArr1[i][j]; &#125; &#125; &#125; //输出稀疏数组的形式 System.out.println(); System.out.println(\"得到稀疏数组为~~~~~~\"); for (int i = 0; i &lt; sparseArr.length; i++) &#123; System.out.printf(\"%d\\t%d\\t%d\\t\\n\", sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]); &#125; testo(sparseArr); testi(sum); /** * 稀疏数组转原始的二维数组的思路 * 1、先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组 * 2、在读取稀疏数组后几行的数据，并赋给原始的二维数组 */ //1、先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组 int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]]; //2. 在读取稀数组后几行的数据(从第二行开始），并赋给原始的二维数组即可 for (int i=1;i&lt;sparseArr.length;i++)&#123; chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2]; &#125; //输出恢复后的二维数组 System.out.println(); System.out.println(\"恢复后的二维数组\"); for (int[] row : chessArr2) &#123; for (int data : row) &#123; System.out.printf(\"%d\\t\", data); &#125; System.out.println(); &#125; &#125; public static void testo(int[][] sparseArr)&#123; /** * 将稀疏数组保存到磁盘,利用IO流将稀疏数组写入map文件 */ System.out.println(\"将稀疏数组保存到磁盘,利用IO流将稀疏数组写入map文件！！！！\"); FileWriter writer = null; try &#123; writer = new FileWriter(\"map.txt\"); for(int i =0; i &lt; sparseArr.length; i++) &#123; for(int j = 0; j &lt; 3; j++) &#123; writer.write(sparseArr[i][j]); &#125; &#125; writer.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if(writer != null) &#123; writer.close(); &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; private static void testi(int sum)&#123; /** * 从磁盘读将稀疏数组 */ System.out.println(); System.out.print(\"再从磁盘读将稀疏数组,\"); System.out.println(\"那么读取后稀疏数组为：\"); FileReader reader = null; int[][] sparseArr2 = new int[sum+1][3]; int getNum = 0; try &#123; reader = new FileReader(\"map.txt\"); for(int i =0; i &lt; sparseArr2.length; i++) &#123; for(int j =0; j &lt; 3; j++) &#123; getNum = reader.read(); sparseArr2[i][j] = getNum; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if(reader != null) &#123; reader.close(); &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; for(int i =0; i &lt; sparseArr2.length; i++) &#123; System.out.printf(\"%d\\t%d\\t%d\\n\", sparseArr2[i][0],sparseArr2[i][1],sparseArr2[i][2]); &#125; //输出一下的稀疏数组 System.out.println(); &#125; &#125; 10、队列1、介绍1）有序，数组或链表2）先入先出 2、数组模拟队列思路front、rear addQueue 步骤： 尾指针后移：rear+1，当front=rear 空 尾指针rear小于队列的最大下标maxSize-1，则数据存入rear所指的的数组元素中，否则无法存入数据。 rear = maxSize-1 队列满 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121package com.atguigu.queue;import java.util.Scanner;public class queue &#123; public static void main(String[] args) &#123; //测试 //创建一个队列 ArrayQueue queue = new ArrayQueue(3); char key = ' ';//接收用户输入 Scanner scanner = new Scanner(System.in); // boolean loop = true; //输出一个菜单 while (loop) &#123; System.out.println(\"s(show):显示队列\"); System.out.println(\"e(exit):退出程序\"); System.out.println(\"a(add):添加数据到队列\"); System.out.println(\"g(get):从队列取出数据\"); System.out.println(\"h(head):查看队列头的数据\"); key = scanner.next().charAt(0);//接收一个字符 switch (key) &#123; case 's': queue.showQueue(); break; case 'a': System.out.println(\"输出一个数\"); int value = scanner.nextInt(); queue.addQueue(value); break; case 'g': //取出数据 try &#123; int res = queue.getQueue(); System.out.printf(\"取出的数据是%d\\n\", res); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case 'h'://查看队列头的数据 try &#123; int res = queue.headQueue(); System.out.printf(\"队列头的数据是%d\\n\", res); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case 'e'://退出 scanner.close(); loop = false; default: break; &#125; &#125; System.out.println(\"程序退出\"); &#125; //使用数组模拟队列~编写一个ArrayQueue类 static class ArrayQueue &#123; private int maxSize;//表示数组的最大容量 private int front; //队列头 private int rear;//队列尾 private int[] arr; //该数据用于存放数据，模拟队列 //创建队列的构造器 public ArrayQueue(int arrMaxSize) &#123; maxSize = arrMaxSize; arr = new int[maxSize]; front = -1;//指向队列头部,分析出front是指向队列头的前一个位置 rear = -1;//指向队列尾，指向队列尾的数据（即就是队列最后一个数据） &#125; //判断队列是否满 public Boolean isFull()&#123; return rear == maxSize - 1; &#125; //判断队列是否空 public Boolean isEmpty()&#123; return rear == front; &#125; //添加数据到队列 public void addQueue(int n) &#123; //判断队列是否满 if (isFull()) &#123; System.out.println(\"队列满，不能加入数据\"); return; &#125; rear++; arr[rear] = n; &#125; //获取队列的数据，出队列 public int getQueue() &#123; //判断队列是否为空 if (isEmpty()) &#123; //通过抛出异常 throw new RuntimeException(\"队列空，不能取数据\"); &#125; front++;//front后移 return arr[front]; &#125; //显示队列的所有数据 public void showQueue() &#123; //遍历 if (isEmpty()) &#123; System.out.println(\"队列空的，没有数据~~\"); return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.printf(\"arr[%d]=%d\\n\", i, arr[i]); &#125; &#125; //显示队列的头数据，注意取出数据 public int headQueue() &#123; //判断 if (isEmpty()) &#123; throw new RuntimeException(\"队列是空的，没有数据~\"); &#125; return arr[front + 1]; &#125; &#125;&#125; 优化：1）不能复用2）环形的队列，取模：% 3、数组模拟环形队列分析1）尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定，这个在做判断队列慢的时候需要注意（rear+1）%maxSize==front 【满】2） rear==front 【空】3）示意图 front指向队列第一个元素 初始值=0 rear指向队列的最后一个元素的后一个位置 空出一个空间作为约定，初始值=0 满：（rear+1）%maxSize==front 空： rear==front 有效数据的个数：（rear+maxSize-front）%maxSize 注：这个约定是动态的 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143package com.atguigu.queue;import java.util.Scanner;public class CircleArrayQueue &#123; public static void main(String[] args) &#123; //创建一个环形队列 CircleArray queue = new CircleArray(4);//4，队列有效数据个数的为3 char key = ' ';//接收用户输入 Scanner scanner = new Scanner(System.in); // boolean loop = true; //输出一个菜单 while (loop) &#123; System.out.println(\"s(show):显示队列\"); System.out.println(\"e(exit):退出程序\"); System.out.println(\"a(add):添加数据到队列\"); System.out.println(\"g(get):从队列取出数据\"); System.out.println(\"h(head):查看队列头的数据\"); key = scanner.next().charAt(0);//接收一个字符 switch (key) &#123; case 's': queue.showQueue(); break; case 'a': System.out.println(\"输出一个数\"); int value = scanner.nextInt(); queue.addQueue(value); break; case 'g': //取出数据 try &#123; int res = queue.getQueue(); System.out.printf(\"取出的数据是%d\\n\", res); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case 'h'://查看队列头的数据 try &#123; int res = queue.headQueue(); System.out.printf(\"队列头的数据是%d\\n\", res); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case 'e'://退出 scanner.close(); loop = false; default: break; &#125; &#125; System.out.println(\"程序退出\"); System.out.println(\"测试数组模拟环形队列的案例\"); &#125; static class CircleArray &#123; private int maxSize;//表示数组的最大容量 // front指向队列第一个元素 初始值=0 private int front; //队列头 //rear指向队列的最后一个元素的后一个位置 初始值=0 private int rear;//队列尾 private int[] arr; //该数据用于存放数据，模拟队列 public CircleArray(int arrMaxSize)&#123; maxSize = arrMaxSize; arr = new int[maxSize]; &#125; //判断队列是否满 public Boolean isFull()&#123; return (rear+1) % maxSize == front; &#125; //判断队列是否空 public Boolean isEmpty()&#123; return rear == front; &#125; //添加数据到队列 public void addQueue(int n) &#123; //判断队列是否满 if (isFull()) &#123; System.out.println(\"队列满，不能加入数据\"); return; &#125; //直接将数据加入 arr[rear]=n; //将rear后移，这里必须考虑取模 rear=(rear+1)%maxSize; &#125; //获取队列的数据，出队列 public int getQueue() &#123; //判断队列是否为空 if (isEmpty()) &#123; //通过抛出异常 throw new RuntimeException(\"队列空，不能取数据\"); &#125; //这里需要分析出front是指向队列的第一个元素 //1.先把front对应的值保留到一个临时变量 //2.将front后移,考虑取模 //3.将临时保存的变量返回 int value = arr[front]; front=(front+1)%maxSize; return value; &#125; //显示队列的所有数据 public void showQueue() &#123; //遍历 if (isEmpty()) &#123; System.out.println(\"队列空的，没有数据~~\"); return; &#125; //思路：从front开始遍历，遍历多少个元素 for (int i = front; i &lt; front+size(); i++) &#123; System.out.printf(\"arr[%d]=%d\\n\", i%maxSize, arr[i%maxSize]); //环形 &#125; &#125; //求出当前队列有效数据的个数 public int size()&#123; //rear=2 //front=1 //maxSize=3 return (rear+maxSize-front)%maxSize; &#125; //显示队列的头数据，注意取出数据 public int headQueue() &#123; //判断 if (isEmpty()) &#123; throw new RuntimeException(\"队列是空的，没有数据~\"); &#125; return arr[front]; &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://lijiale96.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"稀疏数组","slug":"稀疏数组","permalink":"https://lijiale96.github.io/tags/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"},{"name":"队列","slug":"队列","permalink":"https://lijiale96.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"环形队列","slug":"环形队列","permalink":"https://lijiale96.github.io/tags/%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97/"}]},{"title":"Redis笔记1","slug":"Redis笔记1","date":"2020-03-10T03:39:53.000Z","updated":"2020-05-10T14:08:36.946Z","comments":true,"path":"2020/03/10/Redis笔记1/","link":"","permalink":"https://lijiale96.github.io/2020/03/10/Redis%E7%AC%94%E8%AE%B01/","excerpt":"1、技术分类解决功能性Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN 解决扩展性Struts、Spring、SpringMVC、Hibernate、Mybatis 解决性能NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch 应用层服务器：cpu压力数据库服务器：IO压力","text":"1、技术分类解决功能性Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN 解决扩展性Struts、Spring、SpringMVC、Hibernate、Mybatis 解决性能NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch 应用层服务器：cpu压力数据库服务器：IO压力 解决session存储问题会话（Session）跟踪： 会话，指用户登录网站后的一系列动作，比如浏览商品添加到购物车并购买。会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。 cookie 由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。用户A购买了一件商品放入购物车内，当再次购买商品时服务器已经无法判断该购买行为是属于用户A的会话还是用户B的会话了。怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie 的工作原理。 Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。每个用户访问服务器都会建立一个session，那服务器是怎么标识用户的唯一身份呢？事实上，用户与服务器建立连接的同时，服务器会自动为其分配一个SessionId。 区别：*（面）*1、cookie数据存放在客户的浏览器上，session数据放在服务器上。2、cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。5、可以考虑将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。 应用场景 登录网站，今输入用户名密码登录了，第二天再打开很多情况下就直接打开了。这个时候用到的一个机制就是cookie。 session一个场景是购物车，添加了商品之后客户端处可以知道添加了哪些商品，而服务器端如何判别呢，所以也需要存储一些信息就用到了session 方案1： 存在cookie里1、不安全2、网络负担效率低 方案2： 存在文件服务器或者数据库里1、大量IO效率问题 方案3： session复制session数据冗余，节点越多浪费越大 方案4： 缓存数据库完全在内存中，速度快，数据结构简单减少io的读操作 通过破坏一段的业务逻辑来换取性能水平切分（横着切） 垂直切分（竖着切）一对一关系 读写分离：读的数据库，写的数据库 通过破坏一定的业务逻辑换取性能 2、 NoSQL简介 NoSQL(Not Only SQL） 非关系型数据库 不依赖业务逻辑，key-value 不遵循SQL标准 不支持ACID （事务四个特性：原子、一致、隔离、持久化） 远超于SQL性能1、适用场景 对数据高并发的读写 海量数据的读写 对数据高科扩展性 2、不适用场景 需要事务支持 基于sql的结构化查询，即席查询（条件查询） 总结：用不着sql和用了sql也不行的情况用Nosql 常用的NoSQL数据库2 行式存储数据库 12select * from users where id =3 快select avg(age) from users 慢 列式存储数据库 OLAP分析型处理OLTP事务型处理 Redis安装string、list、set、zset、hashpush/pop,add/remove 原子数据缓存在内存会周期性的把更的数据写入磁盘或者把修改操作写入追加的记录文件，实现master-slave（主从）同步 1、配合关系型数据库做告诉缓存 高频次，热门访问的数据，降低数据库IO 分布式架构，做session共享 2、由于拥有持久化能力，利用其多样的数据结构存储特定的数据最新N个数据 &lt;—— list排行榜，Top N &lt;—— 利用zset（有序集合）时效性数据，手机验证码 &lt;—— Expire 过期计数器，秒杀 &lt;—— 原子性，自增方法INCR、DECR去除大量数据的重复数据 &lt;—— 利用set构建队列 &lt;—— 利用list发布订阅消息系统 &lt;—— pub/sub模式 端口 6379 ：Merz默认16个数据库，类似数据下标从0开始，初始默认0统一密码管理，所有库都是同样密码Redis是单线程+多路IO复用技术多路复用是指用一个线程来检查多个文件描述符（Socket网络编程）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞到超时，得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如线程池） 串行（隔离，一个一个处理，一个处理完，才能处理下一个） vs 多线程+锁（memcached： 只有字符串，不持久化，） vs 单线程+多路IO复用（Redis 五种数据类型，持久化，没有阻塞状态） 1、阻塞io等，没做其余，备胎 2、非阻塞io发短信，一直发，除了发短信不做其他事情，专一 3、IO多路复用（监视效果）3.1 select大妈 一个一个询问 最多一次1024个妹子 3.2 poll不限制数量，经过宿舍，就去问是不是女神 3.3 epoll不限制，不一个一个问，标记，通知 操作 keys * exists type del expire ttl dbsize Flushdb Flushall 3、Redis五大数据类型key： String（用的最多） 一个key对应一个value 二进制安全，包含任何数据，jpg图片或者序列化对象 最基本数据类型，一个Redis中字符串最多可以是512M get 查询对应键值 set 添加键值对 append 追加末尾 strlen 长度 setnx 只有不存在，才能设值 incr incrby/decrby &lt;步长&gt; 原子性 单线程 中断只能发生于指令之间 多线程 不能被其他进程打断的操作叫原子操作 mset mget msetnx getrange &lt;起始位置&gt;&lt;结束位置&gt;:获得值的范围 setrange &lt;起始位置&gt; :用value覆写key setex &lt;过期时间&gt;:设值键值的同时，设值过期时间 getset :以新换旧，设置了新值同时获得旧值 set 自动排重，不希望出现重复 set是string类型的无序集合。底层是一个value为null的hash表，添加删除查找都是O（1） sadd smembers:取出所有值 sismember：判断是否有该值 scard :个数 screm:删除 spop:随机吐出一个值 srandmember:随机取出n个值，不会删除 sinter；交集 sunion：并集 sdiff：差集：k1减去k1和k2的交集 list 单键多值 插入，左边（头），右（尾） 双向链表，对两端性能高，中间差 lpush/rpush lpop/rpop rpoplpush:从key1右边吐出一个值，插到key2左边 lrange:按照索引下标获得元素(从左到右) lindex:按照索引下标获得元素（从左到右） llen；长度 linsert before :在前面插入 lrem；从左边删除n个value（从左到右）1,0（删除所有），-1（从右到左） Hash 一个键值对集合 String类的field和value的映射表，适合用于存储对象 类似java的Map&lt;String,String&gt; hset&lt;field 数据类型&gt; hget：取出值 hgetall hmset&lt;field1 数据类型&gt;&lt;field2 数据类型&gt;；批量 hexists hkeys hvals hincrby 负数为减 hsetnx:有则不赋值 zset（sorted set） 一个没有重复元素的字符串集合。不同之处是有序集合的每个成员都关联了一个评分（score），这个评分被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分是可以重复的 因为元素有序，所以很快的根据评分或者次序来获取一个范围的元素。访问有序集合的中间元素也是非常快的，因此你能够使用有序集合作为一个没有重复成员的智能列表 两种情况： 相同元素不同分数会将分数更新，相同分数不同元素能添加进去，正常排序 zadd zrange zrangebyscore key min max zrevrangebyscore key max min zincrby:为元素的score加上增量 zrem:删除指定元素 zcount:统计该集合，分数区间的元素的个数 zrank:返回该值在集合的排名，从0开始 如何利用zset实现一个文章访问量的 backlog队列总和=未完成三次握手队列+已经完成三次握手队列 LRU（最近最少使用）volatile-ttl（即将过期）移除那些TTL值最小的key，即那些要过期的key 4、Redis事务什么是redis的事务？redis事务就是一个命令执行的队列，将一系列预定义命令包装成一个整体，就是一个队列。当执行的时候，一次性按照添加顺序依次执行，中间不会被打断或者干扰。 能干嘛？ 一个队列中，一次性，顺序性，排他性的执行一系列命令 redis事务基本操作 开启事务：multi 设置事务的开始位置，这个指令开启后，后面所有的指令都会加入事务中 执行事务： exec 设置事务的结束位置，同时执行事务，与multi成对出现，成对使用 取消事务：discard 终止当前事务，取消multi后，exec前的所有指令 注意： 加入事务的命令并没有立马执行，而且加入队列中，exec命令后才执行 加入和执行事务有错误会怎么办？ 加入事务语法报错，事务则取消 执行事务报错，则成功的返回成功，失败的返回失败，不影响报错后面的指令 注意： 已经执行完毕的命令对应的数据不会自动回滚，需要程序员自己实现 监控key watch： 对key进行监控，如果在exec执行前，监控的key发生了变化，终止事务执行 unwatch： 取消对所有的key进行监控 是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断 作用是串联多个命令防止别的命令插队 Multi Exec discard 事务的错误处理：组队中某个命令出现了报告错误，执行时整个所有队列都会被取消如果执行阶段某个命令报出了错误，只有报错的命令不被执行，而其他命令都会执行 为什么要做成事务？有很多人有你的账户，同时参加双十一抢购 事务冲突的问题 三个请求 一个请求想给金额减8000 一个请求想给金额减5000 一个请求想给金额减1000 悲观锁 乐观锁 三特性单独的隔离操作没有隔离级别的概念不保证原子性 Redis持久化–RDB 是什么？ 在指定的时间间隔内将内存的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里 备份如何执行？原理是redis会单独创建（fork）一个与当前进程一模一样的子进程来进行持久化，这个子进程的所有数据（变量。环境变量，程序程序计数器等）都和原进程一模一样，会先将数据写入到一个临时文件中，待持久化结束了，再用这个临时文件替换上次持久化好的文件，整个过程中，主进程不进行任何的io操作，这就确保了极高的性能如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感（允许丢失一些数据），那RDB的方式要比AOF方式更加的高效。RDB缺点是最后一次持久化的数据可能丢失 1.这个持久化文件在哪里dump.rdb 2.他什么时候fork子进程，或者什么时候触发rdb持久化机制（1）满足保存策略（写时复制：需要写的时候复制） save 900 1 save 300 10 save 60 10000（2）正常关闭shutdown时，如果没有开启aof，会触发配置文件中默认的快照配置 手动保存（一般不用）执行命令save或者bgsavesave是只管保存，其他不管，全部阻塞bgsave：redis会在后台异步进行快照操作，同时可以响应客户端的请求 执行flushall命令 但是里面是空的，无意义 RDB优点 节省磁盘空间 恢复速度快 RDB缺点 虽然Redis在fork时使用了写时拷贝技术，但是如果数据庞大时还是比较消耗性能 在备份周期在一定间隔时间做一次备份，所以如果Redis意外Down掉的话，就会丢失最后一次快照的所有修改 Redis持久化–AOF 是什么？以日志的形式记录每个写操作原理是将Reids的操作日志以追加的方式写入文件，读操作（get）是不记录的，只许追加文件但不可以改写文件，Redis启动之初会读取该文件重新构建数据，Redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作 AOF文件故障备份 AOF的备份机制和性能虽然和RDB不同 AOF和RDB同时开启，系统默认读取AOF的数据 AOF文件故障恢复 AOF文件的保存路径，同RDB路径一致 如遇到AOF文件损坏，可通过redis-check-aof –fix appendonly.aof 1.这个持久化文件在哪里 2.触发机制（根据配置文件配置项） AOF同步频率设置：no（把不主动进行同步）：表示等操作系统进行数据缓存同步到磁盘（快，持久化没保证）always（始终同步）：同步持久化，每次发生数据变更时，立即记录到磁盘（慢，安全）everysec（每秒同步）：表示每秒同步一次（默认值,很快，但可能会丢失一秒以内的数据） 3.aof重写机制（Rewrite）文件追加方式，为了避免文件会越来越大，新增重写当AOF文件增长到一定大小的时候Redis能够调用AOF文件内容压缩 bgrewriteaof对日志文件进行重写 。 如何实现重写？先写临时文件再rename，遍历新进程的内存数据。重写aof的操作，没有读取旧的aof文件，而是都记录哪些数据，用命令的方式（满足条件的就行）重写一个新的aof文件，和快照类似。 何时重写 当AOF文件大小的增长率大于该配置项时自动开启重写（这里指超过原大小的100%）。auto-aof-rewrite-percentage 100 当AOF文件增长到一定大小的时候Redis能够调用 bgrewriteaof对日志文件进行重写 。当AOF文件大小大于该配置项时自动开启重写 auto-aof-rewrite-min-size 64mb AOF优点 备份机制更稳健，丢失数据效率更低 可读的日志文件，通过AOF操作稳健。可以处理误操作 AOF缺点 比起RDB占用更多的磁盘空间 恢复备份速度要慢 每次读写都同步的话，有一定的性能压力 存在个别Bug，造成恢复不能 用哪个好 两个都用 对数据不敏感，单独使用RDB 不建议单独使用AOF，出现Bug 只是做春内存，可以都不用 Redis主从复制 是什么 主从复制就是主机数据更新后根据配置和策略，自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主 用处 读写分离，性能扩展 容灾快速回复 配从不配主 拷贝多个redis.conf文件include 开启daemonize yes Pid文件名字pidfile 指定端口port Log文件名字 Dump.rdb名字dbfilename Appendonly 关掉或者换名字 info replication 打印主从复制的相关信息 slaveof 成为某个实例的从服务器 一主二仆模式1、切入点问题？slave1、slave2是从头开始复制还是切入点开始复制？比如从k4进来，那之前的123是否也可以复制？答：从头开始复制，不管什么时候，全部都有，主从保持一致2、从机是否可以写？set可否？答：不可以写，只可以读3、主机shutdown后情况如何？从机是上位还是原地待命答：原地待命4、主机又回来了后，主机新增记录？从机还能否顺利复制？答：永远数据保持一致5、其中一台从机down后情况如何？依据原有它能跟上大部队吗？答：能，不管什么时候保持数据一致 复制原理 每次从机联通后，都会给主机发送sync指令 主机立刻进行存盘，发送RDB文件，给从机 从机收到RDB文件后，进行全盘加载 之后每次主机的写操作，都会立刻发送给从机，从机执行相同的命令 薪火相传 上一个slave可以是下一个salve的master，slave同样可以接受其他slaves的连接和同步请求，那么该slave作为了链条中下一个的master，可以有效减轻master的写压力，去中心化降低风险 用slaveof 中途变更转向：会清除之前的数据，重写建立拷贝最新的 风险是一旦某个slave宕机，后面的slave都没法备份 反客为主 当一个master宕机后，后面的slave可以立刻升为master，其后面的slave不用做任何修改 slaveof no one将从机变为主机 哨兵模式（sentinel） 反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库 调整为一主二仆模式 新建sentinel.conf sentinel monitor mymaster 127.0.01 6379 1 其中mymaster为监控对象起的服务器名称，1为至少有多少个哨兵同意迁移的数量 故障恢复 新主登基 挑一个从服务 群仆俯首 sentinel向原主的从发生slaveof 旧主俯首 sentinel向其发送slaveof 注：优先级在redis.conf在slave-priotity 100（值越小优先级越高）偏移量是指获得原主数据最多的每个redis实例启动后都会随机生成一个40位的runid Redis集群 容量不够，redis如何进行扩容 并发写操作，redis如何分摊 什么是集群 Redis集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在N个节点中，每个节点存储总数据的1/N Redis集群通过分区（partition）来提供一定程度的可用性（availability）：即使集群中又一部分节点失效或者无法进行通讯，集群也可以继续处理命令请求 redis cluster 如何分配这六个节点 一个集群至少要有三个主节点 –replicas 1表示我们希望为集群中的每个主节点创建一个从节点 分配原则则尽量保证每个主数据库运行在不同的IP的地址，每个从库和主库不在一个IP地址上。 什么是slots 一个Redis集群包括16834个插槽（hash slot），数据库中的每个键都属于这16384个插槽的其中一个，集群使用公式CRC16（key）%16384来计算键key属于哪个槽，其中CRC16（key）语句用来计算键的key的CRC16校验和 集群的每个节点负责处理一部分插槽。举个例子，如果一个集群可以有主节点，其中： 节点A 负责处理0号-5500号插槽 节点B负责处理5501号-11000号插槽 节点C负责处理11001号-16383号插槽 在集群中录入值 在redis-cli每次录入、查询键值，redis都会计算出该key应该送往的插槽，如果不是该客户端对应服务器的插槽，redis会报错，并告知应前往的redis实例地址和端口 redis-cli客户端提供了-c参数实现自动重定向 redis-cli -c -p 6379登入后，在录入、查询键值对可以自动重定向 不在一个slot下的键值，是不是使用mget，mset等多键操作 可以通过{}来定义组的概念，从而使key中{}内相同内容的键值对放到一个slot中 cluster keyslot:计算key应该被放置在哪个槽上cluster countkeysinslot :返回槽slot目前包含的键值对数量cluster getkeysinslot 返回count个slot槽中的键 故障恢复 如果主节点下线？从节点能否自动升为主节点 能下线，可以 主节点恢复后，主从关系如何？ 从变主，主变从 如果所有某一段插槽的主从节点都当掉，redis服务是否还能继续？ 不好使 redis.conf中的参数 cluster-redis-full-coverage 16834个slot都正常的时候才能对对外提供服务 集群好处： 实现扩容 分摊压力（读写、内存） 无中心配置相对简单 集群不足 多键操作不支持 多键的Redis事务是不被支持的。lua脚本不被支持 由于集群方案出现较晚。 redis发布订阅是什么进程间的一种消息通信模式，发送者（pub）发送消息，订阅者（sub）接收消息 publish: 发布消息 语法：publish channel名称 “消息内存” subscribe: 订阅消息 语法：subscribe channel名称 subscribe: 使用通配符订阅消息 语法: pubscribe channel*名称 punsubscribe: 使用通配符退订消息。语法：punsubscribe channel*名称 unsubscribe : 退订消息 语法：unsubscribe channel名称 补课1：ACID原子性:事务里面的操作单元不可切割,要么全部成功,要么全部失败一致性:事务执行前后,业务状态和其他业务状态保持一致.隔离性:一个事务执行的时候最好不要受到其他事务的影响持久性:一旦事务提交或者回滚.这个状态都要持久化到数据库中不考虑隔离性会出现的读问题脏读:在一个事务中读取到另一个事务没有提交的数据不可重复读:在一个事务中,两次查询的结果不一致(针对的update操作)虚读(幻读):在一个事务中,两次查询的结果不一致(针对的insert操作)通过设置数据库的隔离级别来避免上面的问题(理解)read uncommitted 读未提交 上面的三个问题都会出现read committed 读已提交 可以避免脏读的发生repeatable read 可重复读 可以避免脏读和不可重复读的发生serializable 串行化 可以避免所有的问题 缓存穿透 查询一条数据库没有，缓存也没有的数据 访问空对象 代码简单 效果不好 如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。 布隆过滤器：（再多看看）本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。原理通过自己定义个数的Hash函数，取余所有结果返回1，才能成功传入添加多少数据和fpp（容错率默认0.01），自动得到。。。分布式过滤器解决缓存穿透问题 缓存击穿并发查询一条数据库有，但缓存没有的数据（没人访问这条数据 刚好过期）这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力解决方案： 设置热点数据永远不过期。 加互斥锁，互斥锁参考代码如下： 1）缓存中有数据，直接走上述代码13行后就返回结果了 2）缓存中没有数据，第1个进入的线程，获取锁并从数据库去取数据，没释放锁之前，其他并行进入的线程会等待100ms，再重新去缓存取数据。这样就防止都去数据库重复取数据，重复往缓存中更新数据情况出现。 3）当然这是简化处理，理论上如果能根据key值加锁就更好了，就是线程A从数据库取key1的数据并不妨碍线程B取key2的数据，上面代码明显做不到这点。 缓存雪崩数据库（redis）宕机，大部分数据失效规避雪崩：redis高可用集群（cluster） 错开数据过期时间 如果出现雪崩 熔断 限流 数据一致性 删除策略定时删除–&gt;以CPU内存换redis内存 惰性删除–&gt;以redis内存换CPU内存 定期删除 redis使用：惰性删除+定期删除 1.redis在启动的时候读取配置文件hz的值，默认为10 2.每秒执行hz次serverCron()–&gt;databasesCron()—&gt;actveEXpireCyle() 3.actveEXpireCyle()对每个expires[*]进行逐一检测，每次执行250ms/hz 4.对某个expires[*]检测时，随机挑选N个key检查 ​ 如果key超时，删除key ​ 如果一轮中删除的key的数量&gt;N*25%，循环该过程 ​ 如果一轮中删除的key的数量小于等于N*25%,检查下一个expires[ * ] current_db用于记录actveEXpireCyle()进入哪个expires[ * ] 执行，如果时间到了，那么下次根据current_db继续执行 逐出算法相关配置： maxmemory： 最大可使用内存，占用物理内存的比例，默认值为0,，表示不限制。生产环境一般根据需求设置，通常50%以上 maxmemory-policy： 达到最大内存后，对挑选出来的数据进行删除策略 maxmemory-samples: 每次选取待删除数据的个数，选取数据时并不会全库扫描，采用随机获取数据的方式作为待检测删除数据 redis的持久化机制说白了，就是在指定的时间间隔内，将内存当中的数据集快照写入磁盘，它恢复时是将快照文件直接读到内存 什么意思呢？我们都知道，内存当中的数据，如果我们一断电，那么数据必然会丢失，但是玩过redis的同学应该都知道，我们一关机之后再启动的时候数据是还在的，所以它必然是在redis启动的时候重新去加载了持久化的文件 redis提供两种方式进行持久化， 一种是RDB持久化默认， 另外一种是AOF（append only file）持久化。 1.RDB 是什么？ 原理是redis会单独创建（fork）一个与当前进程一模一样的子进程来进行持久化，这个子进程的所有数据（变量。环境变量，程序程序计数器等）都和原进程一模一样，会先将数据写入到一个临时文件中，待持久化结束了，再用这个临时文件替换上次持久化好的文件，整个过程中，主进程不进行任何的io操作，这就确保了极高的性能 1.这个持久化文件在哪里dump 2.他什么时候fork子进程，或者什么时候触发rdb持久化机制shutdown时，如果没有开启aof，会触发配置文件中默认的快照配置执行命令save或者bgsave save是只管保存，其他不管，全部阻塞 bgsave： redis会在后台异步进行快照操作，同时可以响应客户端的请求 执行flushall命令 但是里面是空的，无意义 2.aof(–fix) ls -l –block-size=M 是什么？ 原理是将Reids的操作日志以追加的方式写入文件，读操作是不记录的 1.这个持久化文件在哪里 2.触发机制（根据配置文件配置项） no：表示等操作系统进行数据缓存同步到磁盘（快，持久化没保证）always：同步持久化，每次发生数据变更时，立即记录到磁盘（慢，安全）everysec：表示每秒同步一次（默认值,很快，但可能会丢失一秒以内的数据） 3.aof重写机制 当AOF文件增长到一定大小的时候Redis能够调用 bgrewriteaof对日志文件进行重写 。当AOF文件大小的增长率大于该配置项时自动开启重写（这里指超过原大小的100%）。auto-aof-rewrite-percentage 100 当AOF文件增长到一定大小的时候Redis能够调用 bgrewriteaof对日志文件进行重写 。当AOF文件大小大于该配置项时自动开启重写 auto-aof-rewrite-min-size 64mb","categories":[{"name":"Redis","slug":"Redis","permalink":"https://lijiale96.github.io/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://lijiale96.github.io/tags/Redis/"},{"name":"session","slug":"session","permalink":"https://lijiale96.github.io/tags/session/"},{"name":"cookie","slug":"cookie","permalink":"https://lijiale96.github.io/tags/cookie/"}]},{"title":"Java自学之路","slug":"Java自学之路","date":"2020-03-09T14:12:00.000Z","updated":"2020-03-10T14:22:13.361Z","comments":true,"path":"2020/03/09/Java自学之路/","link":"","permalink":"https://lijiale96.github.io/2020/03/09/Java%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF/","excerpt":"基础知识-编程语言：Java Python C-基本算法-基本网络知识：TCP/IP HTTP/HTTPS-基本的设计模式","text":"基础知识-编程语言：Java Python C-基本算法-基本网络知识：TCP/IP HTTP/HTTPS-基本的设计模式 工具方面-操作系统：Linux （CentOS\\）-代码管理: SVN/Git-持续集成（CI/CD）: jenkins-Java的项目管理工具：Maven/Gradle 框架方面应用层框架-ssh spring+structs +hibernate（不要学）-ssm:spring springmvc mybatis-spring boot 各种中间件-MQ 消息队列-RPC 通信框架 gPRC thrift dubbo springcloud-elasticsearch 数据库 搜索引擎 数据库-SQL:MySQL / Postgre SQL-NoSQL: Redis Memcached mongodb elasticsearch##架构方面 分布式/微服务架构-spring cloud-dubbo-rpc通信框架 虚拟化/容器化的技术-Docker 容器化-k8s kubernetes 关注源码/性能-JDK源码以及部分设计思想-Spring源码-JVM细节与排错-高并发/高可用 他人经验软件方面，java可以先从中后台开始从应用层方面先开始做做，具备一定系统架构能力之后，个人建议往大数据，知识图谱和AI方面深入研究 我听说编程语言，经常使用的是其中20％的技术。在Java这门语言中，这20％包括哪些内容？参加培训两个月了，还有两个月的时间，要想在两个月后，找到一份Java初级程序员的工作，有哪些是必须掌握的，有哪些是可以现学现卖的？一个完整的Javaweb项目，有哪些具体模块，每个模 块用到的技术是哪些？常用api（String，StringBuffer/StringBuilder等）1.集合类，线程类。2.Servlet（很少用纯粹的servlet写，但你要懂，因为很多框架都是基于servlet封装的）。3.json，xml读写4.数据库访问（CRUD，事务，连接池）5.http请求（HttpClient）6其他，包括常用框架，设计模式，面向对象 初级程序员会这些就可以写项目了。后期遇到的问题就会复杂得多，要靠各种经验和知识的积累。除了要掌握的20%以外还要掌握些什么知识才能游刃有余。下面说说我接触（使用）过、的东西吧。1.java以分布式应用丰富的生态闻名，在分布式系统中逃不过CAP的抉择。早早了解一些分布式一致性协议paxos、raft等。学习zookeeper的原理和使用场景(metadata、分布式锁、leaderEletion… etc)2.RPC框架在SOA架构中起着重要的作用，好好探究终是有好处的，在这里推荐阿里巴巴的dubbo框架，同时会netty、mina等网络库3.Hadoop系列 Storm Spark 等离线\\实时计算框架4.ElasticSearch\\SolrCloud 分布式搜索 ELK 日志相关的东西对这些比较敏感，当然在更多的场景使用ES也是有很多的5.消息队列 kafka\\MetaQ RabbitMQ 恩， ZeroMQ（不完全算作MQ）的作者选择安乐死了，愿天堂没有痛苦6.然后就是各种基础知识，编程语言、网络方面、数据库、数据结构和算法。不要觉得任何一项都精通了，敢说精通的知乎能有几个。说说自己的感受吧，刚工作应该不会让你独立开始新项目，应该会让你跟正在开发中的项目1.学会使用eclipse，svn等IDE和工具（不用说了吧，主要是看你工作的地方，比如大家用eclipse你想用IntelliJIDEA也可以，但是刚工作肯定很多不懂，这时候暂时还不要标新立异的好，出了问题好问。当然你是ide大神请无视）2. 刚入职还接触不到核心工作，就让我先改改页面什么的，作为web开发html、css、和javascript不用精通，至少需要了解用法和语法吧，虽然有前端工程师，但是这个肯定也是要了解的（自己公司小项目组，各个都被逼成全栈了）。javascript其实还是很强大的，但是刚开始不用写的很深，很多轮子可以用，比如easyui，会查阅官方文档，知道用法往网页里嵌，然后后台按格式把数据传到前台就好。3. 然后开始逐步往后台写了，熟悉下设计模式，如果太多太难理解可以先理解工厂模式，写一个接口再用一个或若干个实现类实现这个接口，需要用的时候在根据需要来确定用哪个实现类。（一开始不理解这么做这么繁琐有什么用，但是自从上次项目的数据库从oracle换成mysql就知道这么做其实大有用处）一般项目开发都会用到设计模式，不了解可能会摸不清楚整个项目的架构，无从下手。4.不同公司用的框架不一样，但struts，spring还是用的比较多的，所以这两个东西还是比较熟悉的好，不然你可能连整个项目的架构都不清楚，不要说自己写，连改都很难入手。比如项目的跳转是怎么配的，哪个配置 文件代表了什么。（一开始我把项目本地跑起来以后我连主页在哪是哪个文件怎么进去的都不清楚T.T，一直在找index.jsp然后才知道项目用 freemarker做的，是一个ftl文件）5.web项目要操作数据库的工作是少不了的了，自己跟的项目没用hibernate，主要用的是StringBuffer拼接sql，如果从事web开发，sql还是要比较熟的。6. 自己感觉做web项目设计高深算法的可能做的比较深才会遇到，更多的是对字符串和数值格式的操作，比如后台从数据库抽出来到前台怎么展示，用户输入的数据怎么怎么存到数据库里，所以最好熟悉下字符串的操作，分割呀合并呀，String转float、int什么的，日期格式呀什么的。如果公司有专业运维，服务器部署什么的交给他们就好了，如果没有就最好还是了解下，远程连接呀，linux的一些简单的命令呀，tomcat呀什么的20%我不知道从哪方面去理解，接下来我会将自己多年来工作中会经常使用到的技术列出来。1.html、css2.java工作原理（jvm）3.java语法、数据结构和算法4.java语言特性（封装、继承、多态、抽象）5.java设计模式（在开发中会经常用到）6.java反射机制（常用框架都会用到反射机制）7.io（文件读写）8.多线程9.网络编程10.javascript11.jquery12.数据库（oracle、mysql等等）13.servlet14.JDBC15.javabean16.WEB项目分层架构17.前后台交互18.ajax19.过滤器及过滤器原理20.常用框架（Struts、hibernate、spring、springMVC、i/mybatis）21.框架整合22.工作流（流程引擎工作机制）23.xml、properties、json24.常用页面以及后台插件（tree、时间、poi等等）25.nosql数据库以及应用场景（mongoDB）26.缓存数据库以及机制（redis、memcached）27.第三方接口调用28.SDK29.web应用服务器（tomcat、weblogic）30.linux31.日志32.数据库连接池33.maven34.svn35.建模工具（powerdesiner、axure）使用36.TCP/IP","categories":[{"name":"Java","slug":"Java","permalink":"https://lijiale96.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://lijiale96.github.io/tags/Java/"}]},{"title":"牛客错题整理（61-70）","slug":"牛客Java刷题整理 61-70","date":"2020-03-09T14:12:00.000Z","updated":"2020-03-15T16:08:39.712Z","comments":true,"path":"2020/03/09/牛客Java刷题整理 61-70/","link":"","permalink":"https://lijiale96.github.io/2020/03/09/%E7%89%9B%E5%AE%A2Java%E5%88%B7%E9%A2%98%E6%95%B4%E7%90%86%2061-70/","excerpt":"2020/3/8Java第61套 1、java的数据类型分为两大类：基本类型和引用类型；本类型只能保存一些常量数据，引用类型除了可以保存数据，还能提供操作这些数据的功能； 为了操作基本类型的数据，java也对它们进行了封装，得到八个类，就是java中的基本类型的封装类；他们分别是：八种基本类型：byte short int long float double char boolean对应的包装类 ： Byte Short Integer Long Float Double Character Boolean","text":"2020/3/8Java第61套 1、java的数据类型分为两大类：基本类型和引用类型；本类型只能保存一些常量数据，引用类型除了可以保存数据，还能提供操作这些数据的功能； 为了操作基本类型的数据，java也对它们进行了封装，得到八个类，就是java中的基本类型的封装类；他们分别是：八种基本类型：byte short int long float double char boolean对应的包装类 ： Byte Short Integer Long Float Double Character Boolean 2、既然是实现接口，就要实现接口的所以方法，相当于重写方法，方法的重写需要满足：三同一大一小（方法名、返回值类型、形参相同；访问权限&gt;=重写前；抛出异常&lt;=重写前）接口，比抽象类还要抽象的类。 接口中每一个方法也是隐式抽象的,接口中的方***被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。接口中可以含有变量，但是接口中的变量会被隐式的指定为public static final变量（并且只能是 public，用 private 修饰会报编译错误。）接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。注：接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。 接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。 接口中的方法都是公有的public3、weblogic中开发消息Bean时的persistent与non-persisten的差别： persistent方式的MDB可以保证消息传递的可靠性,也就是如果EJB容器出现问题而JMS服务器依然会将消息在此MDB可用的时候发送过来。 non－persistent方式的消息将被丢弃。4、 1.先执行括号中的i++ 在执行i++的时候 Java会将i先存放到一个临时变量中去 并返回该临时变量的值（假设为temp） 2.所以 这句可以拆成 temp = i （值为-5） 并返回temp的值 然后 i自加1 此时 i 的值为-4 但是之后 执行就会出现问题 由于返回了temp的值 继续执行的表达式为i=++(-5); 单目运算符无法后跟一个字面量 所以在IDEA编辑器中提示Variable expected（此处应为变量） 2020/3/11Java第62套1、A 接口与抽象类是不同的概念。抽象类是用于捕捉子类的通用特性，接口是抽象方法的集合；B 实现接口必须实现接口的所有方法；C 接口可以继承一个或多个接口，抽象类只能继承一个类或者实现多个接口；D 一个类只能继承一个类，但是可以实现多个接口。2、HashMap可以插入null的key或value，插入的时候，检查是否已经存在相同的key，如果不存在，则直接插入，如果存在，则用新的value替换旧的value，在本题中，第一条put语句，会将key/value对插入HashMap，而第二条put，因为已经存在一个key为name的项，所以会用新的value替换旧的vaue，因此，两条put之后，HashMap中只有一个key/value键值对。那就是（name，jack）。所以，size为1.3、在java语言中虚函数指代的就是抽象方法，抽象方法中不能用private，static， synchronized，native等修饰词修饰。4、操作步骤就是先解码再编码用new String(src，”GBK”)解码得到字符串用getBytes(“UTF-8”)得到UTF8编码字节数组5、假设两线程为A、B，设有3种情况：1.AB不并发：此时相当于两个方法顺序执行。A执行完后a=-1，B使用-1作为a的初值，B执行完后a=-22.AB完全并发：此时读写冲突，相当于只有一个线程对a的读写最终生效。相同于方法只执行了一次。此时a=-13.AB部分并发：假设A先进行第一次读写，得到a=1;之后A的读写被B覆盖了。B使用用1作为a的初值，B执行完后a=06、A选项：通过 pageContext（PageContext类的实例，提供对JSP页面所有对象以及命名空间的访问） 获取stringBean 的值，赋给 String类型的变量myBean，然后通过 Jsp 表达式 处理该值。bean:define题目中的 Struts 的bean:define 标签定义了一个字符串变量 stringBean ,它的值为 helloworld。bean:write bean:write相当于 &lt;%=request.getAttribute(“something”)%&gt; 其中 something 是属性的名字。所以 B 错，C对。D选项：通过Jsp 表达式 获取变量 stringBean 的值 2020/3/15Java第63套1、Set 不能有重复的元素，且是无序的，要有空值也就只能有一个。因为它不允许重复。 List可以有重复元素，且是有序的，要有空值也可以有多个，因为它可重复2、同步是害怕在操作过程的时候被其他线程也进行读取操作，一旦是原子性的操作就不会发生这种情况。因为一步到位的操作，其他线程不可能在中间干涉。另外三项都有读取、操作两个步骤，而X=1则是原子性操作。3、因为error是系统出错，catch是无法处理的，难以修复的，RuntimeException不需要程序员进行捕获处理，error和exception都是throwable的子类，我们只需要对exception的实例进行捕获即可 Throwable Error Exception IOException RuntimeException4、注意这里”ISO8859-1”是一个普通字符串，不要被迷惑了String.getBytes(“ISO8859-1”）表示获取这个字符串的byte数组，然后new String(String.getBytes(“ISO8859-1”），GB2312)是上面的字符数组按照GB2312编码成新的字符串 5、服务器端：ServerSocket提供的实例 ServerSocket server = new ServerSocket(端口号)客户端：Socket提供的实例 Socket client = new Socket(IP地址，端口号) 6、五个基本原则：SOLID单一职责原则（Single-Resposibility Principle）：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。开放封闭原则（Open-Closed principle）：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。Liskov替换原则（Liskov-Substituion Principle）：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。依赖倒置原则（Dependecy-Inversion Principle）：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。接口隔离原则（Interface-Segregation Principle）：使用多个小的专门的接口，而不要使用一个大的总接口 7、short类型转为byte类型出错a1*a2结果为int类型，转为byte类型出错 8、JPanel 是 Java图形用户界面(GUI)工具包swing中的面板容器类，包含在javax.swing 包中，是一种轻量级容器，可以加入到JFrame窗体中。JPanel默认的布局管理器是FlowLayout，其自身可以嵌套组合，在不同子容器中可包含其他组件(component),如JButton、JTextArea、JTextField 等，功能是对对窗体上的这些控件进行组合,所以说A是错误的。 9、DynaValidatorActionForm 动态验证表单 10、main()函数即主函数，是一个前台线程，前台进程是程序中必须执行完成的，而后台线程则是java中所有前台结束后结束，不管有没有完成，后台线程主要用与内存分配等方面。前台线程和后台线程的区别和联系：1）后台线程不会阻止进程的终止。属于某个进程的所有前台线程都终止后，该进程就会被终止。所有剩余的后台线程都会停止且不会完成。2）可以在任何时候将前台线程修改为后台线程，方式是设置Thread.IsBackground 属性。3）不管是前台线程还是后台线程，如果线程内出现了异常，都会导致进程的终止。 4）托管线程池中的线程都是后台线程，使用new Thread方式创建的线程默认都是前台线程。说明： 应用程序的主线程以及使用Thread构造的线程都默认为前台线程 使用Thread建立的线程默认情况下是前台线程，在进程中，只要有一个前台线程未退出，进程就不会终止。主线程就是一个前台线程。而后台线程不管线程是否结束，只要所有的前台线程都退出（包括正常退出和异常退出）后，进程就会自动终止。一般后台线程用于处理时间较短的任务，如在一个Web服务器中可以利用后台线程来处理客户端发过来的请求信息。而前台线程一般用于处理需要长时间等待的任务，如在Web服务器中的监听客户端请求的程序，或是定时对某些系统资源进行扫描的程序 11、private成员只能在当前类中访问，派生类可以访问父类的public和protected属性成员 12、Java中的关键字有哪些？答：1）48个关键字：abstract、assert、boolean、break、byte、case、catch、char、class、continue、default、do、double、else、enum、extends、final、finally、float、for、if、implements、import、int、interface、instanceof、long、native、new、package、private、protected、public、return、short、static、strictfp、super、switch、synchronized、this、throw、throws、transient、try、void、volatile、while。2）2个保留字（现在没用以后可能用到作为关键字）：goto、const。3）3个特殊直接量：true、false、null。 13、Java8的接口方法可以有如下定义only public, abstract, default, static and strictfp are permitted","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lijiale96.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://lijiale96.github.io/tags/Java/"},{"name":"牛客","slug":"牛客","permalink":"https://lijiale96.github.io/tags/%E7%89%9B%E5%AE%A2/"}]},{"title":"Navicat12 下载、激活","slug":"Navicat12-下载、激活","date":"2020-03-08T11:43:22.000Z","updated":"2020-03-08T16:32:39.969Z","comments":true,"path":"2020/03/08/Navicat12-下载、激活/","link":"","permalink":"https://lijiale96.github.io/2020/03/08/Navicat12-%E4%B8%8B%E8%BD%BD%E3%80%81%E6%BF%80%E6%B4%BB/","excerpt":"","text":"win7环境下Navicat Premium 12及安装：链接：https://pan.baidu.com/s/12pizxbYY7FNKsqYHrG9CNQ提取码：g817 注： 断网 关闭360等杀毒软件 先打开 Navicat_Keygen_Patch_v4.5_By_DFoX 点击patch Navicat12.exe 选择Enterprise、Premiunm等，点击generate激活码 再打开 Navicat12.exe，复制激活码，再点手动激活，将Request Code复制并点击generate 激活成功 如果还不会，请参考网址：https://www.bilibili.com/video/av66677590","categories":[{"name":"Navicat","slug":"Navicat","permalink":"https://lijiale96.github.io/categories/Navicat/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://lijiale96.github.io/tags/Java/"},{"name":"MySQL","slug":"MySQL","permalink":"https://lijiale96.github.io/tags/MySQL/"}]},{"title":"牛客错题整理（47-60）","slug":"牛客Java刷题整理 47-60","date":"2020-03-06T07:12:00.000Z","updated":"2020-03-07T16:30:48.033Z","comments":true,"path":"2020/03/06/牛客Java刷题整理 47-60/","link":"","permalink":"https://lijiale96.github.io/2020/03/06/%E7%89%9B%E5%AE%A2Java%E5%88%B7%E9%A2%98%E6%95%B4%E7%90%86%2047-60/","excerpt":"2020/2/23Java第47套1、A、AWT文本框 TextField。 B、Menu表示下拉菜单 C、Label表示标签 D、List表示列表框2、Object类中方法： protected Object clone()创建并返回此对象的一个副本。boolean equals(Object obj)指示其他某个对象是否与此对象“相等”。protected void finalize()当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。class getClass()返回此 Object 的运行时类。int hashCode()返回该对象的哈希码值。","text":"2020/2/23Java第47套1、A、AWT文本框 TextField。 B、Menu表示下拉菜单 C、Label表示标签 D、List表示列表框2、Object类中方法： protected Object clone()创建并返回此对象的一个副本。boolean equals(Object obj)指示其他某个对象是否与此对象“相等”。protected void finalize()当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。class getClass()返回此 Object 的运行时类。int hashCode()返回该对象的哈希码值。 void notify()唤醒在此对象监视器上等待的单个线程。void notifyAll()唤醒在此对象监视器上等待的所有线程。String toString()返回该对象的字符串表示。void wait()在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。void wait(long timeout)在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量前，导致当前线程等待。void wait(long timeout, int nanos)在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量前，导致当前线程等待。Sleep是Thread的类方法3、一个子类只能继承一个抽象类（虚类），但能实现多个接口；一个抽象类可以有构造方法，接口没有构造方法；一个抽象类中的方法不一定是抽象方法，即其中的方法可以有实现（有方法体），接口中的方法都是抽象方法，不能有方法体，只有声明；一个抽象类可以是public、private、protected、default, 接口只有public;一个抽象类中的方法可以是public、private、protected、default， 接口中的方法只能是public和defaultc++虚类，即抽象类，至少有一个抽象方法，可以有方法定义 java接口，都是抽象方法，对应c++纯虚类4、A.程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的信号指示器（偏移地址），Java编译过程中产生的字节码有点类似编译原理的指令，程序计数器的内存空间存储的是当前执行的字节码的偏移地址，每一个线程都有一个独立的程序计数器（程序计数器的内存空间是线程私有的），因为当执行语句时，改变的是程序计数器的内存空间，因此它不会发生内存溢出 ，并且程序计数器是jvm虚拟机规范中唯一一个没有规定 OutOfMemoryError 异常 的区域； B.java虚拟机栈：线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会床创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。 没有类信息，类信息是在方法区中 C.java堆：对于绝大多数应用来说，这块区域是 JVM 所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组 D.方法区：属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 2020/2/24Java第48套1、流媒体技术是一种可以使音频，视频和其他多媒体信息在 Internet 及 Intranet上以实时的，无需下载等待的方式进行播放的技术。流媒体又叫流式媒体，它是指商家用一个视频传送服务器把节目当成数据包发出，传送到网络上。 2、 定义在类中的变量是类的成员变量，可以不进行初始化，Java会自动进行初始化，如果是引用类型默认初始化为null,如果是基本类型例如int则会默认初始化为0局部变量是定义在方法中的变量，必须要进行初始化，否则不同通过编译被static关键字修饰的变量是静态的，静态变量随着类的加载而加载，所以也被称为类变量 被final修饰发变量是常量3、Statement对象用于执行不带参数的简单SQL语句。 Prepared Statement 对象用于执行预编译SQL语句。 Callable Statement对象用于执行对存储过程的调用。4、web容器是一种服务程序，在服务器一个端口就有一个提供相应服务的程序，而这个程序就是处理从客户端发出的请求，如JAVA中的Tomcat容器，ASP的IIS或PWS都是这样的容器。一个服务器可以多个容器。Web负责将HTTP请求转换为HttpServletRequest对象5、其实当我们在为Integer赋值的时候，java编译器会将其翻译成调用valueOf()方法。比如Integer i=127翻译为Integer i=Integer.valueOf(127) 然后我们来看看valueOf()函数的源码： public static Integer valueOf(int i) { //high为127 if(i &gt;= -128 &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.***[i + 128]; else return new Integer(i); }可以看出，对于-128到127之间的数，Java会对其进行缓存。而超出这个范围则新建一个对象。 所以现在回到这道问题 i1和i2为128，超出范围，所以都需要新建对象，对象比较为false； i5和i6为100，在范围之内，在执行Integer i5=100时，就会直接缓存到内存中，但执行执行Integer i6=100时，就直接从缓存里取，而不需要新建对象，所以为true。关于字符串的解释（摘自：https://www.cnblogs.com/huajiezh/p/6565301.html）：String str1=”java”; //指向字符串池 String str2=”blog”; //指向字符串池 String s=str1+str2; //s是指向堆中值为”javablog”的对象，+运算符会在堆中建立来两个String对象，这两个对象的值分别是”java” “blog”. 也就是说从字符串池中复制这两个值，然后在堆中创建两个对象，然后再建立对象s,然后将”javablog”的堆地址赋给s. 这句共创建了?个String 对象！ System.out.println(s==”javablog”); //结果是false。 Jvm确实对型如String str1=”java”;的String对象放在常量池里，但是它是在编译时那么做的，而String s=str1+str2;是在运行时刻才能知道，也就是说str1+str2是在堆里创建的，所以结果为false了6、因为byte是有符号单字节整形，所以存储数字范围是[-128·127]而127[01111111]+1==128[10000000]。为什么呢？因为科学家定义数字的时候是一个环，最大的数字后面就是最小，这样才可以把[0·255]分配给[-128·127]。底层就是补码的概念。好，我们再从java程序上运行一次。 public class HelloWorld { public static void main(String []args) { byte b = (byte)129; byte c = (byte)128; System.out.println(b); System.out.println(c); }}B=129=-1277、这里主要是有一点： 如果参数小于0且大于-1.0，结果为 -0 the argument，意思为：如果参数是 NaN、无穷、正 0、负 0，那么结果与参数相同， 如果是 -0.0，那么其结果是 -0.0 ceil：大于等于 x，并且与它最接近的整数。 floor：小于等于 x，且与 x 最接近的整数。8、 字节流：InputStream|– FileInputStream (基本文件流）|– BufferedInputStream|– DataInputStream|– ObjectInputStream 字符流 Reader |– InputStreamReader (byte-&gt;char 桥梁） |– BufferedReader (常用） Writer |– OutputStreamWriter (char-&gt;byte 桥梁） |– BufferedWriter |– PrintWriter （常用）stream结尾都是字节流，reader和writer结尾都是字符流 两者的区别就是读写的时候一个是按字节读写，一个是按字符。实际使用通常差不多。 在读写文件需要对内容按行处理，比如比较特定字符，处理某一行数据的时候一般会选择字符流。 只是读写文件，和文件内容无关的，一般选择字节流。 2020/2/25Java第49套1、HashSet内部使用Map保存数据，即将HashSet的数据作为Map的key值保存，这也是HashSet中元素不能重复的原因。而Map中保存key值前，会去判断当前Map中是否含有该key对象，内部是先通过key的hashCode，确定有相同的hashCode之后，再通过equals方法判断是否相同。 HashSet的底层还是用HashMap来实现的。将Entry&lt;K,V&gt;的V都变成了同一个Object对象，public static final PRESENT = new Object()。 而HashMap的数据结构是数组+链表+红黑树。调用K的hashCode方法，然后高低16位进行&amp;运算。得到的hash值，与数组tab[]（桶）的长度-1进行&amp;运算，确定插入对象在哪一个桶上。然后调用对象的equals方法，形成链表。当链表长度大于8时，链表转红黑树。3、编译时异常必须显示处理，运行时异常交给虚拟机。 运行时异常可以不处理。当出现这样的异常时，总是由虚拟机接管。比如我们从来没有人去处理过Null Pointer Exception异常，它就是运行时异常，并且这种异常还是最常见的异常之一。出现运行时异常后，系统会把异常一直往上层抛，一直遇到处理代码。如果没有处理块，到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。抛出之后，如果是线程，这个线程也就退出了。如果是主程序抛出的异常，整个程序也就退出了。运行时异常是Exception的子类，也有一般异常的特点，是可以被Catch块处理的。只不过往往不对它处理罢了。也就是说，如果不对运行时异常进行处理，那么出现运行时异常之后，要么是线程中止，要么是主程序终止。4、Hibernate 中 get()和load() 的区别： 1.get()采用立即加载方式,而load()采用延迟加载;get()方法执行的时候,会立即向数据库发出查询语句,而load()方法返回的是一个(此中只有一个id属性),只有等真正使用该对象属性的时候,才会发出sql语句 2.如果数据库中没有对应的记录,get()方法返回的是null.而load()方法出现异常ObjectNotFoundException5、被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备一下特点：10ms 并行与并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。 空间整合：与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内6、这里简单地说,a,b,x,y就是四个指针。y本来指向的是b所指向的对象，但是一个“=”，y就指向了x所指向的目标即是a指向的对象，因此原来b所指向的目标并没有发生任何改变。与y不同的是，x进行的是对象操作,此时此对象在内存中是真正的本质上的改变。有点绕，但是手机打字，没发画图，不然其实很容易理解。7、构造函数的作用是完成对象的初始化。当程序执行到new操作符时， 首先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化。而选项B、D中，对象的初始化并不是通过构造函数完成的，而是读取别的内存区域中的对象的各个域来完成。8、 A，java是强类型语言，所有的方法必须放在类里面，包括main B java中可以有多个重载的main方法，只有public static void main(String[] args){}是函数入口 C，内部类的类名一般与文件名不同 D，函数都必须用{}括起来，不管是一条语句还是多条语句9、A:Java中所有错误和异常的父类是java.lang.Throwable B：基本数据类型不是对象，不能用new的方法获取，但是每个基本数据类型都对应着封装类型，这些封装类型为了解决基本数据类型面向对象用的。 C:Java垃圾回收器负责回收无用对象占据的内存资源,但对象没有使用new获取了一块特殊区域，这块特殊区域的回收使用finallize（） D：Java跨平台是因为有JVM的存在，Java的三个版本的运行需要各自不同的环境。10、 synchronized不是修饰变量的 它修饰方法或代码块或对象Volatile和static volatile 避免程序在多线程竞争读到不正确的值。2020/2/26Java第50套1、一个类可以自定义无穷多个构造函数，选项第一个肯定就是错的了 构造函数不和类同名就不是构造了。 构造就是用来建立对象的，当然是在构造中做初始化了。 最后一个创建对象需要自己写调用构造吧？没记得java会自己调用构造。2、无修饰符就是default 同一个包3、饿汉就是类一旦加载，就把单例初始化完成，保证getInstance的时候，单例是已经存在的了，而不是开始初始化 ，评论区很多人别误人子弟。注意：单例是已经存在，而不是才开始初始化单例。你们说的那是懒汉模式。懒汉模式，只有当调用getInstance的时候，才回去初始化这个单例。单例模式，所有符号引用都指向了一个实体。4、Spring的API设计很不错，基本上根据英文翻译就能知道作用:Required:必须的。说明必须要有事物，没有就新建事物。supports:支持。说明仅仅是支持事务，没有事务就非事务方式执行。mandatory:强制的。说明一定要有事务，没有事务就抛出异常。required_new:必须新建事物。如果当前存在事物就挂起。not_supported:不支持事物，如果存在事物就挂起。never:绝不有事务。如果存在事物就抛出异常5、Animal b = new Dog(); 编译器会把当前类型当做父类类型，但是运行时是右边子类类型，所以在用父类调用bark方法时，是不存在的，会编译报错编译错误：The method bark() is undefined for the type Animal。Animal中没有定义bark()方法。 Dog继承自Animal。 当用Dog对象初始化Animal类对象时，完成了对Animal对象中方法与变量的覆盖与隐藏，也就是b.move()调用的是Dog中move()方法。而Animal中本身并没有bark()方法，不存在被覆盖的情况，亦无法访问，也就是b.bark()会报错。6、隐藏域在页面中对于用户（浏览器）是不可见的，在表单中插入隐藏域的目的在于收集或发送信息，以利于被处理表单的程序所使用。浏览者单击发送按钮发送表单的时候，隐藏域的信息也被一起发送到服务器。1.session用来表示用户会话，session对象在服务端维护，一般tomcat设定session生命周期为30分钟，超时将失效，也可以主动设置无效；2.cookie存放在客户端，可以分为内存cookie和磁盘cookie。内存cookie在浏览器关闭后消失，磁盘cookie超时后消失。当浏览器发送请求时，将自动发送对应cookie信息，前提是请求url满足cookie路径；3.可以将sessionId存放在cookie中，也可以通过重写url将sessionId拼接在url。因此可以查看浏览器cookie或地址栏url看到sessionId；4.请求到服务端时，将根据请求中的sessionId查找session，如果可以获取到则返回，否则返回null或者返回新构建的session，老的session依旧存在，2020/2/27Java第51套1、String底层是数组，用final修饰的2、Import ch4.* 导入这个类3、‘a’=1/3，错，因为 a是个常数4、当编写一个java源代码文件时，此文件通常被称为编译单元（有时也被称为转译单元）。每个编译单元都必须有一个后缀名.java，而在编译单元内则可以有一个public类，该类的名称必须与文件的名称相同（包括大小写，但不包括文件的后缀名.java）。每个编译单元只能有一个public类，否则编译器就不会接受。如果在该编译单元之中还有额外的类的话，那么在包之外的世界是无法看见这些类的，这是因为它们不是public类，而且它们主要用来为主public类提供支持。–《Java 编程思想》注：public类不是必须的，但是如果源文件中有一个（只能有一个）public类的话，文件名必须与这个public类同名，原因是为了方便虚拟机在相应的路径中找到相应的类所对应的字节码文件。所以在没有public类的Java文件中，文件名和类名都没什么联系。4、操作系统可以不需要，注释可以多写5、A:java编译成的是字节码，再被各系统的jvm翻译成本系统可以识别的机器码，这就是java一次编程多平台应用的跨平台性B:java源文件生成的是class文件，与系统无关C:注意字节码和机器码不是一回事java程序在运行时字节码才会被jvm翻译成机 器码，所以说java是解释性语言D:注意jvm的版本，好比人穿裤子，一条裤子能被任何人穿上吗6、threadlocalmap使用开放定址法解决hash冲突，hashmap使用链地址法解决hash冲突散列表之开放定址法 在前面的文章中我们介绍过《散列表之链接法》，在链接法中，如果不同键值却将有相同的映射值，即有不同键值的元素却映射到散列表中的同一位置，那么就采用链表的方法，将映射到同一位置的元素插入到同一个链表之中，当需要删除， 查询元素时，只需要遍历该链表即可，链接法在最坏情况下删除和查询元素的时间代价为O(n)O(n) 今天我们来讲散列表中另外一种解决冲突的方法，那就是开放定址法(open addressing)。 假如你在外面旅游时，吃坏东西，急需上厕所，当你好不容易找到一件洗手间的时候，发现排了好多人，这时你会怎么做？ 如果是链接法:排队不就行了，我就在外面等，迟早会排到我的 如果是开放定址法:直接放弃现有厕所，去寻找新的厕所 没错，放弃已被占用的位置，寻找新的插入位置就是开放定址法的思想，开放定址法中的开放二字指的是没有被占用的位置，定址指的是确定位置。开放定址法中，所有的元素都放在散列表中(链接法放在链表中)。也就是说散列表中的每一个位置，要么有元素，要么没有元素。当需要删除，查询元素时，我们从某一个位置开始，按照某种特定的确定下一个位置的方法来检查所有表项，直到找到目标元素，或者没有找到。7、A正确。Map是一个接口，hashtable,hashmap都是它的实现。 B正确。由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。 C正确。HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。 D Hashtable，key和value都不允许出现null值 2020/2/28Java第52套1、对于application，主线程main（)方法执行的线索，对于applet，主线程是浏览器加载并执行java的小程序2、For（i=0；i&lt;=n-1;i++) 执行n次For(j=n;j&gt;i;j–) 当i=1，n-1次，当i=2，n-2次 State n+n-1+n-2+。。。+2+1=n（n+1)/23、为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。 包的作用 1.把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。 2.如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。3.包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。包可见性控制机制4、1. 开放定址法：线性探测再散列、二次探测再散列、再随机探测再散列；2.再哈希法：换一种哈希函数；3.链地址法 ：在数组中冲突元素后面拉一条链路，存储重复的元素； 4.建立一个公共溢出区：其实就是建立一个表，存放那些冲突的元素。 什么时候会产生冲突 HashMap中调用hashCode()方法来计算hashCode。 由于在Java中两个不同的对象可能有一样的hashCode,所以不同的键可能有一样hashCode，从而导致冲突的产升。 HashMap底层是数组和链表 的结合体。底层是一个线性数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。数组是Entry[]数组，静态内部类。 Entry就是数组中的元素，每个 Map.Entry 其实就是一个key-value对，它持有一个指向下一个元素的引用next，这就构成了链表。所以很明显是链地址法。具体过程： 当我们往HashMap中put元素的时候：当程序试图将一个key-value对放入HashMap中时，1.程序首先根据该 key的 hashCode()返回值决定该 Entry 的存储位置； 2.若Entry 的存储位置上为 null，直接存储该对象；若不为空，两个Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同， 3.循环遍历链表，如果这两个Entry 的 key 通过 equals比较返回true，新添加 Entry 的 value 将覆盖集合中原有Entry 的 value，但key不会覆盖；如果这两个 Entry 的 key 通过 equals 比较返回false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于Entry 链的头部 在这里帮大家总结一下hashMap和hashtable方面的知识点吧： 关于HashMap的一些说法：a)HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。HashMap的底层结构是一个数组，数组中的每一项是一条链表。b)HashMap的实例有俩个参数影响其性能： “初始容量” 和 装填因子。c)HashMap实现不同步，线程不安全。HashTable线程安全d)HashMap中的key-value都是存储在Entry中的。e)HashMap可以存null键和null值，不保证元素的顺序恒久不变，它的底层使用的是数组和链表，通过hashCode()方法和equals方法保证键的唯一性f)解决冲突主要有三种方法：定址法，拉链法，再散列法。HashMap是采用拉链法解决哈希冲突的。注：链表法是将相同hash值的对象组成一个链表放在hash值对应的槽位；开放定址法解决冲突的做法是：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。沿此序列逐个单元地查找，直到找到给定的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。拉链法解决冲突的做法是： 将所有关键字为同义词的结点链接在同一个单链表中。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于1，但一般均取α≤1。拉链法适合未规定元素的大小。 Hashtable和HashMap的区别：a) 继承不同。public class Hashtable extends Dictionary implements Mappublic class HashMap extends AbstractMap implements Mapb) Hashtable中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。c) Hashtable 中， key 和 value 都不允许出现 null 值。 在 HashMap 中， null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为 null 。当 get() 方法返回 null 值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为 null 。因此，在 HashMap 中不能由 get() 方法来判断 HashMap中是否存在某个键， 而应该用 containsKey() 方法来判断。d) 两个遍历方式的内部实现上不同。Hashtable、HashMap都使用了Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式。e) 哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。f) Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。注： HashSet子类依靠hashCode()和equal()方法来区分重复元素。HashSet内部使用Map保存数据，即将HashSet的数据作为Map的key值保存，这也是HashSet中元素不能重复的原因。而Map中保存key值的,会去判断当前Map中是否含有该Key对象，内部是先通过key的hashCode,确定有相同的hashCode之后，再通过equals方法判断是否相同。5、 首先jvm中没有进程的概念，但是jvm中的线程映射为操作系统中的进程，对应关系为1：1。那这道题的问的就是jvm中线程如何异步执行 。在jvm中是使用监视器锁来实现不同线程的异步执行，在语法的表现就是synchronized。6、监视器：sysnchronized(Object o); o若为普通属性 o就是同步监视器 若为静态属性 则该类为同步监视器相当于synchronized(O.class) public synchronized void test(){} 同步监视器为调用该方法的对象7、 A、对。 B、对。C、错。匿名内部类用法与局部内部类不一致，首先从定义上就不一样，匿名类用在任何允许存在表达式的地方，而局部内部类用于在任何允许出现局部变量的地方出现。 还有更重要的是匿名类只能使用一次，而局部类则可以在自己的定义域内多次使用。D、错。静态内部类不能直接访问外部类的非静态成员，但可以通过new外部类（）.成员的方式访问。8、创建Statement是不传参的，PreparedStatement是需要传入sql语句preparedStatement和statement的区别与联系：在JDBC应用中,如果你已经是稍有水平开发者,你就应该始终以PreparedStatement代替Statement.也就是说,在任何时候都不要使用Statement。PreparedStatement接口继承Statement，PreparedStatement 实例包含已编译的 SQL 语句，所以其执行速度要快于 Statement 对象。1.Statement为一条Sql语句生成执行计划，如果要执行两条sql语句select colume from table where colume=1;select colume from table where colume=2;会生成两个执行计划 一千个查询就生成一千个执行计划！2.PreparedStatement用于使用绑定变量重用执行计划select colume from table where colume=:x;通过set不同数据只需要生成一次执行计划，可以重用 2020/2/29Java第53套1、 application对象是共享的，多个用户共享一个，以此实现数据共享和通信 JSP内置对象和属性列举如下： 1.request对象 客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。 2.response对象 response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。 3.session对象 session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例. 4.out对象 out对象是JspWriter类的实例,是向客户端输出内容常用的对象 5.page对象 page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例 6.application对象 application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。 7.exception对象 exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象 8.pageContext对象 pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。 9.config对象 config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象） 2、优化Hibernate所鼓励的7大措施： 1.尽量使用many-to-one，避免使用单项one-to-many 2.灵活使用单向one-to-many 3.不用一对一，使用多对一代替一对一 4.配置对象缓存，不使用集合缓存 5.一对多使用Bag 多对一使用Set 6.继承使用显示多态 HQL:from object polymorphism=”exlicit”避免查处所有对象 7.消除大表，使用二级缓存 Hibernate鼓励使用双向一对多关联，不使用单向一对多关联。单向一对多关联映射是在one端维护关系的，必须先保存many端后才可以保存one端，所以在保存many端时该端不知道one端是否存在相应的数据，所以只能将维护的关系字段设置为null，如果为非空则无法保存。因为是one端维护关系，所以在保存one端时，会发出多余的update语句维护many端的外键关系。 3、DriverManager.getConnection方法返回一个Connection对象，这是加载驱动之后才能进行的加载驱动方法 1.Class.forName(“com.microsoft.sqlserver.jdbc.SQLServerDriver”); 2.DriverManager.registerDriver(new com.mysql.jdbc.Driver());3.System.setProperty(“jdbc.drivers”, “com.mysql.jdbc.Driver”); 4、A. ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 //正确，这里的所谓动态数组并不是那个“ 有多少元素就申请多少空间 ”的意思，通过查看源码，可以发现，这个动态数组是这样实现的，如果没指定数组大小，则申请默认大小为10的数组，当元素个数增加，数组无法存储时，系统会另个申请一个长度为当前长度1.5倍的数组，然后，把之前的数据拷贝到新建的数组。 B. 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。//正确，ArrayList是数组，所以，直接定位到相应位置取元素，LinkedLIst是链表，所以需要从前往后遍历。 C. 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。//正确，ArrayList的新增和删除就是数组的新增和删除，LinkedList与链表一致。 D. ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间。//正确，因为ArrayList空间的增长率为1.5倍，所以，最后很可能留下一部分空间是没有用到的，因此，会造成浪费的情况。对于LInkedList的话，由于每个节点都需要额外的指针，所以，你懂的。5、根据《Java虚拟机规范》的规定，运行时数据区通常包括这几个部分：程序计数器(Program Counter Register)、Java栈(VM Stack)、本地方法栈(Native Method Stack)、方法区(Method Area)、堆(Heap)。实例变量就是没有加static的成员变量，也可以说是属性，静态变量就是加了static的成员变量，这种也叫类变量。这道题考的是JVM内存的规范，BC只是两个变量而已，所以是错的。 2020/3/1Java第54套1、javac-d 2、 for循环执行开始 首先执行out(‘A’) 输出A； 然后执行out(‘B’)&amp;&amp;(i&lt;2)此时输出B，i=0，判断条件为真，执行for循环的循环体； 执行i++，out(‘D’)，输出D i=1； 执行out(‘C’),输出C 然后执行out(‘B’)&amp;&amp;(i&lt;2) 此时输出B，i=1 判断条件为真 ，执行for循环的循环体； 执行i++，out(‘D’)，输出D i=2； 执行out(‘C’),输出C 然后执行out(‘B’)&amp;&amp;(i&lt;2) 此时输出B，i=2，不满足i&lt;2 判断条件为假 ，跳出循环； 所以结果为ABDCBDCB3、doGet/doPost 则是在 javax.servlet.http.HttpServlet 中实现的 4、重载是在同一个类中，有多个方法名相同，参数列表不同(参数个数不同，参数类型不同),与方法的返回值无关，与权限修饰符无关，B中的参数列表和题目的方法完全一样了。5、线程安全(Thread-safe)的集合对象： Vector 线程安全 HashTable 线程安全 StringBuffer 线程安全：非线程安全的集合对象： ArrayList LinkedList HashMap HashSet TreeMap TreeSet StringBulider：6、A: HashSet 它不是线程安全的，属于Set接口下的实现类，Set下的实现类特征就是无序，不允许存储相同的对象B: ConcurrentHashMap 它是线程安全的HashMap实现，特征也相似，其中存储的值对象可以重复，键对象不能重复C: Collection接口是List接口和Set接口的父接口，通常情况下不被直接使用D: ArrayList线程不安全的，底层是数组实现，允许存放重复对象7、HttpSessionAttributeListener：可以实现此侦听器接口获取此web应用程序中会话属性列表更改的通知； HttpSessionBindingListener：当该对象从一个会话中被绑定或者解绑时通知该对象，这个对象由HttpSessionBindingEvent对象通知。这可能是servlet程序显式地从会话中解绑定属性的结果，可能是由于会话无效，也可能是由于会话超时； HttpSessionObjectListener：没有该接口API；HttpSessionListener：当web应用程序中的活动会话列表发生更改时通知该接口的实现类，为了接收该通知事件，必须在web应用程序的部署描述符中配置实现类； HttpSessionActivationListener：绑定到会话的对象可以侦听容器事件，通知它们会话将被钝化，会话将被激活。需要一个在虚拟机之间迁移会话或持久会话的容器来通知所有绑定到实现该接口会话的属性。 2020/3/2Java第55套1、javac 将源程序编译成.class文件,字节码；java将字节码转为机器码.exe程序2、考察的是代码执行的顺序。 第5、12行属于static修饰的静态代码块。所以A、B说法错误。 静态代码块以及静态变量自上而下的顺序依次随着类加载而执行，所以依据题目的变量初始化： x初始为10 x+5赋值x，结果为15 x/3赋值给x，结果为53、this的作用其中一个就是在一个构造方法中调用另一个构造方法，格式为this(参数)； super是调用父类的方法；This.A(x) 普通方法Super（x) 父类方法A(a)这种形式是在new一个类时使用。4、Heap存放对象实例和数组substring实际是new，5字符 str3和4也都是new，每个5字符 分别都会创建新的对象 常量池是PermGen的 因此应该是一共15字符5、含有abstract修饰符的class即为抽象类，abstract类不能创建的实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。abstract class 类中定义抽象方法必须在具体 (Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。 接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。 下面比较一下两者的语法区别： 1.抽象类可以有构造方法，接口中不能有构造方法。 2.抽象类中可以有普通成员变量，接口中没有普通成员变量 3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。 4. 抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然 eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。 5. 抽象类中可以包含静态方法，接口中不能包含静态方法 6. 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。6、 java只是单继承，但是可以实现多个接口，继承的耦合性太强，java推荐高内聚低耦合的设计思路，不推荐使用继承。在用继承的情况下，如果还必须要继承另外的接口会很麻烦，尽量用接口，这样在你必须要用到继承的时候就可以用了。抽象类和接口都不能被实例化。接口没有构造方法，不能被实例化，但是抽象方法可以有构造方法，不过不是用来实例化对象的，使用来初始化的。抽象类和接口可以被声明使用。7、java中的数据类型分类：基本数据类型（或叫做原生类、内置类型）8种：整数：byte，short，int，long（默认是int类型） 浮点类型： float，double（默认是double类型） 字符类型：char 布尔类型：boolean引用数据类型3种：数组，类，接口其中，基本数据类型之间除了boolean，其他数据类型之间可以任意的相互转换（强制转化或默认转换），这个与c++中有点区别。 个人认为c定义数组的方式是正确的，只不过少了一个分号。java中定义数组有两种方式，一种是int[ ] number，一种是int number[ ]，推荐第一种，可读性更高。8、1、super()表示调用父类构造函数、this()调用自己的构造函数，而自己的构造函数第一行要使用super()调用父类的构造函数，所以这俩不能在一个构造函数中会出现重复引用的情况 2、super()和this()必须在构造函数第一行，所以这一点也表明他俩不能在一个构造函数中 3、this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块(里面不能使用非static类型的)。 2020/3/3Java第56套1、原生类是指Java中，数据类型分为基本数据类型（或叫做原生类、内置类型）和引用数据类型。 那么原生类为基本数据类型，有八种，这样转换的时候就有表达范围问题。 1、所占位数少的可以转换为所占位数多的类型，比如byte转char,char转int等； 2、而所占位数多的转为所占位数少的默认情况下不能实现转换，需要强制类型转换，这样可能会丢失一部分原始数据；3、此外，boolean类型数据和其他七种不能互相转换。2、 A: 垃圾回收在jvm中优先级相当相当低。 B：垃圾收集器（GC）程序开发者只能推荐JVM进行回收，但何时回收，回收哪些，程序员不能控制。 C：垃圾回收机制只是回收不再使用的JVM内存，如果程序有严重BUG，照样内存溢出。 D：进入DEAD的线程，它还可以恢复，GC不会回收3、Java的异常分为两种，一种是运行时异常（RuntimeException），一种是非运行异常也叫检查式异常（CheckedException）。1、运行时异常不需要程序员去处理，当异常出现时，JVM会帮助处理。常见的运行时异常有：ClassCastException(类转换异常) ClassNotFoundException IndexOutOfBoundsException(数组越界异常) NullPointerException(空指针异常) ArrayStoreException(数组存储异常，即数组存储类型不一致) 还有IO操作的BufferOverflowException异常2、非运行异常需要程序员手动去捕获或者抛出异常进行显示的处理，因为Java认为Checked异常都是可以被修复的异常。常见的异常有： IOException SqlException4、我是这么理解的，数组和对象都是在堆上分配内存的。创建的对象是通过java栈本地变量表中的reference指向堆中的地址，但是c中并没在堆中开辟内存，所以reference的值为null。当给a[0]=1的时候，reference=null，根本找不到地址，所以抛了空指针异常。在深入理解java虚拟机这本书里面对象的访问定位这一节，有关于堆中创建对象的过程。5、方法调用时，会创建栈帧在栈中，调用完是程序自动出栈释放，而不是gc释放6、7、接口和抽象类的区别： 1.接口的方法默认为public abstract ,接口中的变量默认为public static final，在java8之前所有的方法不能有实现抽象类中可以有非抽象方法 2.一个类可以实现多个接口，但只能继承一个抽象类 3.一个类实现接口，要实现该接口的所有抽象方法。 4.接口不能被实例化，但可以声明，但是必须引用一个实现该接口的对象。 抽象类可以有构造方法，但是不能被直接通过new进行实例化。但可以通过子类继承，实例化子类的时候抽象类也会被实例化。 这其实用到了多态，向上转型。父类引用指向子类对象。4.从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。 A B D显然都是对的。主要说C选项： 在JDK1.8之前的版本（不包括JDK1.8），接口中不能有静态方法，抽象类中因为有普通方法，故也可以有静态方法。 在JDK1.8后（包括JDK1.8），在抽象类中依旧可以有静态方法，同时在接口中也可以定义静态方法了。 以下代码在JDK1.8之后是没有问题的（可以通过接口名来调用静态方法 ：Main.prinf(); ）： public interface Demo{ public static void print() { System.out.println(“Hello World!”); }} PS：在JDK1.7，接口中只包含抽象方法，使用public abstract 修饰。 public interface Demo{ public abstract void method();}在JDK1.8，接口中新加了默认方法和静态方法：默认方法：使用default修饰，在接口的实现类中，可以直接调用该方法，也可以重写该方法。静态方法：使用static修饰，通过接口直接调用。 public interface Demo{ //默认方法 public default void method(){ System.out.println(“default method…”); } //静态方法 public static void print(){ System.out.println(“static method…”); }} 在JDK1.9，接口中新加了私有方法，使用private修饰，私有方法供接口内的默认方法和静态方法调用。 public interface Demo{ private void method() { System.out.println(“Hello World!”); }}8、内存如下：a -&gt; “a(b)”b -&gt; “b” a引用指向一块空间，这块空间里面包含着b对象 b引用指向一块空间，这块空间是b对象 A选项，b = null执行后b可以被垃圾回收。这里”b可以被垃圾回收”中的b指的是引用b指向的内存。这块内存即使不被引用b指向，还是被引用a指向着，不会被回收。 B选项，a = null执行后b可以被垃圾回收。从代码中可以看到，a = null是在b = null后执行的，该行执行后，引用a和b都没有指向对象，对象会被回收。 C选项，同理。 2020/3/4Java第57套1、 用new创建的对象在堆区 函数中的临时变量在栈去 java中的字符串在字符串常量区2、web容器：给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使 JSP,SERVLET直接更容器中的环境变量接**互，不必关注其它系统问题。主要有WEB服务器来实现。例如：TOMCAT,WEBLOGIC,WEBSPHERE等。该容器提供的接口严格遵守J2EE规范中的WEB APPLICATION 标准。我们把遵守以上标准的WEB服务器就叫做J2EE中的WEB容器。 EJB容器：Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件EJB各种管理功能。只要满足J2EE规范的EJB放入该容器，马上就会被容器进行高效率的管理。并且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。 JNDI：（Java Naming &amp; Directory Interface）JAVA命名目录服务。主要提供的功能是：提供一个目录系，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布式应用程序的功能。 JMS：（Java Message Service）JAVA消息服务。主要实现各个应用程序之间的通讯。包括点对点和广播。 JTA：（Java Transaction API）JAVA事务服务。提供各种分布式事务服务。应用程序只需调用其提供的接口即可。 JAF：（Java Action FrameWork）JAVA安全认证框架。提供一些安全控制方面的框架。让开发者通过各种部署和自定义实现自己的个性安全控制策略。 RMI/IIOP:（Remote Method Invocation /internet对象请求中介协议）他们主要用于通过远程调用服务。例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本地计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通信。RMI是JAVA特有的。3、 A：编译不成功，因为float浮点类型默认是double类型 所以float f=1.0f;（必须加上f强调定义的是float）此处是精度由高(double)向低(float)转型所以会报错 但是若是float f=1;这里是默认类型是Int 类型 精度由低(int)向高转型(float)不丢失精度不会报错。 B：this的使用时针对在方法内部使局部变量等值于实例变量而使用的一个关键字，此处的n是静态变量而非实例变量所以this的调用会出错（试想一下，static本来是全类中可以使用的，是全局的，你非得this去调用，这不是区分局部变量和实例变量的分水线吗？但是此处是全局的，不需要区分） C：m是实例变量，什么是实例变量：就是需要new 一个对象出来才能使用的，这里直接用类名就调用了，jvm怎么知道m是谁？ D：类变量可以通过类直接调用4、servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。CGI和servlet 的总结与对比：1.CGI: 主要用Perl、Shell Script或C编写 Servlet:用java语言编写2.CGI：每个请求都会启动一个新的进程，每个进程只为一个客户所服务，导致服务器内存和cpu开销大。 Servlet：每个请求会产生新的线程，而不是进程，减少系统中进程数量，并发处理能力强。多个客户能在同一个进程中的同时得到服务。3.CGI进程在服务完成后就被销毁，所以效率上低于servlet。 Servlet进程（实例）处于服务器进程中，只有在服务器被卸载时才会被卸载。4..CGI是不可移植的，是运行于特定平台上的。 Servlet是可移植的，运行于JVM上的。5、“==”：作用是判断两个对象的地址是否相等，即，判断两个对象是不是同一个对象，如果是基本数据类型，则比较的是值是否相等。“equal”：作用是判断两个对象是否相等，但一般有两种使用情况1.类没有覆盖equals()方法,则相当于通过“==”比较2.类覆盖equals()方法，一般，我们都通过equals()方法来比较两个对象的内容是否相等，相等则返回true,如String 地址比较是通过计算对象的哈希值来比较的，hashcode属于Object的本地方法，对象相等（地址相等），hashcode相等，对象不相等，hashcode()可能相等，哈希冲突6、两个对象的equals比较为true，那么他们的HashCode一定相同，反之，两个对象的HashCode相同不一满足equals比较为true，解释一下为什么，这是因为HashCode采用的其实是一种杂凑算法，当然，这业务Java认为最有效的算法，既然是凑出来的那么就有一种情况就是两个不同的对象返回相同的hashCode，并且这种算法越糟糕返回相同的概率越大7、1、abstract类不能用来创建abstract类的对象；2、final类不能用来派生子类，因为用final修饰的类不能被继承；3、如2所述，final不能与abstract同时修饰一个类，abstract类就是被用来继承的；4、类中有abstract方法必须用abstract修饰，但abstract类中可以没有抽象方法，接口中也可以有abstract方法。8、final修饰类、方法、属性！不能修饰抽象类，因为抽象类一般都是需要被继承的，final修饰后就不能继承了。 final修饰的方法不能被重写而不是重载！ final修饰属性，此属性就是一个常量，不能被再次赋值！9、float f =45.0f;Double d = 100.0;char s =’\\u0639’ Unicode 标量值； 2020/3/5Java第58套1、Object 是基类 Java中的所有的类都直接或间接的继承；所以A对 从一个class派生的必然是另一个class。Object是一个class，如果interface继承自Object，那么interface必然是一个class，所以B错 利用equals()方法进行比较时 会调用== 可以看equals()方法的源码，可以这样说， == 比equal更加强大，所以C错 toString()方法是Object类中 即使不重写也能使用 所以D错2、switch break才跳出 类的加载包括：加载，验证，准备，解析，初始化。 选项A：生成java.lang.Class对象是在加载时进行的。生成Class对象作为方法区这个类的各种数据的访问入口。 选项B：既然是对象成员，那么肯定在实例化对象后才有。在类加载的时候会赋予初值的是类变量，而非对象成员。 （int类型对象成员变量赋予默认值不属于类加载） 选项C：这个会调用。可以用反射试验。 选项D：类方法解析发生在解析过程。3、在使用匿名内部类的过程中，我们需要注意如下几点： 1、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。2、匿名内部类中是不能定义构造函数的。3、匿名内部类中不能存在任何的静态成员变量和静态方法。4、匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。5、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。4、首先是foo(0),在try代码块中未抛出异常，finally是无论是否抛出异常必定执行的语句，所以 output += “3”;然后是 output += “4”; 执行foo(1)的时候，try代码块抛出异常，进入catch代码块，output += “2”; 前面说过finally是必执行的，即使return也会执行output += “3” 由于catch代码块中有return语句，最后一个output += “4”不会执行。 所以结果是34235、Boolean修饰的变量为包装类型，初始化值为false,进行赋值时会调用Boolean.valueOf(boolean b)方法自动拆箱为基本数据类型，因此赋值后flag值为true，输出文本true。 如果使用==比较,则输出文本false。if的语句比较，除boolean外的其他类型都不能使用赋值语句，否则会提示无法转成布尔值。 2020/3/7Java第60套1、A.由于y的值不确定，所以要加锁；x=yB,C 两个在多线程情况下是必须要加锁的，因为他们是先被读入寄存器，然后再进行+1操作，如果没有加锁，那么可能会出现数据异常；D 原子操作，所以不需要加锁原子性：指该操作不能再继续划分为更小的操作。Java中的原子操作包括1.除long和double之外的基本类型的赋值操作2.所有引用reference的赋值操作3.java.concurrent.Atomic.* 包中所有类的一切操作2、 A| |B C | DD属于B,D属于A,D属于D,D不属于C3、创建对象是直接分配内存地址，不存在扩容得操作，如果是添加元素超过容量，则会存在扩容的概念4、5、 模型(model)它是应用程序的主体部分，主要包括业务逻辑模块（web项目中的Action,dao类）和数据模块（pojo类）。模型与数据格式无关，这样一个模型能为多个视图提供数据。由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。视图(view) 用户与之交互的界面、在web中视图一般由jsp,html组成。 控制器(controller)接收来自界面的请求 并交给模型进行处理 在这个过程中控制器不做任何处理只是起到了一个连接的作用。 本题中显然D错误，应该是控制器接收请求，并将其交给模型进行处理，正确答案为A,B,C.","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lijiale96.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://lijiale96.github.io/tags/Java/"},{"name":"牛客","slug":"牛客","permalink":"https://lijiale96.github.io/tags/%E7%89%9B%E5%AE%A2/"}]},{"title":"Spring Boot 二","slug":"Spring Boot 二","date":"2020-03-06T06:12:00.000Z","updated":"2020-03-10T16:05:03.286Z","comments":true,"path":"2020/03/06/Spring Boot 二/","link":"","permalink":"https://lijiale96.github.io/2020/03/06/Spring%20Boot%20%E4%BA%8C/","excerpt":"二、配置文件1、配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的 application.properties application.yml","text":"二、配置文件1、配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的 application.properties application.yml 配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot底层都给我们自动配置好； YAML(YAML Ain‘t Markup Language） YAML A Markup Language：是一个标记语言 YAML isn’t Markup Language：不是一个标记语言； 标记语言： 以前的配置文件；大多都使用的是xxx.xml文件； YAML： 以数据为中心，比json、xml等更适合做配置文件； YAML： 配置实例 12server: port: 8081 XML： 12345678910111213 &lt;server&gt; &lt;port&gt;8081 &lt;/port&gt; &lt;\\server&gt;:``` ## 2、YAML语法### 1、 基本语法k:（空格）v 表示一对键值对（空格必须有）；以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一层级的```javaserver: port: 8081 path: /hello 属性和值也是大小写敏感； 2、值得写法字面量：普通的值（数字，字符串，布尔）k: v : 字面直接来写 字符串默认不用加上单引号或者双引号； “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 name： “zahngsan \\n lisi” :输出；zhangsan 换行 lisi ‘’：单引号； 会转义特殊字符，特殊字符最终只是一个普通的字符串数据 name： ‘zahngsan \\n lisi’：输出；zhangngsan \\n lisi 对象（属性和值）（键值对): k: v : 在下一行来写对象的属性和值得关系；注意缩进 对象还是 k: v 的方式 123456789 friendds： lastName：zahngsan age： 20 ``` 行内写法：```javafriends: &#123;lastName: zahngsan,age: 18&#125; 数组（List、Set）：用-值表示数组中的一个元素 1234pets:- cat- dog- pig 行内写法 1pets: [cat,dog,pig] 3、配置文件值注入1、properties配置文件咋idea中默认utf-8可能会乱码配置文件 123456789101112person: lastName: lijiale age: 25 boss: false birth: 1996/05/12 maps: &#123;k1: v1,k2: 12&#125; lists: - zhangyuxin - zaholiu dog: name: 黄狗 age: 6 javaBean: 123456789101112131415161718192021/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定; * prefix = \"person\": 配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能 */@Component@ConfigurationProperties(prefix = \"person\")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt;maps; private List&lt;Object&gt; lists; private Dog dog; 我们可以导入配置文件处理器，以后编写配置就有提示了 123456&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 注： 12345import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;@RunWith(SpringRunner.class) @Autowired @RunWith就是一个运行器 @RunWith(JUnit4.class)就是指用JUnit4来运行 @RunWith(SpringJUnit4ClassRunner.class),让测试运行于Spring测试环境 @RunWith(Suite.class)的话就是一套测试集合 2、@Value与@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 注： - 松散绑定指 person.last-name = person.lastName - SpEL支持表达式 - JSR303数据校验：@Validated，可以按邮箱格式填写 配置文件yml还是properties他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取运行配置文件中的某项值，使用@Value 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用 @ConfigurationProperties； 3、配置文件注入值数据校验1234567891011121314151617181920212223@Component@ConfigurationProperties(prefix = \"person\")@Validatedpublic class Person &#123; /** * &lt;bean class=\"Person\"&gt; * &lt;property name = \"LastName\" value=\"字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEl&#125;\"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 @Email @Value(\"$&#123;person.last-name&#125;\") private String lastName; @Value(\"#&#123;12*2&#125;\") private Integer age; @Value(\"true\") private Boolean boss; private Date birth; private Map&lt;String,Object&gt;maps; private List&lt;Object&gt; lists; private Dog dog; 4、@ProPropertySource &amp; @ImportResource@ProPropertySource ：加载指定的配置文件 12345678910111213141516171819202122232425262728/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定; * prefix = \"person\": 配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationPropertie(prefix = \"person\")默认从全局配置文件中获取值； */@PropertySource(value=&#123;\"classpath:person.properties\"&#125;)@Component@ConfigurationProperties(prefix = \"person\")//@Validatedpublic class Person &#123; /** * &lt;bean class=\"Person\"&gt; * &lt;property name = \"LastName\" value=\"字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEl&#125;\"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 //@Email // @Value(\"$&#123;person.last-name&#125;\") private String lastName; //@Value(\"#&#123;12*2&#125;\") private Integer age; // @Value(\"true\") private Boolean boss; @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别；想让Spring的配置文件生效，加载起来； @ImportResource标注在一个配置类上 12 @ImportResource(locations = &#123;\"classpath:beans.xml\"&#125;)@SpringBootApplication 不来编写Spring的配置文件 1234567 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id =\"helloService\" class=\"com.atguigu.springboot.service.HelloService\"&gt;&lt;/bean&gt;&lt;/beans&gt; Spring Boot推荐给容器中添加组件的方式；推荐使用全注解的方式 1、配置类=======Spring配置文件 2、使用@Bean给容器中添加组件 12345678910111213141516/** * @Configuration:指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件 */@Configurationpublic class MyAppConfig &#123; //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService()02&#123; System.out.println(\"配置类@Bean给容器中添加了组件了。。。\"); return new HelloService(); &#125;&#125; 4、配置文件占位符1、随机数12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int(1024、65536&#125;&#125; 2、占位符获取之前配置的值，如果没有可以使用：指定默认值123456789person.last-name=阿康$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2020/3/7person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_黄狗person.dog.age=6 5、Profile1、多Profile文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml默认使用application.properties的配置； 2、yml支持多文档块方式123456789101112131415161718server: port: 8081spring: profiles: active: prod---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod #指定属于哪个环境 3、激活指定profile1、在配置文件中指定 spring.profiles.active=dev 2、命令行的激活 java -jar spring-boot-02-config-0.01-SNAPSHOT.jar--spring.profiles.active=dev 可以直接再测试的时候，配置传入命令行参数 IDEA：edit configuration——Program arguments 3、虚拟机参数： VM options-Dspring.profiles.active=dev6、配置文件加载位置 springboot启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件 -file:./config/ -file:./ -classpath:/config/ -classpath:/ 优先级由高到低，高优先级的配置会覆盖低优先级的配置 SpringBoot会从这四个位置全部加载主配置文件；互补配置； 123456server.port=8081#配置项目的访问路径server.servlet.context-path=/boot02 spring.config.location=D:/application.properties （只改变外部新加的配置，保留原先的配置） 我们还可以通过spring.config.location来改变默认的配置文件位置 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置。 7、外部配置加载顺序SpringBoot也可以从以下位置加载配置；优先级从高到低；高优先级的配置覆盖低优先级的配置；所有的配置会形成互补配置1.命令行参数java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087 –server.servlet.context-path=/abc 多个配置用空格分开； –配置项=值 2.来自java：comp/env的NDI属性3.Java系统属性（System.getProperties())4.操作系统环境变量5.RandomValuePropertySource配置的random.*属性值 由jar包外向jar包内进行寻找；优先加载带profile6.jar包外部的application-{profile}.properties或application.yml（带spring.profile）配置文件7.jar包内部的application-{profile}.properties或application.yml（带spring.profile）配置文件 再来加载不带profile8.jar包外部的application.properties或application.yml（不带spring.profile）配置文件9.jar包内部的application.properties或application.yml（不带spring.profile）配置文件 10.@Configuration注解类上的@PropertySource11.通过SpringApplication.setDefaultProperties的指定默认属性所有支持的配置加载来源；参考官方文档 8、配置文件写什么？怎么写？自动配置原理 1、自动配置原理：1）SpringBoot启动的时候加载主配置类，开启了自动配置功能@EnableAutoConfiguration2）@EnableAutoConfiguration作用： 利用@AutoConfigurationSelector给容器中导入一些组件 可以插件selectImports（）方法的内容 ist configurations = this.getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置 1234SpringFactoriesLoader.loadFactoryNames（）扫描所有jar包类路径下 META-INF/spring.factories吧扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中 将类路径下 META-INF/spring.factories里面配置的所有EnableAutoConfiguration 的值加入到了容器中；123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.cloud.CloudServiceConnectorsAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveRestClientAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.rest.RestClientAutoConfiguration,\\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\\org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\\org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\\org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\\org.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration,\\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\\org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration 每一个这样的xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； 3）每一个自动配置类进行自动配置功能；4）以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理 123456789101112131415161718192021222324252627282930313233343536373839@Configuration( proxyBeanMethods = false)//表示这是一个配置类，也可以给容器中添加组件@EnableConfigurationProperties(&#123;HttpProperties.class&#125;) //启动指定类的ConfigurationProperties功能；将配置文件对应的值和HttpEncodeingProperties绑定起来；并把HttpEncodingProperties加入到Spring容器中@ConditionalOnWebApplication( type = Type.SERVLET)//Spring底层@Conditional注解，根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;) //判断当前项目有没有这个类，CharacterEncodingFilter；在SpringMVC中进行乱码解决的过滤器@ConditionalOnProperty( prefix = \"spring.http.encoding\", value = &#123;\"enabled\"&#125;, matchIfMissing = true)//判断配置文件是否存在某个配置 spring.http.encoding.enabled;如果不存在，判断也是成立的//即使我们配置文件中不配置spring.http.encoding.enabled=true，也是生效的public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot配置文件映射了 private final Encoding properties; //只有一个有参构造器的启动下，参数的值就从容器中拿 public HttpEncodingAutoConfiguration(HttpProperties properties) &#123; this.properties = properties.getEncoding(); &#125; @Bean //给容器中添加一个组件，这个组件的某些值从properties获取 @ConditionalOnMissingBean //判断容器中没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断，决定整个配置类是否生效？一旦这个配置类生效；这个配置就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 5) 所有配置文件中能配置的属性都是在xxxProperties类中封装者；配置文件能配置什么就可以参照某个功能对应的这个属性类 123456@ConfigurationProperties( prefix = \"spring.http\"//从配置文件中获取指定的值和bean的属性进行绑定)public class HttpProperties &#123; private boolean logRequestDetails; private final HttpProperties.Encoding encoding = new HttpProperties.Encoding(); 精髓：1） SpringBoot启动会加载大量的自动配置类2） 我们看我们需要的功能有没有SpringBoot默认写好的自动配置类;3) 我们再来看这个自动配置类到底配置了哪些组件（只要我们用的组件有，我们就不需要再配置了）4） 给容器中中自动配置类添加组建的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值；xxxxAutoConfiguration：自动配置类；给容器中添加组件xxxxProperties：封装配置文件中相关属性 2、细节1、@Conditional派生注解（Spring注解版原生的@Conditional作用）作用： 必须是@Conditional指定的条件成立，才给容器中添加组件，配置里面的所有内容才能生效 自动配置类必须在一定条件下才能生效我们怎么知道哪些自动配置类生效 我们可以通过启用debug =true属性，来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置了生效 123456789101112131415161718192021222324252627282930313233343536============================CONDITIONS EVALUATION REPORT============================Positive matches:（自动配置类启用的）----------------- AopAutoConfiguration matched: - @ConditionalOnProperty (spring.aop.auto=true) matched (OnPropertyCondition) AopAutoConfiguration.ClassProxyingConfiguration matched: - @ConditionalOnMissingClass did not find unwanted class 'org.aspectj.weaver.Advice' (OnClassCondition) - @ConditionalOnProperty (spring.aop.proxy-target-class=true) matched (OnPropertyCondition) DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet' (OnClassCondition) - found 'session' scope (OnWebApplicationCondition) DispatcherServletAutoConfiguration.DispatcherServletConfiguration matched: - @ConditionalOnClass found required class 'javax.servlet.ServletRegistration' (OnClassCondition) - Default DispatcherServlet did not find dispatcher servlet beans (DispatcherServletAutoConfiguration.DefaultDispatcherServletCondition)Negative matches:没有启用，没有匹配成功的自动配置类----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required class 'javax.jms.ConnectionFactory' (OnClassCondition) AopAutoConfiguration.AspectJAutoProxyingConfiguration: Did not match: - @ConditionalOnClass did not find required class 'org.aspectj.weaver.Advice' (OnClassCondition)","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lijiale96.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://lijiale96.github.io/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lijiale96.github.io/tags/Spring-Boot/"}]},{"title":"Maven","slug":"Maven","date":"2020-03-04T07:12:00.000Z","updated":"2020-03-10T14:22:57.599Z","comments":true,"path":"2020/03/04/Maven/","link":"","permalink":"https://lijiale96.github.io/2020/03/04/Maven/","excerpt":"Maven1、Maven简介Maven 是目前流行的自动化构建工具，对于生产环境下多框架、多模块整合开发有重要作用。Maven 是一款在大型项目开发过程中不可或缺的重要工具。本课程将帮助你了解 Maven 的作用，常用命令，如何配置依赖，以及依赖的范围、依赖的传递性、依赖的排除、生命周期等重要概念，以及继承、聚合这样的 Maven 配置。更会手把手教你在 Eclipse 中玩转 Maven。","text":"Maven1、Maven简介Maven 是目前流行的自动化构建工具，对于生产环境下多框架、多模块整合开发有重要作用。Maven 是一款在大型项目开发过程中不可或缺的重要工具。本课程将帮助你了解 Maven 的作用，常用命令，如何配置依赖，以及依赖的范围、依赖的传递性、依赖的排除、生命周期等重要概念，以及继承、聚合这样的 Maven 配置。更会手把手教你在 Eclipse 中玩转 Maven。 2、具体描述Maven是一个跨平台的项目管理工具，主要用于基于java平台的项目构建，依赖管理。 ![enter description here][2] 3、作用1.有好几个项目，需要用到很多相同的jar包，只解决一个仓库来解决2.测试方法全部运行3.把一个模块的功能放入到仓库中 4、下载安装链接：https://pan.baidu.com/s/1Er27UN69Jd30e7Wba6H4PQ提取码：ovbghttps://blog.csdn.net/westos_linux/article/details/78968012?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task","categories":[{"name":"Maven","slug":"Maven","permalink":"https://lijiale96.github.io/categories/Maven/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://lijiale96.github.io/tags/Java/"},{"name":"Maven","slug":"Maven","permalink":"https://lijiale96.github.io/tags/Maven/"}]},{"title":"Spring Boot  一","slug":"Spring Boot 一","date":"2020-03-04T06:12:00.000Z","updated":"2020-03-06T08:00:12.567Z","comments":true,"path":"2020/03/04/Spring Boot 一/","link":"","permalink":"https://lijiale96.github.io/2020/03/04/Spring%20Boot%20%E4%B8%80/","excerpt":"一、Spring Boot入门1、Spring Boot简介简化Spring应用开发的一个框架整个Spring技术栈的一个大整合J2EE开发的一站式解决方法 2、微服务2014，martin fowler微服务：架构风格一个应用应该是一组小型服务；可以通过HTTP的方式进行互通； 每一个功能元素最终都是一个可独立替换和独立升级的软件单元 对比：牵一发而动全身","text":"一、Spring Boot入门1、Spring Boot简介简化Spring应用开发的一个框架整个Spring技术栈的一个大整合J2EE开发的一站式解决方法 2、微服务2014，martin fowler微服务：架构风格一个应用应该是一组小型服务；可以通过HTTP的方式进行互通； 每一个功能元素最终都是一个可独立替换和独立升级的软件单元 对比：牵一发而动全身 详细参照微服务文档：https://mp.weixin.qq.com/s?__biz=MjM5MjEwNTEzOQ==&amp;mid=401500724&amp;idx=1&amp;sn=4e42fa2ffcd5732ae044fe6a387a1cc3#rd 先学Spring+Maven 环境约束-jdk1.8；Spring Boot1.7及以上-maven3.x：3.3及以上-IDEA2019-SpringBoot1.5.9 1、Maven设置给maven的settings.xm配置文件的profiles标签添加 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; 2、IDEA4、Spring Boot HelloWorld功能：浏览器发送hello请求，服务器接收请求并处理，响应Hello World字符串 1、创建一个maven过程;（jar）2、导入依赖spring boot相关的依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.1.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3、编写一个主程序；启动Spring Boot应用123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; //Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; 4、编写相关的Controller、Service123456789@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping(\"/hello\") public String hello()&#123; return \"Hello World!\"; &#125;&#125; 5、运行主程序测试6、简化1234567891011 &lt;!--这个插件，可以将应用打包成一个可执行的jar包；--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;将这个应用打成jar包，直接使用java -jar的命令进行执行；tomcat已经配置好 5、Hello World探究1、 POM文件1. 父项目 1234567891011121314 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;他的父项目 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;他来真正管理Spring Boot应用里面的所有依赖版本 Spring Boot的版本仲裁中心；以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号） 2.导入的依赖（启动器） 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; spring-boot-starter-web: spring-boot-starter: spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件 Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里引入这些starters相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 2、主程序类，主入口类 1234567891011 /** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; //Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; @SpringBootApplication：Spring Boot 应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用 12345678910111213141516 @Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration:Spring Boot 的配置类； 标注在某个类上，表示这是一个SpringBoot的配置类； @Configuration：配置类上标注这个注解（Spring ) 配置类 ——配置文件;配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能； 以前我们需要配置的东西，Spring Boot帮我们自动配置； @EnableAutoConfiguration 告诉SpringBoot开启自动配置功能；这样自动配置才能生效； 123@AutoConfigurationPackage@Import(&#123;EnableAutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123; @AutoConfigurationPackage:自动配置包 @Import(AutoConfigurationPackageRegistrar.class): Spring的底层注解@import，给容器中导入一个组件；导入的组件由 AutoConfigurationPackageRegistrar.class 将主配置类（@SpringBootApplication标注的类)的所在包及下面所有子包里面的所有组件扫描到Spring容器； @Import({EnableAutoConfigurationImportSelector.class})； 给容器中导入组件？ EnableAutoConfigurationImportSelector：导入哪些组件的选择器； 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中 会给容器中导入非常多的自动配置类（xxAutoConfiguration):就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，免去了我们手动去编写配置注入功能组件等的工作； SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class, ClassLoader()); SpringBoot在启动的时候从类路径下的META-INF/spring.factories获取EnableAutoConfiguration的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作； 以前我们需要自己配置的东西，自动配置类都帮助我们； J2EE整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar 6、使用Spring Initializer快速创建Spring Boot项目 IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目； 选择我们需要的模块；向导会联网创建SpringBoot项目； 默认生成的Spring Boot项目； 主程序研究已经生成好了，我们只需要我们自己的逻辑 resources文件夹 static： 保存所有的静态资源；js css images； templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持jsp页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot应用的配置文件；","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lijiale96.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://lijiale96.github.io/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://lijiale96.github.io/tags/Spring-Boot/"}]},{"title":"Spring","slug":"Spring","date":"2020-03-04T06:12:00.000Z","updated":"2020-03-10T14:22:50.068Z","comments":true,"path":"2020/03/04/Spring/","link":"","permalink":"https://lijiale96.github.io/2020/03/04/Spring/","excerpt":"Spring1、Spring简介一个开源框架为简化企业级应用开发而生Spring是一个IOC(DI)和AOP容器框架","text":"Spring1、Spring简介一个开源框架为简化企业级应用开发而生Spring是一个IOC(DI)和AOP容器框架 2、具体描述-轻量级：Spring是非侵入的-基于Spring开发的应用对象开源不依赖于Spring的API-依赖注入（DI-dependency injection IOC）控制反转-面向切面编程（AOP-aspect oriented programming）——&gt;代码解耦-容器：因为它包含并且管理应用对象的生命周期-框架：Spring实现了使用简单的组件配置组合成一个复杂的应用。在Spring中可以使用XML和Java注解组合这些对象-一站式：在IOC和AOP的基础上整合各种企业应用的开源框架和优秀的第三方类库（实际上Spring自身也提供了展现层的SpringMVC和持久层的Spring JDBC）","categories":[{"name":"Spring","slug":"Spring","permalink":"https://lijiale96.github.io/categories/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://lijiale96.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://lijiale96.github.io/tags/Spring/"}]},{"title":"如何写好一篇论文的引言","slug":"如何写好一篇论文的引言","date":"2020-02-18T05:34:18.000Z","updated":"2020-02-21T13:33:38.959Z","comments":true,"path":"2020/02/18/如何写好一篇论文的引言/","link":"","permalink":"https://lijiale96.github.io/2020/02/18/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E4%B8%80%E7%AF%87%E8%AE%BA%E6%96%87%E7%9A%84%E5%BC%95%E8%A8%80/","excerpt":"SCI 论文成功的第一步，如何写好引言 “引言”( introduction)是一篇论文的引导语或开场白( preamble)。“引言”又称前言(preface)、导言( leadin)、序言( foreword)或绪言( preface)等,在科技论文中,英语一般仅用“introduction”。按照“IMRaD”格式的要求,每篇论文都以“引言”开始。它是正文的引子,属于整篇论文的引论部分,写在正文之前。论文的“引言”,主要用以说明论文的主题和总纲。因此,“引言”应该对正文起到提纲挈领和引起阅读兴趣的作用。正如北卡罗来纳大学( University of North Carolina)“Writing Center”所说的“引言”和“结论”是架在你和读者之间的桥梁,它为读者提供一个自身世界与论文所谈内容之间的过渡。“引言”也像一把钥匙,为读者打开你论文主题的大门提供了必备工具。另外,也可以把“引言”视为一幅十分重要的导航图,它为读者进入你论文的境界提供了详尽的路线。看来,“引言”在引导读者阅读论文的诸方面起着不可忽视的重要作用。","text":"SCI 论文成功的第一步，如何写好引言 “引言”( introduction)是一篇论文的引导语或开场白( preamble)。“引言”又称前言(preface)、导言( leadin)、序言( foreword)或绪言( preface)等,在科技论文中,英语一般仅用“introduction”。按照“IMRaD”格式的要求,每篇论文都以“引言”开始。它是正文的引子,属于整篇论文的引论部分,写在正文之前。论文的“引言”,主要用以说明论文的主题和总纲。因此,“引言”应该对正文起到提纲挈领和引起阅读兴趣的作用。正如北卡罗来纳大学( University of North Carolina)“Writing Center”所说的“引言”和“结论”是架在你和读者之间的桥梁,它为读者提供一个自身世界与论文所谈内容之间的过渡。“引言”也像一把钥匙,为读者打开你论文主题的大门提供了必备工具。另外,也可以把“引言”视为一幅十分重要的导航图,它为读者进入你论文的境界提供了详尽的路线。看来,“引言”在引导读者阅读论文的诸方面起着不可忽视的重要作用。 在科技论文中,撰写“引言”的目的是让作者对进行本项研究工作的背景材料、研究的动机和原因、试图达到什么目的等作出必要的说明,让读者对该项研究有足够的了解和认识。按中国国家标准 GB/T7713-1987 规定,“引言”(或绪论)应简要说明研究工作的目的、范围、相关领域的前人工作和知识空白、理论基础和分析、研究设想、研究方法和实验设计、预期结果和意义等。威斯康星大学Kliewer 教授(2005)在他的论著 Writing It up: A Step-by- Step Guide to Publication for Beginning Investigators 中也十分强调“引言”的作用:“引言的目的是要提供本研究的基础背景材料和你研究的动机( motivation)及与现行研究的全面关系。”“引言”应言简意赅、简明扼要。“引言”不可与摘要雷同,更不可成为摘要的注释。可以说,一篇好的“引言”是论文成功的一半,你应多下工夫撰写“引言”,特别是“引言”的第一句话,因为你不可能有第二次机会给你的读者留下第一印象。那么如何写好引言呢？ 首先，是背景资料。通常在“引言”的开始,首先应该简述你所研究领域的背景材料,也就是历史的回顾。正如 Cetin 和 Hackam 所说:“The first question involves addressing what known about the topic”即说明所研究间题的总体现状、历史情况、你研究的动机,以及与全局的联系( context)和相关性。需要注意的是,这种历史的回顾应该密切结合你的研究主题,而且是极其简要的、提纲挈领式的,绝不可以面面俱到。否则,阐述详尽的背景资来可能诱导你把“引言”变成一篇相当篇幅的“综述”而误入歧途。这种写法常见于“manu”的第一稿,虽不可取,但绝不可怕,说明你阅读了大量的文献资料。你可以修改再改,简化再简化。千万不要吝惜你费力收集到的资料,必要时要大刀阔斧地削减，,最终形成简而明的“引言”维形。请看以下例句：Example Title ：The com bination of raltitrexed (tomudex）and mitomycin-C in the treatment of advanced colorectal cancer-A phaseⅡ study. Michels等(2006)在联合用药治疗结肠直肠癌的研究时,在引言中首先简述了结肠直肠癌的研究背景。他们是这样开始的：The part of introduction ：Colorectal cancer is the second most common cancer worldwide, according for 500 000 deaths annually. The annual incidence in the UK is 35 000 patients, and it is the second most common cause death in the UK. Chemotherapy has been shown to improve overall survival and quality of life in patients with advanced colorectal cancer[. For the past 40 years, the main treatment has been 5-fluorouracil(5-FU), which acts by inhibiting thymidylate synthase. The 5-FU schedule for the treatment of advanced colorectal cancer has been debated, and, until recently, has been the only thymidylate synthase inhibitor available . It is usually given by bolus intravenous Injection, often in combination with leucovorin or as an infusional regimen. 从 J Michels 等的这段描述背景的引言中可以看出,作者只用了 6 句话,106 个字就概述了结肠癌、直肠癌的流行病学及其治疗的现况。这是十分简要和十分精炼的概括性描述。需要注意的是作者在此引用了 5 篇参考文献,这些资料为简化“引言”中的文字起了十分重要的作用。因此,引证是撰写“引言”的基本条件,没有引证,“引言”就不复存在另外,引用这些文献也明确地告诉读者,这些背景材料绝非虚构,而是有根有据的。 其次是进展和问题。在你研究的领域里,当前的进展状况如何?存在的缺欠和不足(deficient)是什么?存在的问题及问题的重要性在哪里?在简述当前有关研究的来龙去脉、关键性的术语及概念之后,应明确地把问题提到读者的面前,并且说明问题的重要性,综述有关研究,提出争论或未解决的问题,未测试的群体和未经实验的方法等。同时说明它的重要性,使编者和读者都深切地感到此问题亟待解决。毫无疑义,在这里需要引用相关领域的权威文献以便让读者确信你所提出的问题的重要性和可靠性。Example Title : Antioxidant property of ginsenoside Re in cardiomyocytes.The part of introduction ：As alluded to above, the pharmacological properties of ginseng are mainly attributed to ginsenosides, the bioactive constituents that are found in the extracts of different parts of ginseng. We analyzed six major ginsen asides(Rb, Rb2, Rc, Rd, Re, and RgI )in American ginseng berry extract by using high performance liquid chromatography( HPLC)and found that the rank order of the total ginsenosides concentration is leaf&gt; berry &gt;root. Our results also indicated that the le specific ginsenoside re is more abundant in the leaf and berry than in he root.So far, there are no data available in the literature with regard to theantioxidant property of Re. Therefore, the aim of the present study is to further explore the antioxidant activity of ginsenoside re in cultured chick cardiomyocytes and cell-free chemical systems in vitrro.在《人参皂苷 Re 对心肌细胞的抗氧化作用》一文中,作者在简述 Re 研究的背景材料和研究进展之后,明确地说明了所存在的问题,即到目前为止,尚无有关 Re抗氧化作用的详细报道资料可被利用,紧接着就提出本研究的目的等。这种写法不仅合乎情理,而且是很容易被理解和接受的。 再次，如何解决这些问题? 在提供当前研究所存在的问题和不足的基础上,明确提出你研究解决这些问题的思路、设想和办法,简述你的实验设计、方法、路线及研究的理论基础等。简言之,就是如何通过你的实验研究,回答前面所提出的问题。通过这段叙述,让读者确信:①问题的提出是有根据的;②解决问题的设想和方案是有道理的(特别强调其独特性和优越性);③整个“引言”的思路是顺理成章的。具有这 3 条评价,应该说这篇“引言”是成功之作。例如,Shao 等在《美国人参果提取物对心肌细胞的抗氧化作用》一文的“引言”中,较为详细地介绍了解决所提出问题的具体方案和方法,并说明了为什么采用这种方案和方法,以及这一方法的可靠性。这种写法可以让读者明显地感觉到这一研究方法和实施的方案是有根据的、切实可行的。Example Title: Antioxidant effects of American ginseng berry extract in cardiomyocytes exposed to acute oxidant stress.The part of introduction: Since the ginsenoside profile for the berry is different compared to the root, we proposed to evaluate if AGBE has antioxidant properties similar to those observed in the commonlyconsumed American ginseng root. In this study, we used cultured chick cardiomyocytes exposed to exogenous H₂O₂ or antimycin A, a mitochondrial electron transport chain (ETC)site Ⅲ inhibitor. This cardiomyocyte model of acute oxidant stress has been successfully used in this our previous studies. Acute oxidant injury can be generated consistently in this model measured as signiticantlyincreased oxidant-dependent fluorescence and decreased cardiomyocyte viability. Effective protection by administration of antioxidant compounds to the cardiomyocyte culture prevented the pathological consequences of acute oxidant injury. We, therefore, used this model in the present study to investigate acute antioxidant effects of AGBE.再次，是有什么重要发现。在“引言”中是否可以简明扼要地指出本研究的重要发现呢?有人说发现属于实验结果,不应在“引言”中阐述。笔者并不认同这一观点。研究的成果或发现诚然是研究结果,必然需要在“结果”中详尽地描述,并在“讨论”中重点析、讨论、引申和探讨,但并不排除在“引言”之末尾,在说明如何解决这些问题及所取得成果之后,画龙点睛地指明你的重要发现,强调你的重要成果,这完全是顺理成章且符合逻辑的事。这样做既没有“多余累赘”之缺点,也无“画蛇添足”之弊端,反而在文章之初就让读者清楚地看到你的重要成果和发现,何乐而不为呢?但是,需要注意的是,这一做法都要符合目标杂志的要求。另外,在“引言”中说明成果,务必非常简洁扼要,常常只用一句话就应足可说明问题。 值得提到的是,国内外一些刚刚涉足生物医学科技论文写作的年轻作者会有另一种错误的考虑。他们把最重要的发现保留到论文的最后才表述出来。他们既不在“摘要”中提及,也不在“引言”中陈述他们的重要发现。他们希望使用“一鸣惊人”的悬念,制造出个“出人意料”的结果。其实,读者阅读科技论文不同于文学作品。这种故弄玄虚的论文写作方法只能让读者感觉论文过于枯燥,读不到作者设计的高潮之处而彻底放弃。(1)在你所研究的领域中还存在什么问题需要解决?(2)这些问题有什么重要价值?为什么值得研究?(3)你计划怎样去研究?即 6.2.3 中所说的如何解决现存的这些问题？一个好的引言是具有吸引力和诱读力的,因为它把鲜明而具有兴趣性的问题摆在了读者面前,从而达到引导读者阅读全文的目的。 最后，什么时候写“引言”最合适，一般作者大都是先撰写“引言”,笔者也不例外。好像总感觉不写完“引言”,往后写不下去似的,这也许是一种写作的习惯,很难改变。有些人甚至不把标题想好就下不了笔,连一个字也写不下去。但是,从习惯或道理上讲,先写引言未必对每个作者都是正确的或最好的方法,也不一定总是写好“引言”的最有效的途径( You may think that you have to write your introduction first, but that isn’t necessarily true, and it isn’t always the most effective way to craft a good introduction From University of North Caroline)。其原因可能有以下 3 个方面。(1)你可能会发现在撰写论文过程之初,你并不知道哪些争论的问题值得在“引言”中提出来。而只是通过写论文的整个过程,你就会发现争论的焦点所在,应该如何表述(2)整个写作过程是你组织论点、思考议题、发展思维、精炼争论的过程,而在写论文之初,往往在论点、议题、思维和争论等诸多问题上都有待深入和锤炼。(3)最后再写引言很容易与整体论文相配合,相呼应( The introduction matches the body of the paper),而不致使“引言”与后继部分脱节。习惯于先写“引言”的作者,在完成论文之后,回过头来再依照这三方面修改“引言”,未必不是明智之举。","categories":[{"name":"科研","slug":"科研","permalink":"https://lijiale96.github.io/categories/%E7%A7%91%E7%A0%94/"}],"tags":[{"name":"论文","slug":"论文","permalink":"https://lijiale96.github.io/tags/%E8%AE%BA%E6%96%87/"},{"name":"引言","slug":"引言","permalink":"https://lijiale96.github.io/tags/%E5%BC%95%E8%A8%80/"}]},{"title":"船舶轨迹背景及研究意义","slug":"船舶轨迹跟踪的背景及研究意义","date":"2020-02-17T08:12:00.000Z","updated":"2020-02-18T06:40:08.477Z","comments":true,"path":"2020/02/17/船舶轨迹跟踪的背景及研究意义/","link":"","permalink":"https://lijiale96.github.io/2020/02/17/%E8%88%B9%E8%88%B6%E8%BD%A8%E8%BF%B9%E8%B7%9F%E8%B8%AA%E7%9A%84%E8%83%8C%E6%99%AF%E5%8F%8A%E7%A0%94%E7%A9%B6%E6%84%8F%E4%B9%89/","excerpt":"","text":"背景 船舶航迹的精确跟踪能力是保证船舶航行安全,省时节能的一种重要技术前提。船舶航迹跟踪是指船舶在航迹制导器和动态跟踪控制器的共同作用下,能够沿着指令航线航行。传统的航向自动舵因其无法直接控制航迹偏差而无法实现航迹的精确控制,然而随着科学技术的发展,高精度差分GPS的出现使得船舶航迹控制成为可能。但由于船舶在航行中易受风、浪、流等环境因素的影响,其中以海浪干扰尤为严重,必然会出现航迹偏差问题,考虑到船舶自身携带能量有限,应该尽量减小实际航线与指令航线的偏差,如何对变化未知的海浪干扰进行估计并加以抑制就成为了船舶航迹跟踪领域急待解决的研究难题。 研究意义 船舶的控制技术在研究上具有非常重要的实际价值和理论意义：其一路径跟踪问题是船舶控制领域的一个热点问题，对于无人船尤为重要。其二，用饱和RISE的方法抑制或补偿干扰的水面船舶的轨迹跟踪还没有解决，可为实际工程奠定理论基础。","categories":[],"tags":[{"name":"科研","slug":"科研","permalink":"https://lijiale96.github.io/tags/%E7%A7%91%E7%A0%94/"}]},{"title":"牛客错题整理（12-46）","slug":"牛客Java刷题整理 12-46","date":"2020-02-17T08:12:00.000Z","updated":"2020-03-06T07:03:37.770Z","comments":true,"path":"2020/02/17/牛客Java刷题整理 12-46/","link":"","permalink":"https://lijiale96.github.io/2020/02/17/%E7%89%9B%E5%AE%A2Java%E5%88%B7%E9%A2%98%E6%95%B4%E7%90%86%2012-46/","excerpt":"2020-1-19Java第12套1、父类引用指向子类对象2、类是单继承（extends），接口可以多继承，多实现3、抽象类只能用来继承4、内部类可以是静态static，也可用public，default，protected，private修饰5、外部类修饰符只能是public，abstract，final6、static 是类属性，不管有多少对象，都共用一个变量。/静态属性对所有对象共用7、方法重载的返回值的类型可以不同，方法重载的方法主要是根据方法的参数不同来判定；方法重写的返回值类型需要相同，重写就是子类继承了父类的方法，并在此方法上重写属于自己的特征，既然是继承过来的，那么它的返回值类型就必须要相同。","text":"2020-1-19Java第12套1、父类引用指向子类对象2、类是单继承（extends），接口可以多继承，多实现3、抽象类只能用来继承4、内部类可以是静态static，也可用public，default，protected，private修饰5、外部类修饰符只能是public，abstract，final6、static 是类属性，不管有多少对象，都共用一个变量。/静态属性对所有对象共用7、方法重载的返回值的类型可以不同，方法重载的方法主要是根据方法的参数不同来判定；方法重写的返回值类型需要相同，重写就是子类继承了父类的方法，并在此方法上重写属于自己的特征，既然是继承过来的，那么它的返回值类型就必须要相同。 8、 涉及继承： a.初始化父类中的静态成员变量和静态代码块 b.初始化子类中的静态成员变量和静态代码块 c.初始化父类的普通成员变量和构造代码块(按次序)，再执行父类的构造方法 d.初始化子类的普通成员变量和构造代码块(按次序)，再执行子类的构造方法 */class X { {System.out.print(“1”);} Y y=new Y(); public X(){ System.out.print(&quot;X&quot;); } {System.out.print(&quot;2&quot;);}}class Y{ public Y(){ System.out.print(“Y”); }}public class Z extends X { {System.out.print(“3”);} Y y=new Y(); public Z() { System.out.print(“Z”); } {System.out.print(“4”);} public static void main(String[] args) { new Z(); }} result：1Y2X3Y4Z9、本题是一个自动拆装箱的考题(自动拆装箱JDK需在1.5上），下面的讨论都不针对新开辟对象的情况： 1）、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true； 2）、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。 3）、两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true 4）、基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。 int a=257; Integer b=257; Integer c=257; Integer b2=57; Integer c2=57; System.out.println(a==b); //System.out.println(a.equals(b)); 编译出错，基本型不能调用equals() System.out.println(b.equals(257.0)); System.out.println(b==c); System.out.println(b2==c2); 因此上面的代码的结果因此为 true, false, false, true10、JVM功能：1)通过ClassLoador寻找和装载class文件2)解释字节码称为指令并执行，提供class文件的运行环境3)进行运行期间垃圾回收4)提供与硬件交互的平台11、wait()、sleep()、yield()的理解1）wait()是Object的实例方法，在synchronized同步环境使用，作用当前对象，会释放对象锁，需要被唤醒。运行状态到阻塞状态2）sleep()是Thread的静态方法，不用在同步环境使用，作用当前线程，不释放锁。运行状态到阻塞状态 Wait() 从运行状态到等待队列3）yield()是Thread的静态方法，作用当前线程，释放当前线程持有的CPU资源，将CPU让给优先级不低于自己的线程用，调用后进入就绪状态。12、map 与 multimap是存储key-value（键-值 对）类型的容器。不同之处在于：map只允许key与 value一一对应；multimap一个key可对应多个value； 而且map和multimap都是由RB_tree（红黑树）来实现的，本就合适于查找，复杂度为 O( ln(N) )UNordered_set ,unordered_map是由hash_table(哈希表)来实现的，时间复杂度为o(1) deque的push_back, push_front, pop_back, pop_front操作时间复杂度为O(1) 2020-1-20Java第13套1、RMI（remote method invocation）远程方法调用是一种计算机之间利用远程对象互相调用实现双方通讯的一种通讯机制。采用TCP/IP的通信协议。2、依赖注入（Dependency Injection，简称DI）是一个重要的面向对象编程的法则来削减计算机程序的耦合问题。依赖注入应用比较广泛。可以使应用程序的配置和依赖性规范与实际的应用程序代码分开。其中一个特点就是通过文本的配置文件进行应用程序组件间相互关系的配置，而不用重新修改并编译具体的代码。 因此依赖注入降低了组件之间的耦合性，而不是使组件之间相互依赖。3、Thread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。 结论：yield()从未导致线程转到等待眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。4、java中的构造方法构造方法的特点：构造方法的方法名与类名相同 构造方法没有返回值类型，也不写void 构造方法可以重载什么时候会用到构造方法：在创建对象的时候构造方法的作用：创建对象的时候给属性赋初值构造方法的分类：显示的构造方法和隐式地构造方法显示的构造方法：显示的写出构造方法时，系统不会提供默认的无参构造方法隐式地构造方法：系统默认提供的无参构造方法代码块：分类：静态代码块和实例代码块静态代码块：static修饰的代码块，在类加载时执行，且只执行一次。因为类就加载一次了。 实例代码块：没有static修饰的代码块，创建对象时执行，每创建一次对象加载一次。实例代码块在执行构造方法之前执行。所以优先级高于构造方法。5、数组声明必须确定行数，列数随意。6、小数如果不加 f 后缀，默认是double类型。double转成float向下转换，意味着精度丢失，所以要进行强制类型转换。 是使用unicode表示的字符，\\u0639是一个unicode 占两个字节，代表一个字符。’f’ 字符会自动装箱成包装类，就可以向上转型成Object了。整数默认是int类型，int类型不能转型为Double，最多通过自动装箱变为Integer但是Integer与Double没有继承关系，也没法进行转型。 2020-1-21Java第14套1、Array_a[10]—–下标为10的元素，则数组长度为112、数组arr有.length属性，String类型是.length()方法,集合list是.size()方法， int m[]={0,1,2,3,4,5,6} 共有7个元素，数组的下标最大为6，m.length的值为7数组下标从0开始是长度-13、 粉红色的是受检查的异常(checked exceptions),其必须被try{}catch语句块所捕获,或者在方法签名里通过throws子句声明.受检查的异常必须在编译时被捕捉处理,命名为 Checked Exception 是因为Java编译器要进行检查,Java虚拟机也要进行检查,以确保这个规则得到遵守. 绿色的异常是运行时异常(runtime exceptions),需要程序员自己分析代码决定是否捕获和处理,比如空指针,被0除… 而声明为Error的，则属于严重错误，如系统崩溃、虚拟机错误、动态链接失败等，这些错误无法恢复或者不可能捕捉，将导致应用程序中断，Error不需要捕捉。 4、ConcurrenrHashMap 采用了分段锁hashMap在单线程中使用大大提高效率，在多线程的情况下使用hashTable来确保安全。hashTable中使用synchronized关键字来实现安全机制，但是synchronized是对整张hash表进行锁定即让线程独享整张hash表，在安全同时造成了浪费。concurrentHashMap采用分段加锁的机制来确保安全Arrays.asList方法返回的这个List的实现类是java.util.Arrays.ArrayList这个类(而不是java.util.ArrayList)。SimpleDateFormat对象是线程不安全的有Synchronized是安全的5、dubbo远程调用可以有这么一个本地存根，场景是：用户要远程调用资源进行登录页面才能访问资源，但是无论登录成功还是不成功都得远程调用，这样就浪费了资源，所以我们就把验证这部分工作放在本地执行（本地存根），当用户验证（验证码等）工作放在本地，stub存根决定是否远程调用，也就是动态链接（动态连接使得大部分的连接过程延迟,直到程序开始运行）。6、类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（ Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的 Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM 不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（ rt.jar ）；Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是 Bootstrap；system class loader：又叫应用类加载器，其父类是 Extension。它是应用最广泛的类加载器。它从环境变量 classpath或者系统属性java.class.path 所指定的目录中记载类，是用户自定义加载器的默认父加载器。用户自定义类加载器：java.lang.ClassLoader的子类父类委托机制是可以修改的，有些服务器就是自定义类加载器优先的。7、MVC：Model VIew Controller 减弱业务逻辑接口与数据接口的耦合性Struts是MVC 的一种实现，一个structs可以有多个Servlet 8、抽象类 特点: 1.抽象类中可以构造方法 2.抽象类中可以存在普通属性，方法，静态属性和方法。 3.抽象类中可以存在抽象方法。 抽象方法无方法体即{} 4.如果一个类中有一个抽象方法，那么当前类一定是抽象类；抽象类中不一定有抽象方法。 5.抽象类中的抽象方法，需要有子类实现，如果子类不实现，则子类也需要定义为抽象的。 接口 1.在接口中只有方法的声明，没有方法体。 2.在接口中只有常量，因为定义的变量，在编译的时候都会默认加上public static final 接口允许定义成员，但必须是常量。 3.在接口中的方法，永远都被public来修饰。 4.接口中没有构造方法，也不能实例化接口的对象。 5.接口可以实现多继承 ，类只能单继承 6.接口中定义的方法都需要有实现类来实现，如果实现类不能实现接口中的所有方法 7.则实现类定义为抽象类。 9、成员方法=实例方法，静态方法=类方法静态方法用static修饰，没有this指针，可以在类方法中生成实例对象再调用实例方法，类方法可以调用其他类的static方法 Java第15套1、如果有public类的话，是要求源文件名称和外部公共类一样的，如果文件中没有公共类的话，则文件名和类名不做强制要求 当编写一个java源代码文件时，此文件通常被称为编译单元（有时也被称为转译单元）。每个编译单元都必须有一个后缀名.java，而在编译单元内则可以有一个public类，该类的名称必须与文件的名称相同（包括大小写，但不包括文件的后缀名.java）。每个编译单元只能有一个public类，否则编译器就不会接受。如果在该编译单元之中还有额外的类的话，那么在包之外的世界是无法看见这些类的，这是因为它们不是public类，而且它们主要用来为主public类提供支持。 –《Java 编程思想》注：public类不是必须的，但是如果源文件中有一个（只能有一个）public类的话，文件名必须与这个public类同名，原因是为了方便虚拟机在相应的路径中找到相应的类所对应的字节码文件。所以在没有public类的Java文件中，文件名和类名都没什么联系。2、一个java文件里可以有多个class,但是只能有一个public class外部类，并且类名必须和.java文件名相同3、普通类是一个完善的功能类，可以直接产生实例化对象，并且在普通类中可以包含有构造方法、普通方法、static方法、常量和变量等内容。而抽象类是指在普通类的结构里面增加抽象方法的组成部分。 那么什么叫抽象方法呢？在所有的普通方法上面都会有一个“{}”，这个表示方法体，有方法体的方法一定可以被对象直接使用。而抽象方法，是指没有方法体的方法，同时抽象方法还必须使用关键字abstract做修饰。 而拥有抽象方法的类就是抽象类，抽象类要使用abstract关键字声明。 范例：定义一个抽象类abstract class A{//定义一个抽象类public void fun(){//普通方法System.out.println(“存在方法体的方法”);} public abstract void print();//抽象方法，没有方法体，有abstract关键字做修饰}4、采用命令行“ java Test one two three ”调用其中Test为调用的方法，而one two three则为Test方法里面main函数的参数System.out.println(args[0]);表示输出第一个元素，故为one；5、正则表达式：以#开头，后面是数字和a-f的字符（大写或小写），这个值是6位或3位。要匹配一个3位是为了符合16进制颜色的简写规则 /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g6、java中有四大修饰符，分别为private,default,protected,public,下面主要是四者之间的区别： private(私有的)private可以修饰成员变量，成员方法，构造方法，不能修饰类(此刻指的是外部类，内部类不加以考虑)。被private修饰的成员只能在其修饰的本类中访问，在其他类中不能调用，但是被private修饰的成员可以通过set和get方法向外界提供访问方式 default(默认的)default即不写任何关键字，它可以修饰类，成员变量，成员方法，构造方法。被默认权限修饰后，其只能被本类以及同包下的其他类访问。 protected(受保护的)protected可以修饰成员变量，成员方法，构造方法，但不能修饰类(此处指的是外部类，内部类不加以考虑)。被protected修饰后，只能被同包下的其他类访问。如果不同包下的类要访问被protected修饰的成员，这个类必须是其子类。 public(公共的)public是权限最大的修饰符，他可以修饰类，成员变量，成员方法，构造方法。被public修饰后，可以再任何一个类中，不管同不同包，任意使用。 public protected default private 同一个类 √ √ √ √同一个包 √ √ √其他包子类 √ √不同包 √7、final static answer=42 没写属性 int8、Const goto 是Java的保留字，所有关键字都是小写，如implements、instanceofSizeof是c\\c++的方法goto和const是保留字也是关键字。关键字列表 (依字母排序共50组)：abstract, assert, boolean, break, byte, case, catch, char, class, const（保留关键字）,continue, default, do, double, else, enum, extends, final, finally,float, for, goto（保留关键字）, if,implements, import, instanceof, int, interface, long, native, new,package, private, protected, public, return, short, static, strictfp,super, switch, synchronized, this, throw, throws, transient, try, void, volatile, while保留字列表 (依字母排序共14组)，Java保留字是指现有Java版本尚未使用，但以后版本可能会作为关键字使用：byValue, cast, false, future,generic, inner, operator, outer, rest, true, var, goto （保留关键字）, const （保留关键字）, null9、一个字符常量为一个字符或一个转义序列，被一对单引号关闭；双引号关闭是字符串常量2020-1-22Java第16套1、Javadoc用来识别注释2、Java没有指针，只有引用。并不是程序结束的时候进行GC，GC的时间是不确定的，且GC的过程需要经过可达性分析，一个对象只有被标记两次才会被GC下图是一个对象被GC的全过程。c是面向过程，java和c++都是面向对象，面向对象的三大特征是：封装、继承、多态。 3、Math.cos为计算弧度的余弦值，Math.toRadians函数讲角度转换为弧度 计算余弦值使用Math类的cos()方法 toRadians()是将角度转换为弧度 toDegrees()是将弧度转换为角度4、（1）从速度上看：System.arraycopy &gt; clone &gt; Arrays.copyOf &gt; for （2）for的速度之所以最慢是因为下标表示法每次都从起点开始寻位到指定下标处（现代编译器应该对其有进行优化，改为指针），另外就是它每一次循环都要判断一次是否达到数组最大长度和进行一次额外的记录下标值的加法运算。 （3）查看Arrays.copyOf的源码可以发现，它其实本质上是调用了System.arraycopy。之所以时间差距比较大，是因为很大一部分开销全花在了Math.min函数上了。5、线程安全的map:HashTable,SynchronizedMap,ConcurrentHashMapHashtable的方法都是synchrnized修饰的线程安全，ConcurrentHashMap并发容器，JDK7采用分段锁，JDK8采用CAS算法，线程安全，建议使用，Connections工具类提供了一个方法synchrnizedMap可以把Map同步，本质就是给每一个方法加上synchrnized关键字进行同步6、A、java为单继承，多实现。可以实现多个接口。 B、接口允许定义成员，但必须是常量。 C、抽象类和接口类的无法实例化，任何编译器中直接使用new会报错。 D、同A，单继承，多实现。7、栈内存中存放函数中定义的一些基本类型的变量和对象的引用变量；堆内存中存放new创建的对象和数组。简单的来说，堆主要是用来存放对象的，栈主要是用来执行程序的 这么做是因为 栈的存取速度快，栈数据可以共享，但是栈中的数据大小和生存期必须确定，缺乏灵活性中存放一些基本类型的对象和对象句柄堆是操作系统分配给自己内存，由于从操作系统管理的内存分配，所以再分配和销毁时都需要占用时间，因此用堆的效率非常低，但是优点在于编译器不需要指导从堆里分配多少存储控件，也不需要知道存储的数据要再堆里停留多长事件，因此用堆保存数据时会得到更大的灵活性在函数中定义的变量不能与其所在函数的形参同名8、三元操作符类型的转换规则： 1.若两个操作数不可转换，则不做转换，返回值为Object类型 2.若两个操作数是明确类型的表达式（比如变量），则按照正常的二进制数字来转换，int类型转换为long类型，long类型转换为float类型等。 3.若两个操作数中有一个是数字S,另外一个是表达式，且其类型标示为T，那么，若数字S在T的范围内，则转换为T类型；若S超出了T类型的范围，则T转换为S类型。 4.若两个操作数都是直接量数字，则返回值类型为范围较大者9、三元操作符如果遇到可以转换为数字的类型，会做自动类型提升。比如 Object o1 = (false) ? new Double(1.0) : new Integer(2);System.out.println(o1); 会打印2.010、finally语句块： 1、不管有木有出现异常，finally块中代码都会执行； 2、当try和catch中有return时，finally仍然会执行； 3、finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的； 4、finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。 举例： 情况1：try{} catch(){}finally{} return; 显然程序按顺序执行。 情况2:try{ return; }catch(){} finally{} return; 程序执行try块中return之前（包括return语句中的表达式运算）代码；再执行finally块，最后执行try中return; finally块之后的语句return，因为程序在try中已经return所以不再执行。 情况3:try{ } catch(){return;} finally{} return; 程序先执行try，如果遇到异常执行catch块，有异常：则执行catch中return之前（包括return语句中的表达式运算）代码，再执行finally语句中全部代码，最后执行catch块中return. finally之后也就是4处的代码不再执行。无异常：执行完try再finally再return. 情况4:try{ return; }catch(){} finally{return;} 程序执行try块中return之前（包括return语句中的表达式运算）代码；再执行finally块，因为finally块中有return所以提前退出。 情况5:try{} catch(){return;}finally{return;} 程序执行catch块中return之前（包括return语句中的表达式运算）代码；再执行finally块，因为finally块中有return所以提前退出。 情况6:try{ return;}catch(){return;} finally{return;} 程序执行try块中return之前（包括return语句中的表达式运算）代码；有异常：执行catch块中return之前（包括return语句中的表达式运算）代码；则再执行finally块，因为finally块中有return所以提前退出。无异常：则再执行finally块，因为finally块中有return所以提前退出。 最终结论：任何执行try 或者catch中的return语句之前，都会先执行finally语句，如果finally存在的话。如果finally中有return语句，那么程序就return了，所以finally中的return是一定会被return的，编译器把finally中的return实现为一个warning。 Java第17套1、A是抽象方法，抽象类可以包含抽象方法，也可以不包含，实现重载。（√） B 在类中不能constInt = constInt + 5（×） C 返回值不能作为重载的依据（×）重载只是名称不同而已 a、参数个数不同 b、参数类型不同 c、参数顺序不同 D 有方法体的不能作为抽象函数（×）2、Java 中的堆是 JVM 所管理的最大的一块内存空间，主要用于存放各种类的实例对象。 在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。 堆的内存模型大致为： 从图中可以看出： 堆大小 = 新生代 + 老年代。其中，堆的大小可以通过参数 –Xms、-Xmx 来指定。3、a++ + a–，a=10，结果为10+11=214、桥接模式： 定义：将抽象部分与它的实现部分分离，使它们都可以独立地变化。 意图 ：将抽象与实现解耦。 桥接模式所涉及的角色 Abstraction：定义抽象接口，拥有一个Implementor类型的对象引用 RefinedAbstraction：扩展Abstraction中的接口定义 Implementor：是具体实现的接口，Implementor和RefinedAbstraction接口并不一定完全一致，实际上这两个接口可以完全不一样Implementor提供具体操作方法，而Abstraction提供更高层次的调用 ConcreteImplementor ：实现Implementor接口，给出具体实现Jdk中的桥接模式：JDBCJDBC连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不动，原因就是JDBC提供了统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了5、A，Thread可以被继承，用于创建新的线程B Number类可以被继承，Integer，Float，Double等都继承自Number类C Double类的声明public final class Doubleextends Numberimplements Comparable final声明的类不能被继承D，Math类的声明为public final class Mathextends Object 不能被继承E，ClassLoader可以被继承，用户可以自定义类加载器6、 只看尖括号里边的！！明确点和范围两个概念 如果尖括号里的是一个类，那么尖括号里的就是一个点，比如List,List,List 如果尖括号里面带有问号，那么代表一个范围，代表小于等于A的范围，代表大于等于A的范围，代表全部范围 尖括号里的所有点之间互相赋值都是错，除非是俩相同的点 尖括号小范围赋值给大范围，对，大范围赋值给小范围，错。如果某点包含在某个范围里，那么可以赋值，否则，不能赋值 List&lt;?&gt;和List 是相等的，都代表最大范围 7.补充：List既是点也是范围，当表示范围时，表示最大范围下面贴代码：（本来用的Eclipse截图的，结果好像网站出来Bug，不能传图了public static void main(String[] args) {List a; List list; list = a; //A对，因为List就是List，代表最大的范围，A只是其中的一个点，肯定被包含在内 List b;a = b; //B错，点之间不能相互赋值 List qm;List o;qm = o; //C对，List&lt;?&gt;代表最大的范围，List只是一个点，肯定被包含在内List d; List&lt;? extends B&gt; downB; downB = d; //D对，List&lt;? extends B&gt;代表小于等于B的范围，List是一个点，在其中List&lt;?extends A&gt; downA; a = downA; //E错，范围不能赋值给点a = o; //F错，List只是一个点downA = downB; //G对，小于等于A的范围包含小于等于B的范围，因为B本来就比A小，B时A的子类嘛 2020-1-23Java第18套1、Java子类重写继承的方法时,不可以降低方法的访问权限，子类继承父类的访问修饰符要比父类的更大，也就是更加开放，假如我父类是protected修饰的，其子类只能是protected或者public，绝对不能是friendly(默认的访问范围)或者private，当然使用private就不是继承了。还要注意的是，继承当中子类抛出的异常必须是父类抛出的异常的子异常，或者子类抛出的异常要比父类抛出的异常要少。2、A错误，类的实例方法是与该类的实例对象相关联的，不能直接调用，只能通过创建超类的一个实例对象，再进行调用 B错误，当父类的类方法定义为private时，对子类是不可见的，所以子类无法调用 C错误，子类具体的实例方法对父类是不可见的，所以无法直接调用，只能通过创建子类的一个实例对象，再进行调用 D正确，实例方法可以调用自己类中的实例方法3、重写 要求两同两小一大原则，方法名相同，参数类型相同，子类返回类型小于等于父类方法返回类型， 子类抛出异常小于等于父类方法抛出异常，子类访问权限大于等于父类方法访问权限。［注意：这里的返回类型必须要在有继承关系的前提下比较］重载 方法名必须相同，参数类型必须不同，包括但不限于一项，参数数目，参数类型，参数顺序 再来说说这道题A B 都是方法名和参数相同，是重写，但是返回类型没与父类返回类型有继承关系，错误D 返回一个类错误C的参数类型与父类不同，所以不是重写，可以理解为广义上的重载访问权限小于父类，都会显示错误虽然题目没点明一定要重载或者重写，但是当你的方法名与参数类型与父类相同时，已经是重写了，这时候如果返回类型或者异常类型比父类大，或者访问权限比父类小都会编译错误4、中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。中间件位于客户机/服务器的操作系统之上，管理计算机资源和网络通讯。是连接两个独立应用程序或独立系统的软件。相连接的系统，即使它们具有不同的接口，但通过中间件相互之间仍能交换信息。执行中间件的一个关键途径是信息传递。通过中间件，应用程序可以工作于多平台或OS环境。 （简单来说，中间件并不能提高内核的效率，一般只是负责网络信息的分发处理）5、枚举类有三个实例，故调用三次构造方法，枚举类构造方法只能加private修饰符6、Java标识符由数字，字母和下划线（_），美元符号（$）组成。在Java中是区分大小写的，而且还要求首位不能是数字。最重要的是，Java关键字不能当作Java标识符。7、线程的互斥锁机制：synchronized，lock，condition前半句话讲的是创建线程的方式，后半句讲的是锁定，驴头不对马嘴。线程调度分为协同式调度和抢占式调度，Java使用的是抢占式调度，也就是每个线程将由操作系统来分配执行时间，线程的切换不由线程本身来决定（协同式调度）。这就是平台独立立的原因。2020-1-24Java第19套1、在 final 定义的方法里，不是必须要用 final 定义变量。 final定义的变量，可以在不是必须要在定义的同时完成初始化，也可以在构造方法中完成初始化。final修饰方法，不能被子类重写，但是可以被重载。final 定义变量，可以用static 也可以不用。2、栈区：存放函数的参数、局部变量等 堆区：存放对象 全局区(静态区)：存放全局变量和静态变量 常量区：存放常量字符串 代码区：存放函数体的二进制代码3、构造函数不能被继承，构造方法只能被显式或隐式的调用。4、方法的重写规则（两同两小一个大）参数列表必须完全与被重写方法的相同；返回类型必须完全与被重写方法的返回类型相同； 父类是A类型，子类是A类或A类的子类（更小）访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。父类的成员方法只能被它的子类重写。声明为final的方法不能被重写。声明为static的方法不能被重写，但是能够被再次声明。子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。异常更小构造方法不能被重写。如果不能继承一个方法，则不能重写这个方法。“二同”：即方法名相同，形参列表相同；“二小”：返回值类型、抛出异常更小；“一个大”:子类方法的访问修饰符应比父类方法更大或相等；5、重载（overloading） 动词 overload 本就是超载的意思，名字为 A 的一个方法，却承载着多个功能，不就是 overloading 了么，这也是 Java 为我们提供的多种编写构造器来构造对象的一种机制。 一些类有多个构造器，e.g. 你可以这样构造一个空 StringBuilder 对象： StringBuilder messages = new StringBuilder(); or StringBuilder todoList = new StringBuilder(“To do:\\n”); 这就是 overloading。当多个方法具有相同的名字且拥有不同的参数时，就会出现重载，由编译器决定调用哪个方法，这个过程被称为 overloading resolution（重载解析）。 Java 允许重载任何方法，要完整的描述一个方法，需要指出方法名和参数类型，这叫做方法的签名（signature），e.g. String 有四个 public 的 indexOf 方法，它们的签名是：indexOf(int) indexOf(int, int) indexOf(String) indexOf(String, int)需要注意的是，返回类型并不是 signature 的一部分，也就是说，编译器无法通过返回类型来区分不同的重载方法，因此，重载方法是同名不同参的方法，与返回类型无关。 覆盖（override）当父类中的一些方法对子类不适用时，就需要提供一个新的方法来 override 父类中的这个方法。那么既然是对父类的override，就不能去修改这个方法的签名，只能对内部做调整，而且不仅仅是签名不能改，方法返回类型以及访问权限也不能改。因此，当发现子类中某个方法和父类的签名相同时，那么这一定是override 而不是overload。在编写代码时，建议在覆盖一个方法时加上 @override，除了标识的作用，它还会帮助你检查你覆盖的这个方法是否在父类中真的存在。6、 java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。 java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。7、接口中字段的修饰符：public static final（默认不写） 接口中方法的修饰符：public abstract（类和方法）（默认不写）8、suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的 resume() 被调用，才能使得线程重新进入可执行状态9、A.类的成员变量包括实例变量和类变量（静态变量）,成员方法包括实例方法和类方法（静态方法）。 A正确 B.类变量（静态变量）用关键字static声明，B错误 C.方法中的局部变量在方法被调用加载时开始入栈时创建，方法入栈创建栈帧包括局部变量表操作数栈，局部变量表存放局部变量，并非在执行该方法时被创建，C错误 D.局部变量被使用前必须初始化，否则程序报错。D正确 2020-1-26Java第20套1、数组声明为什么这么写？ 第一个就是为什么左边不用标大小，而右边需要标大小？首先数组一个对象，它不属于任何类，由jvm在运行期间在堆中创建并继承object，同时添加length属性。由于数组对象所占的内存在堆上，所以在声明时应明确告诉jvm自己所占的大小，方便分配，又因为数组对象的引用在栈中，所以声明时左边就无需标大小，之所以写成2个括号，就是为了表明这个引用指向堆中的二维数组。 第二个就是为什么右边数组可以只声明几行，无需声明没行的大小？大概jvm在运行期间会根据行数分配对应的可扩展空间，方便每一行进行扩充。其实又可以按c语言那样理解，行其实又是一种引用，行首地址又代表一个一维数组。欢迎大佬对第二问题进行补充。2、remove 删除元素3、1.一个对象成为垃圾，是因为没有引用指向它 2.一个对象成为垃圾之后，等待垃圾回收器收集 3.什么时候收集要看垃圾回收器什么时候运行。4.垃圾被收集之前，会调用垃圾对象的finalize（）方法。5.finalize方法也可以主动使用4、 switch语句后的控制表达式只能是short、char、int、long整数类型和枚举类型，不能是float，double和boolean类型。String类型是java7开始支持。5、java中标识符的组成：由52个字母A-Z ，a-z ，数字0-9 ，下划线_ ， 美元符$ 组成6、+=会自动强转（自动装箱功能），但是+必须要手动强转b=(byte)(a+b)7、抽象类中可以构造方法8、 A.一个文件中，可以有多个public class public class Main { public class Inner{ }} 即，外部类为public，还可以有public的内部类。 B.一个文件中可以有多个类，可以是多个并列的类，也可以是外部类、内部类结合。 C.一个类中，可以有多个main方法，这是重载，但是public static void main(String[] args)的方法只能有一个。D.类中，可以有main方法，也可以没有main方法，而有一个main()方法的时候，也可以是任意访问权限。因为这个类不一定要执行，可以只是辅助类。9、Java程序的种类有： （a）内嵌于Web文件中，由浏览器来观看的_Applet（b）可独立运行的 Application（c）服务器端的 Servlets 2020-1-27Java第21套1、finally块会被执行无论是否抛出异常2、Applet 是一种在 Web 环境下，运行于客户端的Java程序组件。Applet 必须运行于某个特定的“容器”，这个容器可以是浏览器本身，也可以是通过各种插件，或者包括支持 Applet 的移动设备在内的其他各种程序来运行。与一般的Java应用程序不同，Applet 不是通过 main 方法来运行的。Applet运行之前，先调用 Init() 方法，然后调用 start() 方法，最后调用 paint() 方法。3、考察点：抽象类和接口 相同点：都不能被实例化,位于继承树的顶端，都包含抽象方法 不同点：1、设计目的：接口体现的一种规范，类似与整个系统的总纲，制订了系统各模块应该遵循的标准，因此接口不应该经常改变，一旦改变对整个系统是辐射性的。 抽象类作为多个子类的共同父类，体现的是一种模板式设计，可以当作系统实现过程中的中间产品，已经实现了系统部分功能。 2、使用不同：（1）接口只能包含抽象方法，抽象类可以包含普通方法。 （2）接口里不能定义静态方法，抽象类可以。 （3）接口只能定义静态常量属性不能定义普通属性，抽象类可以。 （4）接口不包含构造器，抽象类可以（不是用于创建对象而是让子类完成初始化）。 （5）接口里不能包含初始化块，抽象类完全可以。 （6）接口多继承，抽象类但继承（只能有一个直接父类）。 总结：接口所有方法全是抽象方法只能public abstract修饰（默认public abstract修饰），属性默认public static final修饰。 抽象类除了包含抽象方法外与普通类无区别。4、对于管道，有下面这几种类型：①普通管道（PIPE）：通常有两种限制，一是单工，即只能单向传输；二是血缘，即常用于父子进程间（或有血缘关系的进程间）。 ②流管道（s_pipe）：去除了上述的第一种限制，实现了双向传输。③命名管道（name_pipe）：去除了上述的第二种限制，实现了无血缘关系的不同进程间通信。显然，要求是对于不同的服务器之间的通信，是要要求全双工形式的，而管道只能是半双工，虽然可以双向，但是同一时间只能有一个方向传输5、 Statement 每次执行sql语句，数据库都要执行sql语句的编译 ，最好用于仅执行一次查询并返回结果的情形，效率高于PreparedStatement.PreparedStatement是预编译的，使用PreparedStatement有几个好处 a. 在执行可变参数的一条SQL时，PreparedStatement比Statement的效率高，因为DBMS预编译一条SQL当然会比多次编译一条SQL的效率要高。 b. 安全性好，有效防止Sql注入等问题。 c. 对于多次重复执行的语句，使用PreparedStament效率会更高一点，并且在这种情况下也比较适合使用batch； d. 代码的可读性和可维护性。 CallableStatement接口扩展 PreparedStatement，用来调用存储过程,它提供了对输出和输入/输出参数的支持。CallableStatement 接口还具有对 PreparedStatement 接口提供的输入参数的支持。6、1、整数类型byte（1个字节）short（2个字节）int（4个字节）long（8个字节） 2、字符类型char（2个字节） 3、浮点类型float（4个字节）double（8个字节）A，包装和基本类型不是同一个概念 B， long和double都占了64位（64bit）的存储空间C，默认的浮点数据类型是double，如果要指明使用float，则需要在后面加f D，基本数据类型是没有静态方法的，但是基本数据类型的包装类却有6、public void methodOne(){System.out.print(“A”);methodTwo();//注意重写覆盖调用的是子类的methodTwo方法，而子类的又有super关键字，所以先调用父类的methodtwo方法，只要是被子类重写的方法，不被super调用都是调用子类方法7、Class.forName(“com.mysql.jdbc.Driver”); //指定MySQL JDBC驱动程序oracle.jdbc.driver.OracleDriver //oracle驱动sun.jdbc.odbc.JdbcOdbcDriver//Access数据库8、简单记忆线程安全的集合类： 喂！SHE！ 喂是指 vector，S是指 stack，H是指hashtable，E是指：Eenumeration9、线程并发运行结果不稳定 2020-1-29Java第22套1、Java中的四类八种基本数据类型 第一类：整数类型 byte short int long第二类：浮点型 float double第三类：逻辑型 boolean(它只有两个值可取true false) 第四类：字符型 char2、1. List 是一个有序集合，可以存放重复的数据 (有序：存进是什么顺序，取出时还是什么顺序) (1).ArrayList 底层是数组适合查询，不适合增删元素。 (2).LiskedList 底层是双向链表适合增删元素，不适合查询操作。 (3).Vector 底层和ArrayList相同，但是Vector是线程安全的，效率较低很少使用 2. Set 是一个无序集合，不允许放重复的数据 (无序可重复，存进和取出的顺序不一样) (1).HashSet 底层是哈希表/散列表 (2).TreeSet 继承sartedSet接口（无需不可重复，但存进去的元素可以按照元素的大小自动排序） 3. Map 是一个无序集合，以键值对的方式存放数据，键对象不允许重复，值对象可以重复。(1).HashMap实现不同步，线程不安全。 HashTable线程安全(2).HashMap中的key-value都是存储在Entry中的。(3).HashMap可以存null键和null值，不保证元素的顺序恒久不变，它的底层使用的是数组和链表，通过hashCode()方法和equals方法保证键的唯一性3、abstract修饰符用来修饰类和成员方法 1：用abstract修饰的类表示抽象类，抽象类位于继承树的抽象层，抽象类不能被实例化。 2：用abstract修饰的方法表示抽象方法,抽象方法没有方法体。抽象方法用来描述系统具有什么功能，但不提供具体的实现。 Abstract是Java中的一个重要关键字，可以用来修饰一个类或者一个方法。 修饰一个方法时，表示该方法只有特征签名（signature），没有具体实现，而是把具体实现留给继承该类的子类。一个类中只要有一个abstract 方法，那么这个类就要被声明为abstract，但是其中可以有非abstract方法。 abstract类可以使得类的设计者能够创建方法的原型，而真正的实现留给使用这个类的人。4、(1)把类定义在另一个类的内部，该类就被称为内部类。 举例：把类B定义在类A中，类B就被称为内部类。 (2)内部类的访问规则 A:可以直接访问外部类的成员，包括私有 B:外部类要想访问内部类成员，必须创建对象 (3)内部类的分类 A:成员内部类 B:局部内部类 C:匿名内部类 (4)成员内部类访问规则 成员内部类不是静态的：外部类名.内部类名 对象名 = new 外部类名().new 内部类名(); 成员内部类是静态的：外部类名.内部类名 对象名 = new 外部类名.内部类名();(5)局部内部类 A:局部内部类访问局部变量必须加final修饰。 B:为什么呢? 因为局部变量使用完毕就消失，而堆内存的数据并不会立即消失。 所以，堆内存还是用该变量，而改变量已经没有了。 为了让该值还存在，就加final修饰。 通过反编译工具我们看到了，加入final后，堆内存直接存储的是值，而不是变量名。(6)匿名内部类(掌握) A:是局部内部类的简化形式 B:前提存在一个类或者接口 C:格式: new 类名或者接口名() { 重写方法; } D:本质： 其实是继承该类或者实现接口的子类匿名对象5、子类能继承父类的所有成员6、考察方法进栈与出栈的顺序。先进后出 有个知识点，方法在出栈的时候，执行的是return语句。因为出栈就意味着方法结束并消费，如果没有return语句，那么方法出栈的时候什么都不执行，就直接销毁。1.执行split（12）时，执行代码System.out.print(split(number / 2)) split（12/2）进栈，此时number=6；2.执行split（6）时，执行代码System.out.print(split(number / 2)) split（6/2）进栈，此时number=3； 3.执行split（3）第1行 if (number % 2 != 0)第2行 System.out.print(split((number + 1) / 2));第3行 System.out.print(split(number / 2)); 按照顺序执行 先执行第2行 首先split（(3+1)/2）进栈，此时number=2，再执行split（2），那么split（2/2）进栈，此时number=1， 最后return 1，注意此时第2行代码还没有结束时split（2/2）出栈，输出1；split（(3+1)/2）出栈，输出2；第二行代码结束，再执行第三行，此时number=3，执行System.out.print(split(number / 2)) split（3/2）进栈，number=1，return，那么就需要出栈了 split（3/2）出栈，输出1 split（6/2）出栈，输出3 split（12/2）出栈，输出6； 最终结果12136；split（number）方法，最终返回的是number这个值，所以split（n）出栈的输出结果就是n 整理： split（12/2）进栈 split（6/2）进栈 split（(3+1)/2）进栈 split（2/2）进栈 split（2/2）出栈，输出1 split（(3+1)/2）出栈，输出2 split（3/2）进栈split（3/2）出栈，输出1 split（6/2）出栈，输出3 split（12/2）出栈，输出6 Java第23套1、采用synchronized修饰符实现的同步机制叫做互斥锁机制，它所获得的锁叫做互斥锁。每个对象都有一个monitor(锁标记)，当线程拥有这个锁标记时才能访问这个资源，没有锁标记便进入锁池。任何一个对象系统都会为其创建一个互斥锁，这个锁是为了分配给线程的，防止打断原子操作。每个对象的锁只能分配给一个线程，因此叫做互斥锁。互斥锁指的是只有一个线程可以访问该对象。通过继承Thread类或实现Runnable接口，只是创建线程的两种方式。2、javac.exe是编译功能javaCompiler java.exe是执行程序，用于执行编译好的.class文件 javadoc.exe用来制作java文档 jdb.exe是java的调试器 javaprof.exe是剖析工具3、Java的跨平台特性是因为JVM的存在， 它可以执行.class字节码文件，而不是.java源代码4、java编译需要加.class后缀；javac编译不需要加.class后缀；5、接口是一种特殊的抽象类，先说明抽象类中的抽象方法，再说明接口抽象类中的抽象方法(其前有abstract1修饰)不能用 private、static、synchronized、native访回修饰符修饰。原因如下: private 抽象方法没有方法体,是用来被继承的,所以不能用 private修饰; static static修饰的方法可以通过类名来访间该方法(即该方法的方法体),抽象方法用sttic修饰没有意义; synchronized 该关键字是为该方法加一个锁。而如果该关键字修饰的方法是 static方法。则使用的锁就是class变量的锁。如果是修饰类方法。则用this变量锁。但是抽象类不能实例化对象,因为该方法不是在该抽象类中实现的。是在其子类实现的。所以，锁应该归其子类所有。所以，抽象方法也就不能用 synchronized关键字修饰了; native native这个东西本身就和 abstract冲突,他们都是方法的声明,只是一个把方法实现移交给子类,另一个是移交给本地操作系统。如果同时出现,就相当于即把实现移交给子类,又把实现移交给本地操作系统,那到底谁来实现具体方法呢 终于说到了接口！接口是一种特殊的抽象类,接口中的方法全部是抽象方法(但其前的 abstract可以省略),所以抽象类中的抽象方法不能用的访间修饰符这里也不能用。同时额外说明一下protect关键词 4. protectprotected访同修饰符也不能使用,因为接口可以让所有的类去实现(非继承),不只是其子类,但是要用public去修饰。接口可以去继承一个已有的接口。6、字符流和字节流每次读入的字节数是不确定的，可能相同也可能不相同例FileInputStream 的read() 方法每次读入一个字节，read(byte b[]) 每次读入b.length个字节 FileReader 的read()方法每次读入一个字符，read(char cbuf[], int offset, int length)每次读入length个字符另外，字符流和字节流读入一个ASCII字符，字节数是相同的例UTF-8字符编码中一个汉字占三个字节，数字1占一个字节，用字符流读入的数字1长度为一个字节，用字节流读入的数字1长度也为一个字节7、Applet显示相关的方法主要有3个。1. paint(Graphicsg)方法，具体执行Applet的绘制。2. update(Graphicsg)()方法，主要用于更新Applet的显示。3. repaint()方法，主要用于Applet的重新显示，它调用update()方法实现对Applet的更新。而draw()方法与显示无关，故选A draw 2020-1-30Java第24套1、阿里巴巴Java规范中 强制规定， 类名使用首字母大写的驼峰形式，方法名、参数名、成员变量、局部变量都统一使用首字母小写的驼峰形式。ClassName varName = new ClassName(); 类 变量2、自动类型转换遵循下面的规则： 1.若参与运算的数据类型不同，则先转换成同一类型，然后进行运算。 2.转换按数据长度增加的方向进行，以保证精度不降低。例如int型和long型运算时，先把int量转成long型后再进行运算。 3.所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double型，再作运算。 4.char型和short型参与运算时，必须先转换成int型。 5.在赋值运算中，赋值号两边的数据类型不同时，需要把右边表达式的类型将转换为左边变量的类型。如果右边表达式的数据类型长度比左边长时，将丢失一部分数据，这样会降低精度。 下图表示了类型自动转换的规则：3、System.out.println(x+y+” ”+(x+y)+y),先算小括号里的，字符串后面得的都按字符串相加如x=20，y=5，则结果为252554、 Java致力于检查程序在编译和运行时的错误。Java虚拟机实现了跨平台接口类型检查帮助检查出许多开发早期出现的错误。Java自己操纵内存减少了内存出错的可能性。Java还实现了真数组，避免了覆盖数据的可能。注意，是避免数据覆盖的可能，而不是数据覆盖类型5、四个选项都是Swing组件。JTextField输入单行文本，JTextArea输入多行文本，JButton显示按钮，JLebel提示信息6、t.run是调用的Thead类中的run()方法，t.start才是执行线程，所以这题就是执行普通run()方法，先输出pong，在输出ping。7、由于replaceAll方法的第一个参数是一个正则表达式，而”.”在正则表达式中表示任何字符，所以会把前面字符串的所有字符都替换成”/“。如果想替换的只是”.”，那么久要写成”\\.”.8、switch jdk1.7之前byte,short ,int ,char jdk1.7之后加入Stringjava11，required: ‘char, byte, short, int, Character, Byte, Short, Integer, String, or an enum’在Java7之前，switch只能支持 byte、short、char、int或者其对应的封装类以及Enum类型。在Java7中，也支持了String类型String byte short int char Enum 类型 2020-1-31Java第25套1、i!=0 只要不是02、HttpServlet容器响应Web客户请求流程如下： 1）Web客户向Servlet容器发出Http请求； 2）Servlet容器解析Web客户的Http请求； 3）Servlet容器创建一个HttpRequest对象，在这个对象中封装Http请求信息； 4）Servlet容器创建一个HttpResponse对象； 5）Servlet容器调用HttpServlet的service方法，这个方法中会根据request的Method来判断具体是执行doGet还是doPost，把HttpRequest和HttpResponse对象作为service方法的参数传给HttpServlet对象； 6）HttpServlet调用HttpRequest的有关方法，获取HTTP请求信息； 7）HttpServlet调用HttpResponse的有关方法，生成响应数据； 8）Servlet容器把HttpServlet的响应结果传给Web客户。doGet()或doPost()是创建HttpServlet时需要覆盖的方法. Servlet生命周期分为三个阶段： 1.初始化阶段 调用init()方法 2.响应客户请求阶段 调用service()方法 3.终止阶段 调用destroy()方法3、floor ：意为地板，指向下取整，返回不大于它的最大整数Ceil：意为天花板，指向上取整，返回不小于它的最小整数Round：意为大约，表示“四舍五入”，而四舍五入是往大数方向入。Math.round(11.5)的结果为12，Math.round(-11.5)的结果为-11而不是-12。4、在类方法中调用本类的类方法可直接调用。 实例方法也叫做对象方法。类方法是属于整个类的，而实例方法是属于类的某个对象的。由于类方法是属于整个类的，并不属于类的哪个对象，所以类方法的方法体中不能有与类的对象有关的内容。即类方法体有如下限制：(1) 类方法中不能引用对象变量；(2) 类方法中不能调用类的对象方法；(3) 在类方法中不能使用super、this关键字。(4)类方法不能被覆盖。如果违反这些限制，就会导致程序编译错误。与类方法相比，对象方法几乎没有什么限制：(1) 对象方法中可以引用对象变量，也可以引用类变量；(2) 对象方法中可以调用类方法；(3) 对象方法中可以使用super、this关键字。5、default String s A：java的访问权限有public、protected、private和default的，default不能修饰变量abstract double d C：普通变量不能用abstract修饰，abstract一般修饰方法和类abstract final double hyperbolicCosine（） D：被定义为abstract的类需要被子类继承，但是被修饰为final的类是不能被继承和改写的Public final static native int w（）正确5、[a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。注意:只有连字符在字符组内部时,并且出现在两个字符之间时,才能表示字符的范围; 如果出字符组的开头,则只能表示连字符本身. [^a-z]负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。\\b 匹配一个单词边界，也就是指单词和空格间的位置（即正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置，这里的\\b就是匹配位置的）。例如，“er\\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。\\B 匹配非单词边界。“er\\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 \\cx 匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。\\d匹配一个数字字符。等价于[0-9]。\\D 匹配一个非数字字符。\\f 匹配一个换页符。等价于\\x0c和\\cL。\\n 匹配一个换行符。等价于\\x0a和\\cJ。\\r匹配一个回车符。等价于\\x0d和\\cM。\\s 匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。 \\S 匹配任何可见字符。等价于[^ \\f\\n\\r\\t\\v]。\\t 匹配一个制表符。等价于\\x09和\\cI。\\v 匹配一个垂直制表符。等价于\\x0b和\\cK。\\w 匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的”单词”字符使用Unicode字符集。\\W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。6、1.抽象方法只能定义在抽象类中，抽象方法和抽象类必须由abstract修饰，abstract关键字只能描述类和方法，不能描述变量。抽象方法只定义方法声明，不定义方法实现。抽象类不可以被实例化（创建对象），只有通过子类继承抽象类并覆盖抽象类中的所有抽象方法后，该子类才可以被实例化，否则该子类还是一个抽象类。抽象类中有构造函数用于给子类对象进行初始化，同时抽象类中可以含有非抽象方法。abstract关键字不可以与final，private,static关键字共存，因为被final修饰的方法不可以被重写，意味着子类不可以重写该方法，如果abstract和final共同修饰父类中的方法，子类要实现抽象方法（abstract的作用），而final又不让该方法重写，这相互矛盾。如果private和abstract共同修饰父类中的方法，private修饰则该方法不可以被子类访问，但是abstract修饰需要子类去实现，两者产生矛盾。如果static和abstract共同修饰父类中的方法，static表示是静态的方法，随着类的加载而加载，则该方法不需要在子类中去实现，这与abstract关键字矛盾。2.static用于修饰成员变量和成员函数，想要实现对象中的共性数据的对象共享，可以将这个数据进行静态修饰，被静态修饰的成员可以直接被类名调用，静态随着类的加载而加载，而且优先于对象存在。静态方法只能访问静态成员（静态方法和静态变量），不可以访问非静态成员，这是因为静态方法加载时，优先于对象存在，所以没有办法访问对象中的成员。静态方法中不能使用this和super关键字，因为this代表本类对象，super代表父类对象，而静态时，有可能没有对象存在，所以this和super无法使用。3.final关键字可以修饰类，方法，变量（成员变量内，局部变量，静态变量），被final修饰的类是一个最终类，不可以被继承，被final修饰的方法是一个最终方法，不可以被覆盖，但是可以被继承。被final修饰的变量只能是一个常量，只能赋值一次。内部类被定义在类中的局部位置上时，只能访问局部被final修饰的局部变量。4.ABCD A：抽象方法只可以被public 和 protected修饰； B：final可以修饰类、方法、变量，分别表示：该类不可继承、该方法不能重写、该变量是常量 C：static final可以表达在一起来修饰方法，表示是该方法是静态的不可重写的方法 D：private 修饰方法（这太常见的）表示私有方法，本类可以访问，外界不能访问7、 Servlet过滤器的配置包括两部分： 第一部分是过滤器在Web应用中的定义，由元素表示，包括和两个必需的子元素 第二部分是过滤器映射的定义，由元素表示,可以将一个过滤器映射到一个或者多个Servlet或JSP文件，也可以采用url-pattern将过滤器映射到任意特征的URL。8、throws用于在方法上声明该方法不需要处理的异常类型,用在方法上后面跟异常类名 可以是多个异常类 throw用于抛出具体异常类的对象,用在方法内 后面跟异常对象只能是一个异常类型实体. try块必须和catch块或和finally同在,不能单独存在,二者必须出现一个. finally块总会执行,不论是否有错误出现.但是若try语句块或会执行的catch语句块使用了JVM系统退出语句,finally块就不会被执行了. final用于声明属性、方法、类。分别表示属性不可更改、方法不能被覆盖、类不能被继承。 所以C选项说方法不能被继承错误，是不能覆盖 2020-2-1Java第26套1、本题主要考察String对象的不可变性。 toUpperCase()会对当前对象进行检查如果不需要转换直接返回当前对象，否则new一个新对象返回； replace()如果两个参数相同，则直接返回，否则new一个新对象，所以这里y指向”Fmn”; y=y+”wxy” 这里修改y所指向的字符串对象，让它由指向”Fmn”变成指向”Fmnxyz”.2、多态：父类引用指向子类对象实例，接口和抽象类不可实例化。（A a0= new A（））3、ServletContext对象：servlet容器在启动时会加载web应用，并为每个web应用创建唯一的servlet context对象，可以把ServletContext看成是一个Web应用的服务器端组件的共享内存，在ServletContext中可以存放共享数据。ServletContext对象是真正的一个全局对象，凡是web容器中的Servlet都可以访问。 整个web应用只有唯一的一个ServletContext对象 servletConfig对象（可以获得Servlet初始化参数）：用于封装servlet的配置信息。从一个servlet被实例化后，对任何客户端在任何时候访问有效，但仅对servlet自身有效，一个servlet的ServletConfig对象不能被另一个servlet访问。4、方法区在JVM中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等5、A.vector是线程安全的ArrayList，在内存中占用连续的空间。初始时有一个初始大小，当数据条数大于这个初始大小后会重写分配一个更大的连续空间。如果Vector定义为保存Object则可以存放任意类型。B.try{}catch{}会增加额外的开销C.接口中声明的’变量’必须为public final static,所以为常量D.子类可以访问父类受保护的成员6、javac -help 用法: javac 其中, 可能的选项包括: -g 生成所有调试信息 -g:none 不生成任何调试信息 -g:{lines,vars,source} 只生成某些调试信息 -nowarn 不生成任何警告 -verbose 输出有关编译器正在执行的操作的消息 -deprecation 输出使用已过时的 API 的源位置 -classpath &lt;路径&gt; 指定查找用户类文件和注释处理程序的位置 -cp &lt;路径&gt; 指定查找用户类文件和注释处理程序的位置 -sourcepath &lt;路径&gt; 指定查找输入源文件的位置 -bootclasspath &lt;路径&gt; 覆盖引导类文件的位置 -extdirs &lt;目录&gt; 覆盖所安装扩展的位置 -endorseddirs &lt;目录&gt; 覆盖签名的标准路径的位置 -proc:{none,only} 控制是否执行注释处理和/或编译。 -processor [,,…] 要运行的注释处理程序的名称; 绕过默认的搜索进程 -processorpath &lt;路径&gt; 指定查找注释处理程序的位置 -parameters 生成元数据以用于方法参数的反射-d &lt;目录&gt; 指定放置生成的类文件的位置环境变量可在编译source code时指定 -s &lt;目录&gt; 指定放置生成的源文件的位置 -h &lt;目录&gt; 指定放置生成的本机标头文件的位置 -implicit:{none,class} 指定是否为隐式引用文件生成类文件 -encoding &lt;编码&gt; 指定源文件使用的字符编码 -source &lt;发行版&gt; 提供与指定发行版的源兼容性 -target &lt;发行版&gt; 生成特定 VM 版本的类文件 -profile &lt;配置文件&gt; 请确保使用的 API 在指定的配置文件中可用 -version 版本信息 -help 输出标准选项的提要 -A关键字[=值] 传递给注释处理程序的选项 -X 输出非标准选项的提要 -J&lt;标记&gt; 直接将 &lt;标记&gt; 传递给运行时系统 -Werror 出现警告时终止编译@&lt;文件名&gt; 从文件读取选项和文件名7、1.sleep()方法 在指定时间内让当前正在执行的线程暂停执行，但不会释放“锁标志”。不推荐使用。 sleep()使当前线程进入阻塞状态，在指定时间内不会执行。 2.wait()方法 在其他线程调用对象的notify或notifyAll方法前，导致当前线程等待。线程会释放掉它所占有的“锁标志”，从而使别的线程有机会抢占该锁。当前线程必须拥有当前对象锁。如果当前线程不是此锁的拥有者，会抛出IllegalMonitorStateException异常。 唤醒当前对象锁的等待线程使用notify或notifyAll方法，也必须拥有相同的对象锁，否则也会抛出IllegalMonitorStateException异常。Wait()和notify()必须在synchronized函数或synchronized block中进行调用。如果在non-synchronized函数或non-synchronized block中进行调用，虽然能编译通过，但在运行时会发生IllegalMonitorStateException的异常。3.yield方法 不会释放锁 暂停当前正在执行的线程对象。yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。yield()只能使同优先级或更高优先级的线程有执行的机会。4.join方法 join()等待该线程终止 。释放锁 等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测 8、当用户访问这样的网页时，Applet被下载到用户的计算机上执行，但前提是用户使用的是支持Java的网络浏览器。由于Applet是在用户的计算机上执行的，所以它的执行速度不受网络带宽或者Modem存取速度的限制，用户可以更好地欣赏网页上Applet产生的多媒体效果。 在Java Applet中，可以实现图形绘制，字体和颜色控制，动画和声音的插入，人机交互及网络交流等功能。 Applet还提供了名为抽象窗口工具箱（Abstract Window Toolkit，AWT）的窗口环境开发工具。 AWT利用用户计算机的GUI元素，可以建立标准的图形用户界面，如窗口、按钮、滚动条等等。目前，在网络上有非常多的Applet范例来生动地展现这些功能，读者可以去调阅相应的网页以观看它们的效果。 Applet小应用程序的实现主要依靠java.applet包中的Applet类。与一般的应用程序不同，Applet应用程序必须嵌入在HTML页面中，才能得到解释执行；同时Applet可以从Web页面中获得参数，并和Web页面进行交互。 Applet是一种Java的小程序，它通过使用该Applet的HTML文件，由支持Java的网页浏览器下载运行。也可以通过java开发工具的appletviewer来运行。Applet 程序离不开使用它的HTML文件。这个HTML文件中关于Applet的信息至少应包含以下三点： 1)字节码文件名(编译后的Java文件，以.class为后缀) 2)字节码文件的地址 3)在网页上显示Applet的方式。 一个HTML文件增加Applet有关的内容只是使网页更加富有生气，如添加声音、动画等这些吸引人的特征，它并不会改变HTML文件中与Applet无关的元素。 Applet 可以在带有Java解释器的浏览器中运行Applet类必须继承java.applet.AppletApplet可以访问本地文件Applet是Object类的子类 9、String类是final类型的，不能继承和修改这个类。str=“tesk ok”，并不是覆盖str，其实是隐含的让Java生成一个新的String对象，那么就与原来的“Hello”没有任何关系，当函数结束，str作用结束，所以输出的还是“Hello”。char ch[] 是传递引用，修改了原内容。 2020-2-2Java第27套1、A只能有final和abstract的一个，因为final是最终类，不能继承，必须可以创建实例，而abstract是抽象类，只能继承，不有实例。冲突了，所以不对。 B是抽象方法，不能有方法体。所以末尾不是{}而是 才对 如 abstract private move(){} 错 C中 访问修饰符只能有一个，而且对象没有类型。 D正确，这是抽象类。抽象方法不能有方法体也就是说不能有花括号，但是抽象类可以有花括号，不能混淆 如 public abstract class Car{} 对 A、abstract不能和final共用。因为final是最终类，不能继承，必须可以创建实例，而abstract是抽象类，只能继承注意：abstract是用来修饰类和方法的： 修饰方法：abstract不能和private、final、static共用。 修饰外部类：abstract不能和final、static共用。（外部类的访问修饰符只能是默认和public） 修饰内部类：abstract不能和final共用。（内部类四种访问修饰符都可以修饰）2、String str1 =”hello” “hello”存放在 常量池；new String(“llo”) 存放在 堆 中；== 比较的是地址，所以很明显不相等；3、内存回收负责释放无用资源 A、JVM一旦启动，就会创建一个守护线程来监测是否需要有对象内存被释放。C、无法直接释放。D、不可以指定时间，System.gc()，只是提醒JVM可以进行一次Full GC，但是什么时候真正执行，还是不知道的。4、catch可以省略，try的形式有三种： try-catch try-finally try-catch-finally但catch和finally语句不能同时省略！5、（1）a+b的16进制表示为：OxFFFFFFFFFFFFFFF（16位F），转为2进制为111……111（64位1，每个F-&gt;4位2）。（2）有符号数：是针对二进制来讲的。用最高位作为符号位，“0”代表“+”，“1”代表“-”。所以a+b的结果是一个负数。（3）计算机中负数是以补码的形式保存的，将补码转换成原码的计算方式如下： ①. 对于正数，原码与补码相同。 ②. 对于负数，将补码除符号位之外，按位取反，末位加1，即得到原码。（4）a + b = 111……111（64位1） 取反：100……000（1位1，后面63位0） 加一：100……00（中间62位0） 10进制：-1。6、-Xmx：最大堆大小-Xms：初始堆大小 最小内存值-Xmn: 年轻代大小-XXSurvivorRatio：年轻代中Eden区与Survivor区的大小比值年轻代5120m， Eden：Survivor=3：2，Survivor区大小=1024m（Survivor区有两个，即将年轻代分为5份，每个Survivor区占一份），总大小为2048m。-Xms初始堆大小即最小内存值为10240m7、BD错；数组的长度是固定的，int[] array =new array[100]就对了 E错：数组是一种引用数据类型 那么他肯定是继承Object类的 所以里面有equals() 方法 但是肯定没有重写过 因为他并不是比较数组内的内容 使用Arrays.equals() 是比较两个数组中的内容。 数组是一种引用数据类型 那么他肯定是继承Object类的 所以里面有equals() 方法 但是肯定没有重写过 因为他并不是比较数组内的内容8、两个最基本的java回收算法：复制算法和标记清理算法复制算法：两个区域A和B，初始对象在A，继续存活的对象被转移到B。此为新生代最常用的算法标记清理：一块区域，标记可达对象（可达性分析），然后回收不可达对象，会出现碎片，那么引出标记-整理算法：多了碎片整理，整理出更大的内存放更大的对象两个概念：新生代和年老代新生代：初始对象，生命周期短的永久代：长时间存在的对象整个java的垃圾回收是新生代和年老代的协作，这种叫做分代回收。Serial New收集器是针对新生代的收集器，采用的是复制算法Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理Parallel Scavenge（并行）收集器，针对新生代，采用复制收集算法Serial Old（串行）收集器，新生代采用复制，老年代采用标记整理Parallel Old（并行）收集器，针对老年代，标记整理CMS收集器，基于标记清理G1收集器：整体上是基于标记 整理 ，局部采用复制综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理9、1.声明非静态内部类对象的方法：外部类名.内部类名 对象名=new 外部类名（）.new 内部类名（）；（注意：此时等号右边需要创建外部类对象,所以有 new 外部类名（）.new 内部类名（））2.声明静态内部类对象的方法：外部类名.内部类名 对象名=new 外部类.内部类名（）；（注意：此时等号右边不需要创建外部类对象,所以有 new 外部类.内部类名（）即可）当开头导入import包就不需要创建外部类 2020-2-3Java第28套1、String对象不可变、StringBuffer对象可变的含义： 举个例子：String str = “aa”; str = “aa”+”bb”; 此时str的值为”aabb”，但是”aabb”不是在开始的字符串”aa”后面直接连接的”bb”，而是又新生成了字符串”aabb”，字符串”aa”一旦被初始化，那么它的值不可能再改变了。 StringBuffer strb = StringBuffer(“aa”); strb.append(“bb”); 此时的strb的值也为”aabb”，但是”aabb”是直接在开始的字符串”aa”后面连接的“bb”，并没有生成新的字符串。2、java中的super关键词 super用于代表子类的直接父类的特征 super可以访问： 父类的成员变量，成员方法，构造方法 使用super关键词的情况： 在子类中，存在与父类相同的属性和方法，由于访问子类中属性和方法的优先级高于父类，可以通过super关键词来访问父类中的属性和方法 在子类中，可以通过super关键词来显示的调用父类的构造方法 子类的构造方法默认调用父类的无参构造方法，当父类中不存在无参构造方法时，可以同过super来调用父类的有参构造方法来避免编译时错误。3、一个类可以有多个构造方法，多个构造方法通过不同参数列表进行重载。4、 ①无论如何，Integer与new Integer不会相等。不会经历拆箱过程， ②两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false java在编译Integer i2 =128的时候,被翻译成-&gt; Integer i2 = Integer.valueOf(128);而valueOf()函数会对-128到127之间的数进行缓存 ③两个都是new出来的,都为false ④int和integer(无论new否)比，都为true，因为会把Integer自动拆箱为int再去比Integer i01=59； 自动装箱Int i02=52；Integer i03 = integer.valueof(59) 同第一行Integer i04 = new Integer(59) 有new 开辟一块新内存i01==i02 int和integer(无论new否)比，都为true，因为会把Integer自动拆箱为int再去比I01==i03 都自动装箱I03==i04 引用指向的对象地址不同I02==i04 int和integer(无论new否)比，都为true，因为会把Integer自动拆箱为int再去比5、静态块：用static申明，JVM加载类时执行，仅执行一次 构造块：类中直接用{}定义，每一次创建对象时执行 执行顺序优先级：静态块&gt;main()&gt;构造块&gt;构造方法 静态块按照申明顺序执行，先执行Test t1 = new Test(); 所以先输出blockA，然后执行静态块，输出blockB，最后执行main 方法中的Test t2 = new Test();输出blockA。6、 A，CopyOnWriteArrayList适用于写少读多的并发场景 B，ReadWriteLock即为读写锁，他要求写与写之间互斥，读与写之间互斥， 读与读之间可以并发执行。在读多写少的情况下可以提高效率 C，ConcurrentHashMap是同步的HashMap，读写都加锁 D，volatile只保证多线程操作的可见性，不保证原子性7、 出于运行速率的考虑，java编译器会把经常经常访问的变量放到缓存（严格讲应该是工作内存）中，读取变量则从缓存中读。但是在多线程编程中,内存中的值和缓存中的值可能会出现不一致。volatile用于限定变量只能从内存中读取，保证对所有线程而言，值都是一致的。但是volatile不能保证原子性，也就不能保证线程安全。8、 Swing 是在AWT的基础上构建的一套新的图形界面系统，它提供了AWT 所能够提供的所有功能，并且用纯粹的Java代码对AWT的功能进行了大幅度的扩充。AWT 是基于本地方法的C/C++程序，其运行速度比较快；Swing是基于AWT 的Java程序，其运行速度比较慢。8、修饰接口只能使用public，static用来修饰变量或者方法，而不修饰类2020-2-4Java第29套1、构造函数与类名相同，在new一个对象时调用构造函数，构造函数可以重载。2、整数类型 默认为 int 带小数的默认为 double3、4、最终类就是被final修饰的类，最终方法就是被final修饰的方法。最终类不能被继承，最终方法不能被重写。5、一个.java文件中定义多个类： 注意一下几点： (1) public权限类只能有一个（也可以一个都没有，但最多只有一个）； (2)这个.java文件名只能是public 权限的类的类名； (3)倘若这个文件中没有public 类，则它的.java文件的名字是随便的一个类名； (4)当用javac命令生成编译这个.java 文件的时候，则会针对每一个类生成一个.class文件；6、HttpServletResponse完成：设置http头标，设置cookie，设置返回数据类型，输出返回数据；读取路径信息是HttpServletRequest做的7、 Base base = new Son();这句new了一个派生类，赋值给基类，所以下面的操作编译器认为base对象就是Base类型的Base类中不存在methodB()方法，所以编译不通过8、正确选项 A选项：isIDCard=/^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$/ C选项：isIDCard=/^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{4}$/ ^：起始符号，^x表示以x开头 $：结束符号，x$表示以x结尾 [n-m]：表示从n到m的数字 \\d：表示数字，等同于[0-9] X{m}：表示由m个X字符构成，\\d{4}表示4位数字 15位身份证的构成：六位出生地区码+六位出身日期码+三位顺序码 18位身份证的构成：六位出生地区码+八位出生日期码+三位顺序码+一位校验码 C选项的构成： [1-9]\\d{5}：六位出生地区码，出生地区码没有以0开头，因此第一位为[1-9]。 [1-9]\\d{3}：八位出生日期码的四位年份，同样年份没有以0开头。 ((0\\d)|(1[0-2]))：八位出生日期码的两位月份，| 表示或者，月份的形式为0\\d或者是10、11、12。 (([0|1|2]\\d)|3[0-1])：八位出生日期码的两位日期，日期由01至31。 \\d{4}：三位顺序码+一位校验码，共四位。 A选项的构成： [1-9]\\d{7}：六位出生地区码+两位出生日期码的年份，这里的年份指后两位，因此没有第一位不能为0的限制，所以合并了。 后面的与C选项类似了。 好吧其实我也是第一次知道身份证还有15位的。9、A. request.getAttribute:getAttribute是在服务器端的操作。比如说 request.setAttribute(k,v),其行为动作在服务器端。而在服务端放入cookies是通过response.addCookie(cookie)。因此，A错了B. Accept 浏览器可接受的MIME类型Accept-Charset 浏览器支持的字符编码Accept-Encoding 浏览器知道如何解码的数据编码类型(如 gzip)。Servlets 可以预先检查浏览器是否支持gzip并可以对支持gzip的浏览器返回gzipped的HTML页面，并设置Content-Encoding回应头(response header)来指出发送的内容是已经gzipped的。在大多数情况下，这样做可以加快网页下载的速度。Accept-Language 浏览器指定的语言，当Server支持多语种时起作用。Authorization 认证信息，一般是对服务器发出的WWW-Authenticate头的回应。Connection 是否使用持续连接。如果servlet发现这个字段的值是Keep-Alive，或者由发出请求的命令行发现浏览器支持 HTTP 1.1 (持续连接是它的默认选项)，使用持续连接可以使保护很多小文件的页面的下载时间减少。Content-Length (使用POST方法提交时，传递数据的字节数)Cookie (很重要的一个Header，用来进行和Cookie有关的操作，详细的信息将在后面的教程中介绍)Host (主机和端口)If-Modified-Since (只返回比指定日期新的文档，如果没有，将会反回304 “Not Modified”)Referer (URL)User-Agent (客户端的类型，一般用来区分不同的浏览器) request.getHeader可以取到http请求的cookie值C.request.getParameter()方法获取从客户端中通过get 或者post方式传送到服务器端的参数。行为操作在服务器端。所以cookies明显不是通过url或者form表单提交过来的。C错 D.看方法名字就行了。 做错了 查阅一下了资料，记录一下~~各位共勉 2020-2-5Java第30套1、一、使用 MouseListener 接口处理鼠标事件1.使用 MouseListener 接口可处理 5 类操作发生的鼠标事件： 1) 在事件源上按下鼠标键 2) 在事件源上释放鼠标键 3) 在事件源上单击鼠标键 4) 鼠标进入源 5) 鼠标退出事件源2.鼠标事件的类型是 MouseEvent ，该类中有下列主要方法： 1) getX() ：获取鼠标在事件源坐标系统中的 x 坐标。 2) getY() ：获取鼠标在事件源坐标系统中的 y 坐标。 3) getModifiers() ：获取鼠标的左键或右键。鼠标的左键和右键分别使用 InputEvent 类中的常量 BUTTON1_MASK 和 BUTTON3_MASK 来表示。 4) getClickCount() ：获取鼠标被单击的次数。 5) getSource() ：获取发生鼠标事件的事件源。 事件源获得监视器的方法是 addMouseListener( 监视器 ) 。3.MouseListener 接口中有如下方法： 1) mousePressed(MouseEvent) ：负责处理鼠标按下事件。即当在事件源按下鼠标时，监视器发现这个事件后将自动调用接口中的这个方法对事件作出处理。 2) mouseReleased(MouseEvent) ：负责处理鼠标释放事件。 3) mouseEntered(MouseEvent) ：负责处理鼠标进入事件。 4) mouseExited(MouseEvent) ：负责处理鼠标离开事件。 5) mouseClicked(MouseEvent) ：负责处理鼠标单击事件。 二、使用 MouseMotionListener 接口处理鼠标事件 1. 使用 MouseMotionListener 接口可以处理两种操作发生的鼠标事件： 1) 在事件源上拖动鼠标。 2) 在事件源上移动鼠标。 鼠标事件的类型是 MouseEvent, 即当发生鼠标事件时， MouseEvent 类自动创建一个事件对象。 事件源获得监视器的方法是 addMouseMotionListener( 监视器 ). MouseMotionListener 接口中有如下方法： 1) mouseDragged(MouseEvent e) ：负责处理鼠标拖动事件。 2) mouseMoved(MouseEvent e) ：负责处理鼠标移动事件。三、鼠标事件的转移 可以使用鼠标事件的转移将一个事件源发生的鼠标事件转移到另一个事件源上，即当用户在某个事件源上单击鼠标时，可以通过鼠标事件的转移导致另一个事件源上发生鼠标事件。使用 javax.swing 包中的 SwingUtilities 类的静态方法： MouseEvent convertMouseEvent(Component source,MouseEventsourceEvent,Component destination); 可以将 Source 组件上发生的鼠标事件转移到组件 destination 。 我的Github ^_^ : https://github.com/CircleZ37911172、第一：方法名不能以数字开头，所以编译通不过 第二：改正确方法名后输出“360DW”，本题意在考察开启线程的方法t.start()和直接调用t.run()的区别。但在题目中没有提现 注：直接调用线程的run()方法不是开启线程，就是普通调用，会直接执行run()方法中的内容3、throw是语句抛出异常，有两种用法: //***抛出异常e实例或新的Exception实例1.catch中的throw e; 2.方法体中的throw new Exception(); 区别如下: throw e是将已经catch到的e重新抛出，而throw new Exception()是重新生成一个Exception类的对象并抛出。有两点重要区别，第一e中记录了原异常的信息，如除零异常的信息，而new Exception()是一个新对象，当中不包含任何有用的信息；第二e可能存在向上转型，即e的实际类型可能是Exception的子类，而new Exception()就是Exception类的对象。4、public static void main(String[] args) { Object o = new Object() { //重写object的equals().返回值为true. public boolean equals(Object obj) { return true; } }; //无论传入什么值都是true。 System.out.println(o.equals(“Fred”));//true System.out.println(o.equals(0));//true System.out.println(o.equals(null));//true}5、通常一个类实现序列化方式是实现序列化接口 Serializable 序列化的作用：把数据长久的保存在磁盘中，磁盘和内存是不同的，内存一般在程序运行时占用，数据保存周期短，随程序结束而结束，磁盘可以长久保存数据 transient关键字的作用，在已实现序列化的类中，有的变量不需要保存在磁盘中，就要transient关键字修饰，如银行卡密码等，就这个作用——在已序列化的类中使变量不序列化6、&amp;和&amp;&amp;都是逻辑运算符，都是判断两边同时真则为真，否则为假；但是&amp;&amp;当第一个条件不成之后，后面的条件都不执行了，而&amp;则还是继续执行，直到整个条件语句执行完为止7、 public可以被当前类，子类，包，其他包，访问， protected 可以被当前类，子类，包访问 default可以被可以被当前类，包内访问； private只能被当前类访问10、子类可以置换父类的同步方法 容器保存的是对象的引用；构造方法不需要同步化11、小转大随便转，不同类型运算结果类型向右看齐:char＜short＜ int＜ float ＜double12、1.String对象的两种创建方式:13、 第一种方式: String str1 = “aaa”; 是在常量池中获取对象(“aaa” 属于字符串字面量，因此编译时期会在常量池中创建一个字符串对象)， 第二种方式: String str2 = new String(“aaa”) ; 一共会创建两个字符串对象一个在堆中，一个在常量池中（前提是常量池中还没有 “aaa” 字符串对象）。 System.out.println(str1==str2);//false 2.String类型的常量池比较特殊。它的主要使用方法有两种： 直接使用双引号声明出来的String对象会直接存储在常量池中。 如果不是用双引号声明的String对象,可以使用 String 提供的 intern 方法。 String.intern() 是一个 Native 方法，它的作用是： 如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用； 如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。 String s1 = new String(“AAA”); String s2 = s1.intern(); String s3 = “AAA”; System.out.println(s2);//AAA System.out.println(s1 == s2);//false，因为一个是堆内存中的String对象一个是常量池中的String对象，System.out.println(s2 == s3);//true，s2,s3指向常量池中的”AAA“2020-2-6Java第31套1、A.没有模板，怎么可能创建对象，创建对象必须先要定义类，常识 B.对象中的数据域和方法取决于该对象的类，类里面有就有，没有就没有C.数据域可以是基本类型变量，也可以是一个对象 D.数据域不一定是基本类型，也可以是引用类型2、RandomAccessFile 可以通过 seek(long pos) 方法去移动文件指针进行追加更新写入. OutputStream() 是一个抽象类 不能直接实例化去写入 DataOutputStream() 也无法追加写入3、 包含在java文件的公共类必须和文件名相同 下面贴上代码：public class Test{ public static class innerClass{ public static void prin(){ System.out.println(“innerClass”); } } public static void main(String[] args) { Test.innerClass.prin(); System.out.println(“HelloWorld”); }} 题目的意思是： 除去扩展名.java的部分，包含在java文件里的Java里的公共类必须与文件的名字相同。 但是公共的内部类是不需要和文件的名字相同的。4、被final修饰的变量是常量，这里的b6=b4+b5可以看成是b6=10；在编译时就已经变为b6=10了 而b1和b2是byte类型，java中进行计算时候将他们提升为int类型，再进行计算，b1+b2计算后已经是int类型，赋值给b3，b3是byte类型，类型不匹配，编译不会通过，需要进行强制转换。 Java中的byte，short，char进行计算时都会提升为int类型。5、子类不可以继承父类的构造方法，只可以调用父类的构造方法。子类中所有的构造函数都会默认访问父类中的空参数构造函数，这是因为子类的构造函数内第一行都有默认的super（）语句。super（）表示子类在初始化时调用父类的空参数的构造函数来完成初始化。一个类都会有默认的空参数的构造函数，若指定了带参构造函数，那么默认的空参数的构造函数，就不存在了。这时如果子类的构造函数有默认的super（）语句，那么就会出现错误，因为父类中没有空参数的构造函数。因此，在子类中默认super（）语句，在父类中无对应的构造函数，必须在子类的构造函数中通过this或super（参数）指定要访问的父类中的构造函数。一个类想要被继承必须提供无参构造器，方法只有重载和重写继承具有传递性6、Hibernate Pojo的三态分别为transient（瞬时态）,persistent（持久态）,detached（游离态）1、官方给出的三态与Session的关系如下：transient: never persistent, not associated with any Session persistent: associated with a unique Session detached: previously persistent, not associated with any Session2、三种状态间相互转换关系，及他们在数据库、session中的状态如下： a.当我们new一个pojo时，它处于瞬时态，此时与session、数据库均无任何关联。 b.此后，我们获得session并开启hibernate事务，调用save(),persist(),saveOrUpdate()方法，将pojo转变为持久态，此时session中存有这个pojo，但直到transaction.commit()被调用时，sql语句才会执行，此后数据库中也才有此条数据。 c.但当commit()并且session.close()执行过后，pojo就变为了游离态，也就是说，数据库中有该记录，但session中不再有。 d.持久化状态的实例，也可以重新变成瞬时态，那就是调用delete()方法。 e.通过get()或load()方法得到的pojo是持久态的。 f.游离态的pojo可以通过update(),saveOrUpdate(),lock()和replicate()方法重新成为持久态。 g.调用merge()方法后，pojo维持原态，但内容会被更新到数据库游离状态可以通过update等方法变成持久态 2020-2-7Java第32套1、byte：8位 一个字节 int：32位 四个字节 long：64位 八个字节 char：16位 两个字节 float:32位 四个字节 double：64位 八个字节 boolean：8位 一个字节2、JAVA中,标识符, 指用于给变量.类.方法名 等命名的名称.1,标识以数字,字符,下划线,以及美元$符组成.（不能包括@、%、空格等）,不能以数字开头. 2,不能与JAVA关键字重复3,严格区分的大小写,（Flag和flag是两个变量） abstract assert boolean break byte casecatch char class const continue default do double else enum extendsfinal finally float for goto if implements import instanceof intinterface long native new package private protected public returnstrictfp short static super switch synchronized this throw throwstransient try void volatile while 等3、选A thread.Join把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。t.join(); //使调用线程 t 在此之前执行完毕。t.join(1000); //等待 t 线程，等待时间是1000毫秒join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。4、 1.若try代码块内含有return，同时存在finally代码块（代码块内无return值）时，先执行finally函数的值。 2.若try代码块内含有return，暂时保存起来，同时存在finally代码块且代码块内含有return值时，此时finally代码块内的return值将直接返回（或覆盖掉try代码块中的return值）。 public class Test { public static void main(String[] args) { System.out.println(test()); //第三个输出，输出try的返回值 } private static int test() { int temp = 1; try { System.out.println(temp);//第一个输出 return ++temp;//此时返回的temp值为++temp的值，即为2 } // catch (Exception e) { // //System.out.println(temp); // return temp; // // } finally { System.out.println(“测试：”+temp);//测试用 ++temp; System.out.println(temp);//第二个输出 } } }5、ThreadLocalMap中使用开放地址法来处理散列冲突，而HashMap中使用的是分离链表法。之所以采用不同的方式主要是因为：在ThreadLocalMap中的散列值分散得十分均匀，很少会出现冲突。并且ThreadLocalMap经常需要清除无用的对象，使用纯数组更加方便。6、 Java通过方法重写和方法重载实现多态 方法重写是指子类重写了父类的同名方法 方法重载是指在同一个类中，方法的名字相同，但是参数列表不同7、字节流：后缀是Stream InputStream |– FileInputStream (基本文件流） |– BufferedInputStream |– DataInputStream |– ObjectInputStream 字符流 Reader |– InputStreamReader (byte-&gt;char 桥梁） |– BufferedReader (常用） Writer |– OutputStreamWriter (char-&gt;byte 桥梁） |– BufferedWriter |– PrintWriter （常用）简单地说，字符流是字节流根据字节流所要求的编码集解析获得的 可以理解为字符流=字节流+编码集 所以本题中和字符流有关的类都拥有操作编码集(unicode)的能力。8、循环优化：死代码删除，代码外提，强度削弱，删除归纳变量，复写传播2020-2-8Java第33套1、run方法线程执行体，start方法开启多线程2、在interface里面的变量都是public static final 的。所以你可以这样写： public static final int i=10;或则int i=10；（可以省略掉一部分）注意在声明的时候要给变量赋予初值 解释： 首先你要弄清接口的含义.接口就是提供一种统一的’协议’,而接口中的属性也属于’协议’中的成员.它们是公共的,静态的,最终的常量.相当于全局常量. 抽象类是不’完全’的类,相当于是接口和具体类的一个中间层.即满足接口的抽象,也满足具体的实现. 如果接口可以定义变量，但是接口中的方法又都是抽象的，在接口中无法通过行为来修改属性。有的人会说了，没有关系，可以通过实现接口的对象的行为来修改接口中的属性。这当然没有问题，但是考虑这样的情况。如果接口A中有一个public访问权限的静态变量a。按照Java的语义，我们可以不通过实现接口的对象来访问变量a，通过A.a = xxx;就可以改变接口中的变量a的值了。正如抽象类中是可以这样做的，那么实现接口A的所有对象也都会自动拥有这一改变后的a的值了，也就是说一个地方改变了a，所有这些对象中a的值也都跟着变了。这和抽象类有什么区别呢，怎么体现接口更高的抽象级别呢，怎么体现接口提供的统一的协议呢，那还要接口这种抽象来做什么呢？所以接口中不能出现变量，如果有变量，就和接口提供的统一的抽象这种思想是抵触的。所以接口中的属性必然是常量，只能读不能改，这样才能为实现接口的对象提供一个统一的属性。 通俗的讲，你认为是要变化的东西，就放在你自己的实现中，不能放在接口中去，接口只是对一类事物的属性和行为更高层次的抽象。对修改关闭，对扩展（不同的实现implements）开放，接口是对开闭原则的一种体现。 csdn:https://blog.csdn.net/u0133098703、 MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。 MVC只是将分管不同功能的逻辑代码进行了隔离，增强了可维护和可扩展性，增强代码复用性，因此可以减少代码重复。但是不保证减少代码量，多层次的调用模式还有可能增加代码量4、作用范围从小到大依次是private,default,protected,public 被private修饰的属性和方法，只能在该类的内部访问；无修饰时，在前面的基础上，还可以被同一个包内的其他类访问；被protected修饰的属性和方法，在前面的基础上，还可以被其他包内的子类访问；被public修饰的属性和方法，可以被任意包内的类访问此外，类要想被其他包导入，必须被修饰为public6、分类Java语言提供了很多修饰符，大概分为两类：1. 访问权限修饰符 2. 非访问权限修饰符访问权限修饰符 public：共有访问。对所有的类都可见。 protected：保护型访问。对同一个包可见，对不同的包的子类可见。 default：默认访问权限。只对同一个包可见，注意对不同的包的子类不可见。 private：私有访问。只对同一个类可见，其余都不见。 非访问权限修饰符 static 修饰符，用来创建类方法和类变量。 final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。 abstract 修饰符，用来创建抽象类和抽象方法。 synchronized 用于多线程的同步。 volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。 transient：序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。 类外部类修饰符 public（访问控制符），将一个类声明为公共类，它可以被任何对象访问，一个程序的主类必须是公共类。 default（访问控制符），类只对包内可见，包外不可见。 abstract（非访问控制符），将一个类声明为抽象类，抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充，抽象类可以包含抽象方法和非抽象方法。。 final（非访问控制符），将一个类生命为最终（即非继承类），表示它不能被其他类继承。注意：1.protected 和 private 不能修饰外部类，是因为外部类放在包中，只有两种可能，包可见和包不可见。 2. final 和 abstract不能同时修饰外部类，因为该类要么能被继承要么不能被继承，二者只能选其一。 3.不能用static修饰类，因为类加载后才会加载静态成员变量。所以不能用static修饰类和接口，因为类还没加载，无法使用static关键字。 内部类修饰符 内部类与成员变量地位一直，所以可以public,protected、default和private，同时还可以用static修饰，表示嵌套内部类，不用实例化外部类，即可调用。 方法修饰符 public（公共控制符），包外包内都可以调用该方法。 protected（保护访问控制符）指定该方法可以被它的类和子类进行访问。具体细节可参考：http://blog.csdn.net/dawn_after_dark/article/details/74453915 default(默认权限），指定该方法只对同包可见，对不同包（含不同包的子类）不可见。 private（私有控制符）指定此方法只能有自己类等方法访问，其他的类不能访问（包括子类），非常严格的控制。 final ,指定方法已完备，不能再进行继承扩充。 static，指定不需要实例化就可以激活的一个方法，即在内存中只有一份，通过类名即可调用。 synchronize，同步修饰符，在多个线程中，该修饰符用于在运行前，对它所属的方法加锁，以防止其他线程的访问，运行结束后解锁。 native，本地修饰符。指定此方法的方法体是用其他语言在程序外部编写的。 abstract ,抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。抽象方法不能被声明成 final 和 static。 任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。 抽象方法的声明以分号结尾，例如：public abstract sample();。 成员变量修饰符 public（公共访问控制符），指定该变量为公共的，它可以被任何对象的方法访问。 protected（保护访问控制符）指定该变量可以别被自己的类和子类访问。在子类中可以覆盖此变量。 default(默认权限），指定该变量只对同包可见，对不同包（含不同包的子类）不可见。 private（私有访问控制符）指定该变量只允许自己的类的方法访问，其他任何类（包括子类）中的方法均不能访问。 final，最终修饰符，指定此变量的值不能变。 static（静态修饰符）指定变量被所有对象共享，即所有实例都可以使用该变量。变量属于这个类。 transient（过度修饰符）指定该变量是系统保留，暂无特别作用的临时性变量。不持久化。 volatile（易失修饰符）指定该变量可以同时被几个线程控制和修改，保证两个不同的线程总是看到某个成员变量的同一个值。 final 和 static 经常一起使用来创建常量。 局部变量修饰符 only final is permitted。 为什么不能赋予权限修饰符？ 因为局部变量的生命周期为一个方法的调用期间，所以没必要为其设置权限访问字段，既然你都能访问到这个方法，所以就没必要再为其方法内变量赋予访问权限，因为该变量在方法调用期间已经被加载进了虚拟机栈，换句话说就是肯定能被当前线程访问到，所以设置没意义。 为什么不能用static修饰 我们都知道静态变量在方法之前先加载的，所以如果在方法内设置静态变量，可想而知，方法都没加载，你能加载成功方法内的静态变量？ 接口 接口修饰符 接口修饰符只能用public、default和abstract。 不能用final、static修饰。 接口默认修饰为abstract。 接口中方法修饰符 only public &amp; abstract are permitted 。 意思只能用 public abstract修饰，当然如果你什么都不写，默认就是public abstract。 注意：在Java1.8之后，接口允许定义static 静态方法了！所以也可以用static来修饰！ 7、flush（）函数强制将缓冲区中的字符流、字节流等输出，目的是如果输出流输出到缓冲区完成后，缓冲区并没有填满，那么缓冲区将会一直等待被填满。所以在关闭输出流之前要调用flush（）。OutputStream含有8、Hashtable的方法都是synchrnized修饰的线程安全， ConcurrentHashMap并发容器，JDK7采用分段锁，JDK8采用CAS算法（乐观锁，比较并交换），线程安全，建议使用，Connections工具类提供了一个方法synchrnizedMap可以把Map同步，本质就是给每一个方法加上synchrnized关键字进行同步9、1.java支持单继承，却可以实现多个接口。a对d错 2.接口没有构造方法，所以不能实例化，抽象类有构造方法，但是不是用来实例化的，是用来初始化的。c对 3.抽象类可以定义普通成员变量而接口不可以，但是抽象类和接口都可以定义静态成员变量，只是接口的静态成员变量要用static final public 来修饰。 2020-2-9Java第34套1、Socket套接字 就是源Ip地址，目标IP地址，源端口号和目标端口号的组合 服务器端：ServerSocket提供的实例 ServerSocket server= new ServerSocket(端口号) 客户端：Socket提供的实例 Socket soc=new Socket(ip地址，端口号)2、list{5,3,1} nums.add(6); //往后边加一个6，{5，3，1，6} nums.add(0,4);//往下标为0的数加一个4，{4，5，3，1，6} nums.remove(1); // 移除下标为1 的元素，{4，3，1，6}3、 B选项中应该是Session接口而不是SessionFactory接口 1，Configuration接口：配置Hibernate，根据其启动Hibernate，创建SessionFactory对象； 2，SessionFactory接口：初始化Hibernate，充当数据存储源的***，创建session对象，SessionFactory 线程安全的，意味着它的同一个实例可以被应用的多个线程共享，是重量级二级缓存； 3，session接口：负责保存、更新、删除、加载和查询对象，是一个非线程安全的，避免多个线程共享一个session，是轻量级，一级缓存。 4，Transaction接口：管理事务。可以对事务进行提交和回滚； 5，Query和Criteria接口：执行数据库的查询。4、按照流是否直接与特定的地方（如磁盘、内存、设备等）相连，分为节点流和处理流两类。 节点流：可以从或向一个特定的地方（节点）读写数据。如FileReader.处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader.处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。 JAVA常用的节点流：文 件 FileInputStream FileOutputStrean FileReader FileWriter 文件进行处理的节点流。 字符串 StringReader StringWriter 对字符串进行处理的节点流。数 组 ByteArrayInputStream ByteArrayOutputStreamCharArrayReader CharArrayWriter 对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）。管 道 PipedInputStream PipedOutputStream PipedReaderPipedWriter对管道进行处理的节点流。 常用处理流（关闭处理流使用关闭里面的节点流）缓冲流：BufferedInputStrean BufferedOutputStream BufferedReader BufferedWriter 增加缓冲功能，避免频繁读写硬盘。转换流：InputStreamReader OutputStreamReader 实现字节流和字符流之间的转换。 数据流 DataInputStream DataOutputStream 等-提供将基础数据类型写入到文件中，或者读取出来.流的关闭顺序 一般情况下是：先打开的后关闭，后打开的先关闭另一种情况：看依赖关系，如果流a依赖流b，应该先关闭流a，再关闭流b。例如，处理流a依赖节点流b，应该先关闭处理流a，再关闭节点流b可以只关闭处理流，不用关闭节点流。处理流关闭的时候，会调用其处理的节点流的关闭方法。5、A.Java系统提供3种类加载器：启动类加载器（Bootstrap ClassLoader） 扩展类加载器（Extension ClassLoader） 应用程序类加载器（Application ClassLoader）. A正确B.《深入理解Java虚拟机》P228：对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那么这两个类必定不相等。接口类是一种特殊类，因此对于同一接口不同的类装载器装载所获得的类是不相同的。B错误C.类只需加载一次就行，因此要保证类加载过程线程安全，防止类加载多次。C正确 D. Java程序的类加载器采用双亲委派模型，实现双亲委派的代码集中在java.lang.ClassLoader的loadClass()方法中，此方法实现的大致逻辑是：先检查是否已经被加载，若没有加载则调用父类加载器的loadClass()方法，若父类加载器为空则默认使用启动类加载器作为父类加载器。如果父类加载失败，抛出ClassNotFoundException异常。D错误 E.双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。E正确F.应用程序类加载器（Application ClassLoader）负责加载用户类路径（ClassPath）上所指定的类库，不是所有的ClassLoader都加载此路径。F错误6、 对于普通同步方法，锁是当前实例对象。 对于静态同步方法，锁是当前类的Class对象。对于同步方法块，锁是synchronized括号里配置的对象。 同步代码块（synchronized(this)，synchronized(类实例对象)，锁是小括号()中的实例对象） 同步非静态方法（synchronized method），锁的是当前对象的实例对象 获取类锁同步代码块（synchronized(类.class)），锁是最小括号 () 中的类对象（Class对象）同步静态方法（synchronized static method），锁是当前对象的类对象（Class 对象） 总结有线程访问对象的同步代码块时，另外的线程可以访问该对象的非同步代码块若锁住的是同一个对象，一个线程在访问对象的同步代码块时，另一个访问对象的同步代码块的线程会被阻塞。若锁住的是同一个对象，一个线程在访问对象的同步方法时，另一个访问对象的同步方法的线程会被阻塞。若锁住的是同一个对象，一个线程在访问对象的同步代码块时，另一个访问对象同步方法的线程会被阻塞，反之亦然。同一个类的不同对象的锁互不干扰 类锁由于也是一种特殊的对象锁，因此表现和上述一致，而由于一个类只有一把对象锁，所以同一个类的不同对象使用类锁将会是同步的类锁和对象锁互不干扰 2020-2-10Java第35套1、 for(int i=0;i&lt;10;i++){ a[i+1]=a[i]} 这个i+1就是整数型表达式 或者a[5+3]就是a[8]2、java的基本编程单元是类，基本存储单元是变量。3、5 &gt;&gt; 2 相当于 5除于2的平方，等于1 ，&gt;&gt;&gt; 表示无符号 右移，高位用0 填充，0001 右移两位00004、 A、在方法中，修改一个基础类型的参数永远不会影响原始参数值。 B、在方法中，改变一个对象参数的引用永远不会影响到原始引用。然而，它会在堆中创建了一个全新的对象。（译者注：指的是包装类和immutable对象） C、在方法中，修改一个对象的属性会影响原始对象参数。 D、在方法中，修改集合和Maps会影响原始集合参数。5、 1，字符串在java中存储在字符串常量区中 2，==判断的是对象引用是否是同一个引用，判断字符串相等要用equals方法 首先判断a==MESSAGE 同一份字符串常量在内存中只有一份，因此是同一地址，返回true再次比较(b+c)==MESSAGE 这相当于 new String(b+c)==MESSAGE 这里new了一个String对象，所以返回false6、 ServerSocket ss=new ServerSocket(3000); Socket s=ss.accept();//当有客户端连接时才创建Socket对象，而不是new ServerSocket时创建7、包装类是针对基本数据类型在JDK中针对各种基本类型分别定义相应的引用类型–称为封装类Boolean Byte Short Integer Long Float Double Character8、instanceof 用来判断某个实例变量是否属于某种类的类型。这句话不准确，instanceof可以用来判断某个实例变量是否属于某种类的类型，但它的功能不局限于此，比如还可以判断某个类是否属于某个类的子类的类型。即判断&amp;&amp;两侧的表达式是否都为真，都为真则此&amp;&amp;表达式值为真；&amp; 是按位与 即将&amp;两侧的数用二进制展开，每一位都求与运算，最后得到的二进制数即为结果；逻辑与结果只讲真和假，而按位与得出的却是实实在在的一个数 &amp;：在逻辑运算的时候是非短路逻辑与，位运算中是按位与。&amp;&amp;：短路逻辑与 2020/2/11Java第36套1、静态代码块&gt;main2、在继承中代码的执行顺序为：1.父类静态对象，父类静态代码块 2.子类静态对象，子类静态代码块3.父类非静态对象，父类非静态代码块4.父类构造函数5.子类非静态对象，子类非静态代码块 6.子类构造函数 对于本题来说：在只想new Sub(5)的时候，父类先初始化了 int flag = 1，然后执行父类的构造函数Super（），父类构造函数中执行的test（）方法，因子类是重写了test（）方法的，因此父类构造函数中的test（）方法实际执行的是子类的test（）方法，所以输出为Sub.test() flag=1，接着执行子类构造函数Sub(5) 将flag赋值为5，因此输出结果Sub.Sub() flag=5。最终选择了A。3、intValue()是把Integer对象类型变成int的基础数据类型； parseInt()是把String变成int的基础数据类型； Valueof()是把String 转化成Integer对象类型；（现在JDK版本支持自动装箱拆箱了。） 本题：parseInt得到的是基础数据类型int，valueof得到的是装箱数据类型Integer，然后再通过valueInt转换成int，所以选择D3、父类静态域——》子类静态域——》父类成员初始化——》父类构造块——》1父类构造方法——》2子类成员初始化——》子类构造块——》3子类构造方法； 加黑的123，对应为A基类构造函数&gt;派生类对象成员构造函数&gt;派生类本身的构造函数类的初始化过程也就是方法执行的过程。 父类的静态域-子类的静态域 父类的非静态域-父类的构造函数 子类的非静态域-子类的构造函数 规律就是 父类先于子类 静态的先于非静态的 其中静态域包含静态代码块与静态方法，这个谁在前面，则先执行谁。 非静态域同理4、1.sleep()方法 在指定时间内让当前正在执行的线程暂停执行，但不会释放“锁标志”。不推荐使用。 sleep()使当前线程进入阻塞状态，在指定时间内不会执行。2.wait()方法 在其他线程调用对象的notify或notifyAll方法前，导致当前线程等待。线程会释放掉它所占有的“锁标志”，从而使别的线程有机会抢占该锁。 当前线程必须拥有当前对象锁。如果当前线程不是此锁的拥有者，会抛出IllegalMonitorStateException异常。 唤醒当前对象锁的等待线程使用notify或notifyAll方法，也必须拥有相同的对象锁，否则也会抛出IllegalMonitorStateException异常。 waite()和notify()必须在synchronized函数或synchronized block中进行调用。如果在non-synchronized函数或non-synchronized block中进行调用，虽然能编译通过，但在运行时会发生IllegalMonitorStateException的异常。3.yield方法 暂停当前正在执行的线程对象。 yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。 yield()只能使同优先级或更高优先级的线程有执行的机会。4.join方法 等待该线程终止。 等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。Join（）底层是调用wait（）方法，wait释放，join也释放锁 5、 会话跟踪是一种灵活、轻便的机制，它使Web上的状态编程变为可能。 HTTP是一种无状态协议，每当用户发出请求时，服务器就会做出响应，客户端与服务器之间的联系是离散的、非连续的。当用户在同一网站的多个页面之间转换时，根本无法确定是否是同一个客户，会话跟踪技术就可以解决这个问题。当一个客户在多个页面间切换时，服务器会保存该用户的信息。 有四种方法可以实现会话跟踪技术：URL重写、隐藏表单域、Cookie、Session。 1）.隐藏表单域：，非常适合步需要大量数据存储的会话应用。 2）.URL 重写:URL 可以在后面附加参数，和服务器的请求一起发送，这些参数为名字/值对。 3）.Cookie:一个 Cookie 是一个小的，已命名数据元素。服务器使用 SET-Cookie 头标将它作为 HTTP响应的一部分传送到客户端，客户端被请求保存 Cookie值，在对同一服务器的后续请求使用一个Cookie 头标将之返回到服务器。与其它技术比较，Cookie的一个优点是在浏览器会话结束后，甚至在客户端计算机重启后它仍可以保留其值 4）.Session：使用 setAttribute(String str,Object obj)方法将对象捆绑到一个会话 2020/2/12Java第37套1、AOP和OOP都是一套方法论，也可以说成设计模式、思维方式、理论规则等等。AOP不能替代OOP，OOP是obejct abstraction，而AOP是concern abstraction，前者主要是对对象的抽象，诸如抽象出某类业务对象的公用接口、报表业务对象的逻辑封装，更注重于某些共同对象共有行为的抽象，如报表模块中专门需要报表业务逻辑的封装，其他模块中需要其他的逻辑抽象，而AOP则是对分散在各个模块中的共同行为的抽象，即关注点抽象。一些系统级的问题或者思考起来总与业务无关又多处存在的功能，可使用AOP，如异常信息处理机制统一将自定义的异常信息写入响应流进而到前台展示、行为日志记录用户操作过的方法等，这些东西用OOP来做，就是一个良好的接口、各处调用，但有时候会发现太多模块调用的逻辑大都一致、并且与核心业务无大关系，可以独立开来，让处理核心业务的人专注于核心业务的处理，关注分离了，自然代码更独立、更易调试分析、更具好维护。核心业务还是要OOP来发挥作用，与AOP的侧重点不一样，前者有种纵向抽象的感觉，后者则是横向抽象的感觉，AOP只是OOP的补充，无替代关系。2、a. 类中的构造方法可以省略不写的 b. 构造方法必须跟类名相同，普通的类方法能与类同名的，但是要返回一个值。 c. 构造方法都在new 对象的时候调用的 d. 一个类可以定义多个构造方法的3、原生类是指Java中，数据类型分为基本数据类型（或叫做原生类、内置类型）和引用数据类型。数组是对象4、（1）静态类/变量不可以访问非静态类/变量 因为非静态类/变量在没有被实例化之前不能被使用。（2）非静态类/变量可以访问静态类/变量 因为静态类/变量在没有被实例化之前就存在了。4、abstrat class is-a:是一个 抽象 Interface like-a：像一个 接口5、表之间的关系是一对一，一对多，多对多关系，类的关系是继承。两者无必然联系。6、14^3=13 异或 相同是0，不同是17、引用类型作为函数的参数时，复制的是引用的地址，不会产生一个新的T；而如果T是值类型，其作为函数实参时会复制其值，也就是产生了一个新的T。8、抽象类能继承一个普通类（或抽象类），实现多个接口。 抽象类和普通类相比只是不能被实例化，只能作为子类的超类。 抽象类是用来捕捉子类的通用特性的，被用来创建继承层级里子类的模板。 可以有默认的方法实现。 抽象类可以有构造方法。 可以有main方法。 不必须有抽象方法，但是包含抽象方法的类一定是抽象类。 ===接口=== 接口能实现多个其他接口。 接口是抽象方法的集合，一个类实现了某个接口就必须实现抽象方法。 接口抽象方法默认修饰符是public（可以不写），不能使用其他修饰符。java 8中接口可以包含具体的方法实现，方法实现必须default修饰9、可见性可以修改的意思是 可以在子类使用其他可见性修饰符 protected的子类只要使用＞= protected的修饰符即可，因此子类可以使用public，意思就是修改了可见性。。。10、final修饰变量，变量的引用（也就是指向的地址）不可变，但是引用的内容可以变（地址中的内容可变）。 finally表示总是执行。但是其实finally也有不执行的时候，但是这个题不要扣字眼。 1. 在try中调用System.exit(0)，强制退出了程序，finally块不执行。 2. 在进入try块前，出现了异常，finally块不执行。 finalize方法，这个选项错就错在，这个方法一个对象只能执行一次，只能在第一次进入被回收的队列，而且对象所属于的类重写了finalize方法才会被执行。第二次进入回收队列的时候，不会再执行其finalize方法，而是直接被二次标记，在下一次GC的时候被GC。 2020/2/13Java第38套1、A.抽象类是可以实现接口的，而且抽象类也可以继承自抽象类 B.对 抽象类必须有“abstract class” C.抽象类指有abstract修饰的class，其可以包含抽象方法，也可以不包含 D.抽象类和接口都是不能被实例化的，只有具体的类才可以被实例化2、final和abstract不能同时使用3、 如果在循环的过程中调用集合的remove()方法，就会导致循环出错，例如： for(int i=0;i&lt;list.size();i++){ list.remove(…); } 循环过程中list.size()的大小变化了，就导致了错误。 所以，如果你想在循环语句中删除集合中的某个元素，就要用迭代器iterator的remove()方法，因为它的remove()方法不仅会删除元素，还会维护一个标志，用来记录目前是不是可删除状态，例如，你不能连续两次调用它的remove()方法，调用之前至少有一次next()方法的调用。4、（3+x）*(4+x)=2x^2+4…..x=8或-16、Lanbda表达式的主要作用就是代替匿名内部类的繁琐语法， 它由三部分组成：（1）形参列表。形参列表允许省略形参类型。如果形参列表中只有一个参数，甚至连形参列表的圆括号也可以省略。（2）箭头（→）。必须通过英文中画线和大于符号组成。（3）代码块。如果代码块只包含一条语句，Lambda表达式允许省略代码块的花括号，那么那条语句就不要用花括号表示语句结束。Lambda代码块只有一条return语句，甚至可以省略return关键字。Lambda表达式需要返回值，而它的代码块中仅有一套省略了return的语句。Lambda表达式会自动返回这条语句的值。7、写写数字, 观察规律 i= 1, 2, 3, 4, 5, 6, 7, 8 k=1, 3, 6, 10, 15, 21, 28, 36 把k的数字两个两个一起看的话, 也就是(1,3), (6,10), (15, 21), (7,8), 求和后可以发现规律(1+3=4), (6+10=16), (15+21=36), (28+36=64) 也就是2^2, 4^2, 6^2, 8^2…偶数的平方 循环在x^2&gt;=n时终止, 可得x等于根号n,也就是n^(1/2) 循环的次数是x/2, 时间复杂度为O((1/2)n^(1/2)), 一般而言时间复杂度认为常系数为1, 所以答案就是O(n^(1/2))2020/2/14Java第39套1、Switch：没有break，发生case穿透现象，程序会继续向下执行，直到遇到break或者结束switch语句的大括号为止。2、我收集的一点关于内部类的资料，与大家共享，有不对的欢迎指正。题目说的应该是3.1，定义在方法外部的内部类：1.内部类中不能定义静态成员2.内部类可以直接访问外部类中的成员变量，3.内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中在方法体外面定义的内部类的访问类型可以是public,protecte,默认的，private等4种类型，创建内部类的实例对象时，一定要先创建外部类的实例对象，然后用这个外部类的实例对象去创建内部类的实例对象方法内部定义的内部类前面不能有访问类型修饰符，就好像方法中定义的局部变量一样，但这种内部类的前面可以使用final或abstract修饰符。这种内部类对其他类是不可见的，其他类无法引用这种内部类，但是这种内部类创建的实例对象可以传递给其他类访问。4.在方法外部定义的内部类前面可以加上static关键字，从而成为Static Nested Class，它不再具有内部类的特性，所有，从狭义上讲，它不是内部类3、序列化保存的是对象的状态，静态变量属于类的状态，因此，序列化并不保存静态变量。Java在序列化时不会实例化static变量和transient修饰的变量，因为static代表类的成员，transient代表对象的临时数据，被声明这两种类型的数据成员不能被序列化。4、Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。 (1)加载：容器通过类加载器使用servlet类对应的文件加载servlet (2)创建：通过调用servlet构造函数创建一个servlet对象 （在前）(3)初始化：调用init方法初始化(4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求(5)卸载：调用destroy方法让servlet自己释放其占用的资源05、被static修饰的变量称为静态变量，静态变量属于整个类，而局部变量属于方法，只在该方法内有效，所以static不能修饰局部变量6、getParameter()是获取POST/GET传递的参数值； getInitParameter获取Tomcat的server.xml中设置Context的初始化参数 getAttribute()是获取对象容器中的数据值； getRequestDispatcher是请求转发。7、A错，调用Base这个构造方法应该这样 new Base(a,b) B错，和C相比应该是分号不是逗号 x=a，y=b 错 C正常赋值操作 D调用本类的构造方法 2020/2/15Java第40套1、A，接口中方法的默认修饰符时public abstract，抽象方法可是没有方法体的，没有大括号{} B，JDK8中，接口中的方法可以被default和static修饰，但是！！！被修饰的方法必须有方法体。 C，注意一下，接口是可以多继承的。整个没毛病，和A选项一样，抽象方法不能有方法体 2、 A在类中定义的变量称为类的成员变量，在别的类中不可以直接使用局部变量的 C使用别的类的方法需要通过该类的对象引用方法的名字 D只要没有定义任何构造函数，JVM都会为类生成一个默认构造函数3、 java中”包”的引入的主要原因是java本身跨平台特性的需求。实现跨平台的是JVM。 package语句是Java源文件的第一条语句。（若缺省该语句，则指定为无名包。），如果想在另一个类里面引用包里面的类，要把名字写全。（相当用文件的绝对路径访问）或者用import导入。java中并无#include关键字， 如果想在另一个类里面引用包里面的类，要把名字写全。（相当用文件的绝对路径访问）或者用import导入。4、Statement在JDBC中相当于SQL语句的载体 A，Statement是最基本的用法，采用字符串拼接的方式，存在注入漏洞 B，PreparedStatement对Statement中的SQL语句进行预编译，同时检查合法性，效率高 C，CallableStatement接口扩展 PreparedStatement，用来调用存储过程,它提供了对输出和输入/输出参数的支持。CallableStatement 接口还具有对 PreparedStatement 接口提供的输入参数的支持。D，BatchedStatement不是标准的Statement类5、Frame框架有菜单条6、本题考的不仅仅是审题，而且是try……catch……finally块的关系，以及return与finally的执行关系。 具体执行过程： 1、先进入main函数，进入try块调用aMethod(0)方法； 2、执行aMethod()方法的try块，i/10可以正确执行，故并未抛出异常，catch块不执行，而需要执行finally（该块任何时候都要执行），故打印finally； 3、回到main函数，由于aMethod()调用成功，因此main函数的catch块同样不执行，顺序执行finally块，打印finished 因此，最终的输出结果就是：finally finished7、 1）对于==，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等； 如果作用于引用类型的变量，则比较的是所指向的对象的地址2）对于equals方法，注意：equals方法不能作用于基本数据类型的变量 如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址； 诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。 转自https://www.cnblogs.com/dolphin0520/p/3592500.html3）f2是float[]类型的，f1[1]是float类型的，无法比较。8、A 可以调用父类无参的构造函数，子类的有参构造函数和是否调用父类的有参数的构造函数无必然联系。B 接口继承的时候只能继承接口不能继承类，因为如果类可以存在非抽象的成员，如果接口继承了该类，那么接口必定从类中也继承了这些非抽象成员，这就和接口的定义相互矛盾，所以接口继承时只能继承接口。C 接口可以多继承可以被多实现，因为接口中的方法都是抽象的，这些方法都被实现的类所实现，即使多个父接口中有同名的方法，在调用这些方法时调用的时子类的中被实现的方法，不存在歧义；同时，接口的中只有静态的常量，但是由于静态变量是在编译期决定调用关系的，即使存在一定的冲突也会在编译时提示出错；而引用静态变量一般直接使用类名或接口名，从而避免产生歧义，因此也不存在多继承的第一个缺点。 对于一个接口继承多个父接口的情况也一样不存在这些缺点。所以接口可以多继承。D 子类即使没有显示构造函数，也会有个无参数的默认构造函数，仍然会调用父类的构造函数。9、ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。 可以总结为一句话：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。 举个例子，我出门需要先坐公交再做地铁，这里的坐公交和坐地铁就好比是同一个线程内的两个函数，我就是一个线程，我要完成这两个函数都需要同一个东西：公交卡（北京公交和地铁都使用公交卡），那么我为了不向这两个函数都传递公交卡这个变量（相当于不是一直带着公交卡上路），我可以这么做：将公交卡事先交给一个机构，当我需要刷卡的时候再向这个机构要公交卡（当然每次拿的都是同一张公交卡）。这样就能达到只要是我(同一个线程)需要公交卡，何时何地都能向这个机构要的目的。 有人要说了：你可以将公交卡设置为全局变量啊，这样不是也能何时何地都能取公交卡吗？但是如果有很多个人（很多个线程）呢？大家可不能都使用同一张公交卡吧(我们假设公交卡是实名认证的)，这样不就乱套了嘛。现在明白了吧？这就是ThreadLocal设计的初衷：提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。 2020-2-16Java第41套1、setDaemon()方法必须在线程启动之前调用，当线程正在运行时调用会产生异常。2、 java规定类名首字母必须大写，这里可以直观的看出来Boolean是一个引用类型，不是基本数据类型。 java中的基本数据类型都对应一个引用类型，如Float是float的引用类型，Integer是int的引用类型3、1、接口是一种约束和规范，是一种更加更高级的抽象类，抽象类的方法必须是公开的，因为要给人继承和使用啊，不用public，别人怎么看得到，所以在接口实现时，定义的方法修饰符必须是public；因此子类在实现接口重写方法时的修饰符必须是public。 2、另外再扩展一下，接口中没有变量（既然是约束和规范，怎么能够定义一个大家都可以改的东西呢？），只能是常量，接口中定义常量默认的修饰符为public static final。4、既然求最小整数，那肯定先想到负数，则最高位（符号位）一定为1，原码中肯定是1所在的位数越高，值越小，而补码是由原码取反加1得到的，则在补码中1所在的位数一定要越低，即补码为1000 0011；由补码求得原码：1111 1101=-(64+32+16+8+4+1)=-125;5、while()括号里参数必须是布尔类型，While并不是关键字，这是大写的6、Java体系结构包括四个独立但相关的技术： Java程序设计语言 Java.class文件格式 Java应用编程接口（API） Java虚拟机 我们再在看一下它们四者的关系： 当我们编写并运行一个Java程序时，就同时运用了这四种技术，用Java程序设计语言编写源代码，把它编译成Java.class文件格式，然后再在Java虚拟机中运行class文件。当程序运行的时候，它通过调用class文件实现了Java API的方法来满足程序的Java API调用7、创建Statement是不传参的，PreparedStatement是需要传入sql语句 2020-2-17Java第42套1、\\d 匹配一个数字字符。等价于 [0-9]。 \\D 匹配一个非数字字符。等价于 [^0-9]。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 \\w 匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。 \\W 匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。2、静态方法中不能调用对象的变量，因为静态方法在类加载时就初始化，对象变量需要在新建对象后才能使用3、声明为public类型的类名必须与文件名相同，默认权限的可以不同并且内部类的类名一般与文件名不同4、java,exe是java虚拟机 javadoc.exe用来制作java文档 jdb.exe是java的调试器 javaprof,exe是剖析工具5、 new Sub();在创造派生类的过程中首先创建基类对象，然后才能创建派生类。创建基类即默认调用Base()方法，在方法中调用callName()方法，由于派生类中存在此方法，则被调用的callName（）方法是派生类中的方法，此时派生类还未构造，所以变量baseName的值为null6、s为null，因此只要调用了s.length()都会抛出空指针异常。因此这个题目就是考察if语句的后半部分会不会执行。A，单个与操作的符号&amp; 用在整数上是按位与，用在布尔型变量上跟&amp;&amp;功能类似，但是区别是无论前面是否为真，后面必定执行，因此抛出异常B，与操作，前半部分判断为假，后面不再执行C，这里跟 &amp; 和&amp;&amp; 的区别类似，后面必定执行，因此抛出异常 ‘|’D，或语句，前面为真，整个结果必定为真，后面不执行 ‘||’ 2020/2/18Java第43套1、JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。2、 java的堆内存分为两块:permantspace（持久带） 和 heap space。 持久带中主要存放用于存放静态类型数据，如 Java Class, Method 等，与垃圾收集器要收集的Java对象关系不大。而heapspace分为年轻带和年老带 ，年轻代的垃圾回收叫 Young GC，年老代的垃圾回收叫 Full GC。在年轻代中经历了N次（可配置）垃圾回收后仍然存活的对象，就会被复制到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象年老代溢出原因有循环上万次的字符串处理、创建上千万个对象、在一段代码内申请上百M甚至上G的内存，既A B D选项持久代溢出原因 动态加载了大量Java类而导致溢出3、Math.floor() 表示向下取整，返回double类型 （floor—地板） Math.ceil() 表示向上取整，返回double类型 （ceil—天花板） Math.round() 四舍五入，返回int类型4、栈的规则：先进后出 例如进栈序列为：1，2，3，4 全部进栈完成再出栈的序列则为：4，3，2，1 注：一个元素进栈后可以马上出栈，不用等全部进栈 例如：2这个元素一进就想出了，后面的3，4正常进栈再出栈。那么出栈顺序就是：2，4，3，1 (1是第一个进的，进的时候也没有立刻出去，所以被压在栈底，最后才能出去）例如：2这个元素一进就想出了，后面的3一进也想立刻想出去了，后面的4跟着进栈 那么出栈顺序就是：2，3，4，1 (2，3都进了立刻出 所以这时4压着的是1，所以出栈顺序是4在前面）5、java 8中基本数据类型：byte，short，int，long，double，float，boolean，char （首字母无大写）6、1.从地址栏显示来说 forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址. redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL. 2.从数据共享来说 forward:转发页面和转发到的页面可以共享request里面的数据. redirect:不能共享数据. 3.从运用地方来说 forward:一般用于用户登陆的时候,根据角色转发到相应的模块. redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等. 4.从效率来说 forward:高. redirect:低.8、数组有length属性，字符串只有length()方法ABC在java中会报错，D可以正常运行, 所以答案是ABC. A. ‘a’是字符,’ a’这个是空格和a，必须要用” a”才可以; str =“ a” B.String有length()方法 数组的长度是 .length，而String类型的长度表示的.length()，而集合 的长度表示.size();String 的末尾可以加数字的 C.int 无法直接转成String类型 D.尾部添加字符串”100“9、synchronized保证三大性，原子性，有序性，可见性，volatile保证有序性，可见性，不能保证原子性9、volatile到底做了什么: 禁止了指令重排 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量值，这个新值对其他线程是立即可见的 不保证原子性（线程不安全）synchronized关键字和volatile关键字比较： volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞 volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。 2020/2/20Java第44套1、对象赋值时，比如A=B，只是把A对象的地址指向了B对象的地址，所以其实对象只有一个2、instance是java的二元运算符，用来判断他左边的对象是否为右面类（接口，抽象类，父类）的实例3、hashCode()方法和equals()方法的作用其实是一样的，在Java里都是用来对比两个对象是否相等一致。 那么equals()既然已经能实现对比的功能了，为什么还要hashCode()呢？因为重写的equals()里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高。 那么hashCode()既然效率这么高为什么还要equals()呢？ 因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠， 所以我们可以得出： 1.equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的。 2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。 所有对于需要大量并且快速的对比的话如果都用equals()去做显然效率太低，所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equal()去再对比了）,如果hashCode()相同，此时再对比他们的equals()，如果equals()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！ 在静态方法中调用本类的静态方法时可直接调用4、synchrozied关键字称作同步，主要用来给方法、代码块加锁，被加锁的代码段，同一时间内多线程同时访问同一对象的加锁方法/代码块时，只能有一个线程执行能执行方法/代码块中的代码，其余线程必须等待当前线程执行完以后才执行该方法/代码块。 volatile关键字1.保证了不同线程对该变量操作的内存可见性.(当一个线程修改了变量,其他使用次变量的线程可以立即知道这一修改)。2.禁止了指令重排序. Lock接口提供了与synchronized关键字类似的同步功能，但需要在使用时手动获取锁和释放锁。transient关键字 简单地说，就是让某些被修饰的成员属性变量不被序列化。5、无效等价类是指对于软件规格说明而言，是没有意义的、不合理的输入数据集合。利用无效等价类可以找出程序异常说明情况，检查程序的功能和性能的实现是否有不符合规格说明要求的地方。有效等价类是指输入数据完全满足程序输入的规格说明，是有效、有意义的输入数据所构成的集合。利用有效等价类可以检验程序是否满足规格说明所规定的功能和性能。 应该选 C，因为C的后面一句话是已经排除了负数中的100的整数倍了 参考：百度百科 - 无效等价类6、Java 提供的事件处理模型是一种人机交互模型。它有三个基本要素： 1) 事件源（Event Source）：即事件发生的场所，就是指各个组件，如按钮等，点击按钮其实就是组件上发生的一个事件； 2) 事件（Event）：事件封装了组件上发生的事情，比如按钮单击、按钮松开等等； 3) 事件***（EventListener）：负责监听事件源上发生的特定类型的事件，当事件到来时还必须负责处理相应的事件；7、就本题而言，首先搞清楚一个Java类的初始化顺序：1. 静态代码块；2. 普通代码块；3. 构造函数。 其次，静态代码块只加载一次；普通代码块创建几个对象就加载几次。 所以，我觉得本题的答案应该： A的静态代码块 A的构造代码块 A的构造函数8、 Hashtable： （1）Hashtable 是一个散列表，它存储的内容是键值对(key-value)映射。 （2）Hashtable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为null。 （3）HashTable直接使用对象的hashCode。 HashMap： （1）由数组+链表组成的，基于哈希表的Map实现，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。 （2）不是线程安全的，HashMap可以接受为null的键(key)和值(value)。 （3）HashMap重新计算hash值Hashtable,HashMap,Properties继承关系如下： public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializablepublic class HashMap&lt;K,V&gt;extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable java.lang.Objecct java.util.Dictionary&lt;K,V&gt; java.util.Hashtable&lt;Object,Object&gt; java.util.Properties 2020/2/21Java第45套1、Map接口有两个金典的子接口分别是 Hashtable 和 Hashmap。 Hashtable 线程安全，不支持key和value为空，key不能重复，但value可以重复，不支持key和value为null。 Hashmap 非线程安全，支持key和value为空，key不能重复，但value可以重复，支持key和value为null。由于题目否定Map集合中的value都不可重复，这是错误的。2、A a = new A()3、final 修饰符final 变量： final 变量能被显式地初始化并且只能初始化一次。被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变，但是里面的值可以改变。 final 修饰符通常和 static 修饰符一起使用来创建类常量。final 方法 类中的 final 方法可以被子类继承，但是不能被子类修改。 声明 final 方法的主要目的是防止该方法的内容被修改。final 类 final 类不能被继承，没有类能够继承 final 类的任何特性。4、顶层容器是指可以不能被其他容器包含 ，是容纳其他容器的容器组件， 顶层容器包含JApplet、JDialog、JFrame和JWindow及其子类.JFrame中就可以放Jtree（树形组件）5、堆区：只存放类对象，线程共享； 方法区：又叫静态存储区，存放class文件和静态数据，线程共享; 栈区：存放方法局部变量，基本类型变量区、执行环境上下文、操作指令区，线程不共享;6、插入法复杂度低 2020/2/22Java第46套1、mock对象：也成为伪对象，在测试中的利用mock对象来代替真实对象，方便测试的进行。 java的封装性：指的是将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，通过该类提供的方法实现对内部信息的操作访问。 反射机制：在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法;对于任意一个对象，都能够调用它的任意一个方法和属性3、LinkedHashSet 继承于HashSet、又基于 LinkedHashMap 来实现 TreeSet 使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。 HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得总结:1.HashSet的性能总比TreeSet好。 2特别是最常用的添加、查找元素等操作时，用HashSet 3.当需要一个保持排序的Set时，用TreeSet. 4.遍历集合元素时，用LinkedHashSet 5.EnumSet是所有Set实现类中性能最好的，但它只能保存同一个枚举类的枚举值作集合元素。 6.Set的3个实现类HashSet，TreeSet和EnumSet都是线程不安全，则必须手动保证该Set集合的同步性。通常可以通过Collection工具类的synchronizedSortedSet方法来”包装”该Set集合。此操作最好在创建时进行，以防止对Set集合的意外非同步访问。4、输出到控制台，直接 System.out.println5、socket编程，服务器端操作 6、String.valueOf(myChar); //是将char类型的myChar转化成String类型只有char变成int，才会变为对应的Assica码7、String a = new String(“myString”) String b= “myString” String c=”my”+”String” String d= cA：a指向堆内存，b指向常量池，因此地址不相等，falseB：java有常量优化机制，c也指向常量池，且与b指向同一个，则a与c地址不相等,false； C：b与c地址相等，trueD：d是c的副本，地址相同，所以b与d地址相等，truea是运行时动态加载的，此时会在堆内存中生成一个myString字符串，指向堆内存字符串地址 b是编译时静态加载的，此时会在常量池中存放一个myString字符串，指向常量池字符串地址c会在编译时对”my” + “String”进行拼接成myString字符串，再去常量池查找，找到之后指向该字符串地址d是c的脚本，地址相同最后：Sting的==比较的是地址值是否相同8、 针对本题： 1、抽象类可以有构造，只不过不能new。 2、接口中可以有变量，但是无论你怎么写，最后都是public static final的。 3、抽象类中可以有静态方法，接口中也可以有。 抽象类可以有普通成员变量，接口中没有普通成员变量 扩展： 1、接口中可以有非抽象的方法，比如default方法（Java 1.8）。 2、接口中可以有带方法体的方法。（Java 1.8） 3、接口中的方法默认是public的。9、含有abstract修饰符的class即为抽象类，abstract类不能创建的实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。下面比较一下两者的语法区别：1.抽象类可以有构造方法，接口中不能有构造方法。2.抽象类中可以有普通成员变量，接口中没有普通成员变量3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。 抽象类中可以包含静态方法，接口中不能包含静态方法 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。一个类可以实现多个接口，但只能继承一个抽象类。下面接着再说说两者在应用上的区别：接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用， 例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码，伪代码如下：package com.lei;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponsepublic abstract class BaseServlet extends HttpServlet { /** serialVersionUID属性概述 /private static final long serialVersionUID = 1L;public final void service(HttpServletRequest request,HttpServletResponse response) throws IOException, ServletException {// 记录访问日志// 进行权限判断if (true)// if条件里写的是“具有权限”{try {doService(request, response);} catch (IOException e) {// 记录异常信息}} protected abstract void doService(HttpServletRequest request,HttpServletResponse response) throws IOException, ServletException;}实现类如下： package com.lei; import java.io.IOException; import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse; public class MyServlet extends BaseServlet{ /** serialVersionUID属性概述 /private static final long serialVersionUID = 1L; @Overrideprotected void doService(HttpServletRequest request,HttpServletResponse response) throws IOException, ServletException {// TODO Auto-generated method stub}}父类方法中间的某段代码不确定，留给子类干，就用模板方法设计模式。备注：这道题的思路是先从总体解释抽象类和接口的基本概念，然后再比较两者的语法细节，最后再说两者的应用区别。比较两者语法细节区别的条理是：先从一个类中的构造方法、普通成员变量和方法（包括抽象方法），静态变量和方法，继承性等6个方面逐一去比较回答，接着从第三者继承的角度的回答，特别是最后用了一个典型的例子来展现自己深厚的技术功底。10、Java语言中的异常处理包括声明异常、抛出异常、捕获异常和处理异常四个环节。throw用于抛出异常。 无对象throws关键字可以在方法上声明该方法要抛出的异常，然后在方法内部通过throw抛出异常对象。try是用于检测被包住的语句块是否出现异常，如果有异常，则抛出异常，并执行catch语句。cacth用于捕获从try中抛出的异常并作出处理。finally语句块是不管有没有出现异常都要执行的内容。11、反射指的是在运行时能够分析类的能力的程序。反射机制可以用来：1.在运行时分析类的能力–检查类的结构–所用到的就是java.lang.reflect包中的Field、Method、Constructor，分别用于描述类的与、方法和构造器。A中的Class类在java.lang中。2.在运行时查看对象。3.实现通用的数组操作代码。反射机制的功能：在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法；生成动态***。 反射机制常见作用：动态加载类、动态获取类的信息（属性、方法、构造器）；动态构造对象；动态调用类和对象的任意方法、构造器；动态调用和处理属性；获取泛型信息（新增类型：ParameterizedType,GenericArrayType等）；处理注解（反射API:getAnnotationsdeng等）。反射机制性能问题： 反射会降低效率。 void setAccessible(boolean flag):是否启用访问安全检查的开关，true屏蔽Java语言的访问检查，使得对象的私有属性也可以被查询和设置。禁止安全检查，可以提高反射的运行速度。 可以考虑使用：cglib/javaassist操作。 上述资料来源：《Java核心技术 卷I》，网络课程资料。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://lijiale96.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://lijiale96.github.io/tags/Java/"},{"name":"牛客","slug":"牛客","permalink":"https://lijiale96.github.io/tags/%E7%89%9B%E5%AE%A2/"}]},{"title":"船舶轨迹跟踪综述","slug":"船舶轨迹跟踪","date":"2020-02-16T09:02:18.000Z","updated":"2020-02-17T09:16:22.474Z","comments":true,"path":"2020/02/16/船舶轨迹跟踪/","link":"","permalink":"https://lijiale96.github.io/2020/02/16/%E8%88%B9%E8%88%B6%E8%BD%A8%E8%BF%B9%E8%B7%9F%E8%B8%AA/","excerpt":"摘要In this paper, we consider the problem of robust control for an autonomous surface vehicle (ASV) with bounded exogenous disturbance. The objective is to design a controller that ensures the system state tracks a sufficiently smooth desired trajectory generated by a virtual ship. To solve this problem, based on the robust integral of the sign of the error (RISE) feedback, the developed controller is able to utilize a smooth saturation functions controller with a strong input-to-state stability backstepping term. The bounds on the control are known a priori and can be adjusted by changing the feedback gains. Moreover, A Lyapunov stability analysis is included to prove semi-global asymptotically tracking. A simulation is provided to demonstrate the proposed controller on an experimentally validated ASV model.","text":"摘要In this paper, we consider the problem of robust control for an autonomous surface vehicle (ASV) with bounded exogenous disturbance. The objective is to design a controller that ensures the system state tracks a sufficiently smooth desired trajectory generated by a virtual ship. To solve this problem, based on the robust integral of the sign of the error (RISE) feedback, the developed controller is able to utilize a smooth saturation functions controller with a strong input-to-state stability backstepping term. The bounds on the control are known a priori and can be adjusted by changing the feedback gains. Moreover, A Lyapunov stability analysis is included to prove semi-global asymptotically tracking. A simulation is provided to demonstrate the proposed controller on an experimentally validated ASV model. 引言A three-degree-of-freedom ASV controller shows asymptotic track the desired trajectory in the plant dynamics online by rejecting unknown disturbances. Combined with a saturated RISE control scheme with ISS-backstepping, allowing ASV tracking continuous inertial trajectory. The stability of the controller is verified by the Lyapunov stability theorem. Finally, simulation is given to verify its effectiveness.目录Introduction 2输入饱和 2 s2.0-S0921889016307382-main 2 05723705 2 06875955 3 08049416 3RISE反馈结构 4 1-s2.0-S1270963817317509-main 4 01310482（nan） 4 08776586 5 08408263（*） 6 05990958 7 Tro14 7 Tac12_2 7 06314913 7 TAC14 8 1-s2.0-S1270963817316516-main（no） 8 2019-Chapter 9全驱动、欠驱动水面水下机器人（1、4） 10 Global robust adaptive path-tracking control of underactuated ships under stochastic disturbances 10 Introduction输入饱和 s2.0-S0921889016307382-mainAn adaptive radial basis function neural network (RBFNN) is constructed to provide an estimation of the unknown disturbances and is applied to design the trajectory tracking controller through a backstepping technique.To handle the effect of nonsmooth asymmetric saturation nonlinearity, a Gaussian error function-based continuous differentiable asymmetric saturation model is employed such that the backstepping technique can be used in the control design. It is proved that all the states in the closed-loop system are semiglobally uniformly ultimately bounded, and the tracking error converges to a small neighborhood of origin by appropriately choosing design parameters.用RBFNN 来预估干扰和非线性饱和。Zewei Zheng, Cheng Jin, Ming Zhu, Kangwen Sun . “Trajectory tracking control for a marine surface vessel with asymmetric saturation actuators.” Robotics and Autonomous Systems 97 (2017): 83-91. 05723705in the presence of input saturation and unknown external disturbance by using backstepping approaches,two new robust adaptive control algorithms are developed by introducing a well defined smooth function and using a Nussbaum function.The Nussbaum function is introduced to compensate for the nonlinear term arising from the input saturation. Unlike some existing control schemes for systems with input saturation, the developed controllers do not require assumptions on the uncertain parameters within a known compact set and a priori knowledge on the bound of the external disturbance用Nussbaum函数来补偿由输入饱和引起的非线性项。C. Wen, J. Zhou, Z. Liu and H. Su, “Robust Adaptive Control of Uncertain Nonlinear Systems in the Presence of Input Saturation and External Disturbance,” in IEEE Transactions on Automatic Control, vol. 56, no. 7, pp. 1672-1678, July 2011. 06875955To handle the effect of nonsmooth asymmetric saturation nonlinearity, a Gaussian error function-based continuous differentiable asymmetric saturation model isemployed such that the backstepping technique can be used in the control design. The explosion of complexity in traditional backstepping design is avoided using dynamic surface control. Using radial basis function NN, adaptive control is developed to guarantee that all the signals in the closed-loop system are semiglobally uniformly ultimately bounded, and the tracking error converges to a small neighborhood of origin by appropriately choosing design constants.研究了一类具有不对称饱和执行器和外部扰动的不确定非线性系统的自适应神经网络控制问题。J. Ma, S. S. Ge, Z. Zheng and D. Hu, “Adaptive NN Control of a Class of Nonlinear Systems With Asymmetric Saturation Actuators,” in IEEE Transactions on Neural Networks and Learning Systems, vol. 26, no. 7, pp. 1532-1538, July 2015. 08049416Command filters are incorporated in the control subsections to limit the magnitude of the virtual controls and simultaneously avoid arduous computations involving their time derivatives. Subsequently, auxiliary systems that aregoverned by smooth switching functions are developed in an inprecedented manner to compensate for the saturation constraints on actuators. Nonlinear disturbance observers are concurrently introduced to estimate the unknown externaldisturbances for increasing system’s robustness.光滑切换函数补偿执行器的饱和约束。Z. Zheng and M. Feroskhan, “Path Following of a Surface Vessel With Prescribed Performance in the Presence of Input Saturation and External Disturbances,” in IEEE/ASME Transactions on Mechatronics, vol. 22, no. 6, pp. 2564-2575, Dec. 2017. RISE反馈结构5. 1-s2.0-S1270963817317509-mainThis paper presents a velocity-free desired compensation trajectory tracking strategy integrated with adaptive robust integral of the sign of the error (RISE) feedback mechanism for quadrotors concerning parametric uncertainties and external disturbances. The original cascaded dynamics of quadrotor is derived in a strict form with additive disturbances. Then, the adaptive RISE feedback controllers arerespectively constructed in position and attitude loop, in which the control gains in RISE terms are adaptively updated online to ensure the robustness against uncertainties. In addition, to alleviate the measurement noise effect arising from the actual velocity signals, the velocity states in the model-based feedforward control are replaced with their desired values, then the desired compensation adaptiveRISE controllers that depend on the desired trajectory and output tracking errors are synthesized, where the design conservatism on selecting the control gain in RISE is eliminated without knowing the prior bound of uncertainties, and enhanced performance robustness is also retained in the absence of velocity information. It is shown via Lyapunov analysis that the proposed method can guarantee thetracking errors to converge to the origin with asymptotic performance despite of bounded disturbances. The effectiveness and superiority of proposed method are validated through extensive simulations and comparisons.针对参数不确定和外部干扰，提出一种无速度期望补偿轨迹跟踪策略与自适应RISE（误差信号的鲁棒积分）反馈机制相结合的四旋翼系统。Wang, Hongliang, et al. “A velocity-free adaptive RISE-based trajectory tracking approach for quadrotors with desired model compensation.” Aerospace Science and Technology (2019). 01310482（nan）In this paper, we investigate the distributed formation reconfiguration problem of multiple spacecraft with collision avoidance in the presence of external disturbances. Artifificial potential function (APF) based virtual velocity controllers for the spacecraft are fifirstly constructed, which overcome the local minima problem through introducing auxiliary inputs weighted by bump functions. Then, based on the robust integral of the sign of the error (RISE) control methodology, a distributed continuous asymptotic tracking control protocol is proposed, accomplishing both formation reconfifiguration and the collision avoidance among spacecraft and with obstacles. Furthermore, using tools from graph theory, Lyapunov analysis and backstepping technique, we show the stability and collision avoidance performance of the closed-loop multiple spacecraft system. Numerical simulations for a spacecraft formation are finally provided to validate the effectiveness of the proposed algorithm.本文研究了在外部干扰作用下多个避碰航天器的分布式编队重构问题。人工势函数首先构造了基于APF的航天器虚拟速度控制器，该控制器通过引入带凸点函数加权的辅助输入来克服局部极小问题。那么，基于RISE误差(上升)控制方法的鲁棒积分，提出了一种分布式连续渐近跟踪控制协议，实现了两种编队重构。避免航天器间和障碍物之间的碰撞。此外，利用图论、李雅普诺夫分析和反推技术等工具，证明了系统的稳定性和避碰性。闭环多航天器系统的性能。最后给出了航天器编队的数值模拟，验证了该算法的有效性。Guo, Yaohua, Jun Zhou, and Yingying Liu. “Distributed RISE control for spacecraft formation reconfiguration with collision avoidance.” Journal of the Franklin Institute 356.10 (2019): 5332-5352. 08776586In this paper, the model-based adaptive control combined with a continuous robust integral of the sign of the error (RISE) feedback strategy is presented for the trajectory tracking control of an autonomous surface vessel (ASV) subject to parametric uncertainties and time-varying disturbances. The control objective is to achieve asymptotic tracking and guarantee the transient tracking performancesimultaneously. An adaptive feedforward term is used to compensate for the parametric uncertainties, and the effects generated by external disturbances can be overcome by a gain of the error sign term (a part of the RISE feedback term). In the previous RISE-based feedback control, the upper bounds of disturbances and their time derivatives are often required to be known, while the requirement is relaxed, in this paper, by rendering the gain of the error sign term adaptive. It should be noted that the adaptive gain of the error sign term adjusts automatically until it is suffificient to compensate for the disturbances, which helps to reduce the control effort. Moreover, the prescribed performance control technique is introduced to provide the transient performance specifification of the tracking error, which guarantees the tracking performance and improves the robustness of the control system. Based on the backstepping procedure and the Lyapunov stability analysis,asymptotic trajectory tracking with transient tracking performance is theoretically guaranteed, and all the signals are shown to be bounded. The effectiveness of the proposed control scheme is demonstrated through the numerical simulation results 本文将基于模型的自适应控制与误差符号(上升)反馈的连续鲁棒积分相结合，用于自动轨迹跟踪控制。ASV，受参数不确定性和时变扰动的影响。控制目标是实现渐近跟踪，保证暂态跟踪性能。同时。采用自适应前馈项对参数不确定性进行补偿，（RISE）误差符号器的增益可以克服外部干扰的影响。在以前的基于RISE的反馈控制中，扰动及其时间导数的上界往往是已知的，而要求放宽是通过对误差符号项的增益进行自适应表示。应该注意的是，误差符号项的自适应增益会自动调整，直到足够补偿为止。对于扰动，这有助于减少控制效果。此外，还引入了规定的性能控制技术，以提供的瞬态性能指标，保证了系统的跟踪性能，提高了控制系统的鲁棒性。基于反步过程和李雅普诺夫稳定性分析，得到了渐近轨迹。理论上保证了暂态跟踪的性能，并证明了所有信号都是有界的。通过数值仿真验证了所提出的控制方案的有效性。针对全驱动ASV，提出了自适应前馈项和RISE补偿参数不确定和干扰的影响，并通过误差符号项的自适应调谐增益放宽了扰动有界的要求，同时引入了规定的性能控制技术，以保证跟踪误差的实时性。C. Dong, S. He and S. Dai, “Performance-Guaranteed Tracking Control of an Autonomous Surface Vessel With Parametric Uncertainties and Time-Varying Disturbances,” in IEEE Access, vol. 7, pp. 101905-101914, 2019 08408263（*）This paper present a control design technique of asymptotic trajectory tracking with guaranteed transient performance for an autonomous underwater vehicle (AUV) subject to external time-varying disturbances. To achieve the asymptotic convergence of output tracking errors, the robust integral of the sign of the error (RISE) feedback method is employed to compensate for the effect of the external disturbances. In the previous RISE-based control scheme, the upper bounds of the external disturbances and their derivatives are often required to be known a priori, while this requirement is relaxed by adaptive tuning gain of the error sign term. To further provide the transient performance of the tracking errors, the prescribed performance control technique is introduced to guarantee that the convergence rate of the tracking error is faster than a prescribed speed and the overshoot of the tracking error is less than a predefifined value. Based on backstepping procedure, prescribed performance control, and Lyapunov synthesis, a RISE-based controller is designed to achieve asymptotic convergence of the tracking errors with guaranteed prescribed performance. The effectiveness of the proposed control strategy is demonstrated through numerical simulation.本文提出了一种具有保证的瞬态性能的渐近轨迹跟踪控制技术。为了实现输出跟踪误差的渐近收敛，采用误差符号的鲁棒积分（R IS E）反馈方法来补偿外部d的影响。在以前的基于上升的控制方案中，外部扰动及其导数的上界往往是先验已知的，而这一要求则放宽了通过误差符号项的自适应调谐增益。为了进一步提供跟踪误差的瞬态性能，引入了规定的性能控制技术，以保证跟踪误差的实时性。跟踪误差的收敛速度快于规定的速度，跟踪误差的超调小于预定值。基于反步过程，规定性能在控制和李雅普诺夫合成的基础上，设计了一种基于上升的控制器，实现了跟踪误差的渐近收敛性，保证了指定的性能。 针对全驱动AUV，提出RISE补偿参数不确定和干扰的影响，并通过误差符号项的自适应调谐增益放宽了扰动有界的要求，引入了规定的性能控制技术，以保证跟踪误差的实时性。 S. Dai, Y. Peng and S. He, “Performance-guaranteed control of an autonomous underwater vehicle subject to time-varying disturbances,” 2018 Chinese Control And Decision Conference (CCDC), Shenyang, 2018, pp. 6448-6453. 05990958\\cite{bib2} developed a continuous tracking controller for coupling MIMO AUV with a stability analysis based on Lyapunov is included to demonstrate that the continuous RISE enhanced NN control method produces semi-global asymptotic tracking.\\bibitem{bib2}N. Fischer, S. Bhasin and W. E. Dixon, “Nonlinear control of an autonomous underwater vehicle: A RISE-based approach,” Proceedings of the 2011 American Control Conference, San Francisco, CA, 2011, pp. 3972-3977. Tro14In addition, there is an open water sea trial to illustrate design in a real environment, see \\cite{bib3} for details.\\bibitem{bib3}N. Fischer, D. Hughes, P. Walters, E. M. Schwartz and W. E. Dixon, “Nonlinear RISE-Based Control of an Autonomous Underwater Vehicle,” in IEEE Transactions on Robotics, vol. 30, no. 4, pp. 845-852, Aug. 2014. Tac12_2In actual engineering, underactuated ships will be used for manufacturing cost, energy consumption, system propulsion efficiency and reliability considerations. Lyapunov-Krasovskii (LK) functionals is proposed in \\cite{bib4}.\\bibitem{bib4}N. Sharma, S. Bhasin, Q. Wang and W. E. Dixon, “RISE-based adaptive control of an uncertain nonlinear system with unknown state delays,” 49th IEEE Conference on Decision and Control (CDC), Atlanta, GA, 2010, pp. 1773-1778. 06314913In general, robust control techniques do not consider that the input may require more actuation than may actually be required by the system. \\cite{bib5} concentrated on developing saturation controllers for some of the more general trajectory tracking problems. \\bibitem{bib5}N. Fischer, Z. Kan and W. E. Dixon, “Saturated RISE feedback control for Euler-Lagrange systems,” 2012 American Control Conference (ACC), Montreal, QC, 2012, pp. 244-249. TAC14\\cite{bib6} used the experimental results of the two-link manipulator demonstrate the performance of the designed controller.\\bibitem{bib6}O. Fischer, Z. Kan, R. Kamalapurkar and W. E. Dixon, “Saturated RISE Feedback Control for a Class of Second-Order Nonlinear Systems,” in IEEE Transactions on Automatic Control, vol. 59, no. 4, pp. 1094-1099, April 2014. 1-s2.0-S1270963817316516-main（no）This paper presents a velocity-free robust trajectory tracking control for a quadrotor unmanned aerial vehicle (UAV) with consideration of parametric uncertainties and external disturbances by effectively integrating robust integral of the sign of the error (RISE) feedback control with extended state observer (ESO). The original cascaded dynamics of quadrotor UAV is fifirst derived in a strict form with lumpeddisturbances. Then, the robust RISE partial state feedback controllers with disturbance compensation are respectively synthesized in position and attitude loop, where the unmeasurable velocity states and disturbance compensation terms are estimated by ESO, the synthesized RISE control law is then accounted for attenuating the residual estimation error to achieve enhanced robustness against uncertainties. The major feature of proposed method is that fundamentally differentanti-disturbance mechanisms of disturbance suppression-based RISE control and disturbance observer-based control are combined to handle the lumped disturbances simultaneously, which preserves their theoretical advantages while overcoming their performance limitations. Moreover, the proposed controller theoretically guarantees that the tracking error converges to a small neighborhood around the origin. The effectiveness and superiority of proposed control method are investigated in simulations against disturbances due to parametric uncertainties, wind gust and bounded perturbations. Shao, Xingling, et al. “RISE and disturbance compensation based trajectory tracking control for a quadrotor UAV without velocity measurements.” Aerospace Science and Technology 74 (2018): 145-159. 2019-ChapterIn this paper, a robust three dimensional output feedback control problemis proposed for a 6-degrees-of-freedom model of a quadrotor unmanned aerialvehicle (UAV) to track a bounded and suffificiently smooth reference trajectory in the presence of slowly varying force disturbances. Due to the underactuation structure of the UAV, a nonlinear output feedback controller based on the robust integral of the sign error signal (RISE) mechanism is first designed for the translational dynamics to ensure position reference tracking without velocity measurement. The angular velocity is then regarded as intermediate control signal for the rotational dynamics to fulfifill the task of attitude angle reference tracking. The torque input is designed taking full advantage of the smooth exact differentiator that circumvents derivatives computation of virtual controls, the backstepping technique is then judiciously modifified to allow the use of the RISE control technique to compensate for the external disturbances. The proposed controller yields semi-global asymptotic stability tracking despite the added disturbances in the dynamics. Simulation results are shown to demonstrate the proposed approach.本文针对四旋翼无人飞行器(UAV)的6自由度模型提出了一个鲁棒的三维输出反馈控制问题，以跟踪有界和足够的问题在存在缓慢变化的力扰动的情况下，平滑的参考轨迹。由于UAV的欠驱动结构，基于鲁棒积分的非线性输出反馈控制器首先针对平移动力学设计符号误差信号(上升)机制，以确保在没有速度测量的情况下定位参考跟踪。然后将角速度视为实现姿态角参考跟踪的任务提供了旋转动力学的中间控制信号。扭矩输入的设计充分利用了光滑精确微分器规避了虚拟控件的导数计算，然后巧妙地修改了Backstepping技术，以允许使用RISE上升控制技术来补偿外部扰动。该控制器具有半全局渐近稳定性跟踪，尽管在动力学中增加了扰动.仿真结果证明了该方法的有效性。 本文针对四旋翼无人飞行器(UAV)的6自由度模型提出了一个鲁棒的三维输出反馈控制问题，光滑精确微分器规避了虚拟控件的导数计算，然后巧妙地修改了Backstepping技术，以允许使用RISE上升控制技术来补偿外部扰动。A smooth precision differentiator is proposed to reverse the technique and use the RISE control technique to compensate for external interference Ghommam, Jawhar, Luis F. Luque-Vega, and Maarouf Saad. “Backstepping-based nonlinear RISE feedback control for an underactuated quadrotor UAV without linear velocity measurements.” New Developments and Advances in Robot Control. Springer, Singapore, 2019. 321-342. 全驱动、欠驱动水面水下机器人（1、4）16. Global robust adaptive path-tracking control of underactuated ships under stochastic disturbancesThis paper presents a design of new controllers that force underactuated ships under both deterministic and stochastic sea loads to globally track a reference path. First, the loads are decomposed to a deterministic part treated as unknown constants, and a time-varying part considered as stochastic disturbances with unknown time-varying covariances. Second, the path-tracking errors are represented in amoving frame attached to the path. These errors are then to be stabilized at the origin by a design of controllers based on backstepping and Lyapunov’s direct methods. Weak and strong nonlinear Lyapunov functions are introduced, and the path-parameter is used as an additional control input to overcome diffificulties caused by underactuation and Hessian terms induced by stochastic differentiation rule. Estimate of the deterministic disturbances and upper covariances of the stochastic disturbances is incorporated in the control design. The effectiveness of the proposed results is illustrated through simulations.本文介绍了一种新型控制器的设计，这种控制器可以在确定性和随机海载下强制欠驱动船舶全局跟踪参考路径。首先，将载荷分解为被视为未知常数的确定性部分，并将时变部分视为具有未知时变协方差的随机扰动。其次，路径跟踪误差表示在附加到路径的移动框架中。然后通过基于backstepping和Lyapunov直接方法的控制器设计将这些误差稳定在原点。引入弱和强非线性Lyapunov函数，并将路径参数用作附加控制输入，以克服由随机微分规则引起的欠时滞和Hessian项引起的困难。控制设计中包含了随机扰动的确定性扰动和上协方差的估计。通过模拟说明了所提出结果的有效性。K.D. Do. Global robust adaptive path-tracking control of underactuated ships under stochastic disturbances[J]. Ocean Engineering,2016,111. 研究背景全驱动船舶的特点：一一对应、操作简单、系统可靠、定位精准、跟踪准确。全驱动船舶的应用 :航路点导航、特定作业船舶如挖泥船、拖曳船、铺管船和风电安装船等。 研究意义船舶的控制技术在研究上具有非常重要的实际价值和理论意义：其一路径跟踪问题是船舶控制领域的一个热点问题，对于无人船尤为重要。其二，用饱和RISE的方法抑制或补偿干扰的水面船舶的轨迹跟踪还没有解决，可为实际工程奠定理论基础。研究进展 路径跟踪问题是船舶控制领域的一个热点问题，对于无人船尤为重要，即给定一条路径，无人船如何高效率地跟踪该路径。路径跟踪的准确性的提高不仅仅与平台模型构建相关，与采用的控制方法也是密不可分的。现阶段控制领域的几乎所有的成熟和先进的控制方法应用于相关海洋平台的运动控制，包括PID（比例-积分-微分方法），滑动模态和模糊控制，神经网络等方法。大体上这些方法可以分为两类，一类是线性化方法，一类是非线性方法。 对于线性化方法，主要有两种方式，一种是在平衡位置将水动力方程线性化，然后使用PID或其它反馈控制方法进行航向追踪进而实现路径追踪；第二种是通过设计反馈控制律，将非线性方程补偿为标准线性状态空间方程，该方法也被用于无人机、工业机器人等控制工作。线性化方法已经用于相关海洋观测平台的路径跟踪工作。 对于路径跟踪的非线性控制方法，通常是利用李亚普诺夫稳定性理论进行其控制律的设计。路径跟踪控制方法主要有李亚普诺夫直接方法、级联方法、输出反馈和状态反馈等。工作主要集中于大型舰船的路径跟踪控制。对于前进、侧移和偏航全驱动高速船，Godhavn设计了反推控制用于解决高速时非对称性惯性矩阵的非线性模型的舰船路径跟踪控制。对于仅两个控制输入的船舶，Fosson使用非线性反推获得前进和偏航控制律，利用船模验证了其控制器的路径追踪能力。Berge利用线性化状态反馈方法设计了具有完整行为舰船的非线性路径跟踪控制器。在USV“DELFIM”的路径跟踪工作中，将该问题转化为使用线性矩阵不等式方法求解离散时间H2问题，并得到了较好的试验结果 [2] 。 控制方法1.最优控制方法 最优控制理论是庞特里亚金极值原理为依据的，其是对性能指标进行优化并寻找使目标极小控制器。假设系统是线性的，性能指标函数是控制变量和状态变量二次型函数，满足这要求的最优控制器叫做LQR线性二次型最优控制器。在实际工程中，这类控制器具有非常重要的意义。第一，它代表许多工程实际问题提出性能指标的要求；第二，它在数学上处理简单，只要求解黎卡提方程即可得到最优控制器解析表达式，需要特别指出的是，线性二次型最优控制是基于状态反馈得到的最优控制算法，容易达到闭环最优控制，从而在最优控制工程上具有重要意义。 Holzhuter采用LQG（Linear Quadratic Gaussian, 线性二次型高斯）最优控制和卡尔曼滤波方法，研究了船舶直线航迹保持和航迹改变问题，所研究的模型较为简单，而且在稳定性方面只能实现直线航迹控制的局部渐近稳定。Cimen探讨了大型油轮通过伊斯坦布尔海峡时的控制模型，基于SDRE（state-dependent Riccati equation，状态相关Riccati方程），应用非线性最优控制方法研究了大型油轮通过伊斯坦布尔海峡的航迹控制。Sarioz与Narli亦应用最优控制研究了大型油轮通过伊斯坦布尔海峡时的航迹控制，在研究过程中考虑了船舶所受的各种约束、限制，对其进行了计算机模拟仿真。2.滑模变结构控制 张戎军等人应用滑模变结构控制研究了船舶在限制水域的操纵控制问题，将系统输出重定义为偏航角和偏航距离的线性组合形式，提出了一种基于反馈线性化和滑模控制方法的欠驱动船舶直线航迹控制器，获得了船舶直线航迹控制的渐近稳定效果，但不能保证重定义变量中各组合元素的收敛性，同时这种线性组合形式的重定义输出会导致船舶“旋转”。 卜仁祥等人针对带有状态变量及控制输入约束条件的欠驱动船舶航迹控制问题，提出了一种基于分解迭代非线性滑模的船舶航迹增量反馈控制方法，避免了定常干扰引起的稳态误差及变结构控制的抖振问题，该算法无需对不确定的风、流干扰以及模型参数进行估计，对系统参数摄动及外界干扰不敏感，具有较强的鲁棒性。3.智能控制 船舶操纵控制随着船舶的工作状态（如载荷、吃水、航速等）及航行环境（如航线、水深、风、浪、流等）的不同而有很大的变化，是一个模型时变、非线性、大干扰的过程，将智能控制（神经网络、模糊逻辑、遗传算法等）技术引入船舶路径跟踪控制系统设计中，就有可能解决上述问题。 杨盐生等人建立了外界干扰下的船舶操纵运动数学模型，并将模糊控制理论应用于船舶操纵运动自适应控制，可以对船舶在各种风、流状态下的运动性能进行仿真，同时选用不同的模糊控制参数建立相应的合理的模糊控制规则，可以实现船舶在风、流条件下保持航向、航迹以及改变航向、航线的模糊控制仿真。4.反馈线性化 在研究非线性控制理论与应用的过程中，以微分几何为工具发展起来的精确反馈线性化方法受到了普遍重视，Isidori在这方面做了很多开创性的工作。通过李括号及微分同胚等工具研究非线性系统的状态、输入及输出量之间的依赖关系，系统的建立了非线性系统能控、能观及能检测的充分或必要条件，特别是全局状态精确线性化及输入输出精确线性化等方法的发展，使复杂的非线性系统综合问题在适当的非线性状态和反馈变换下转化为简单的线性系统综合问题。它与传统的利用泰勒级数展开进行局部线性化的近似方法不同，即在线性化过程中没有忽略掉任何高阶非线性项，因此，这种线性化不仅是精确的，而且是在全局意义下的，即线性化对变换有定义的整个区域都适用。 李铁山等人针对船舶航迹控制系统中存在的非线性，建立了欠驱动船舶直线航迹控制系统的非线性数学模型，基于输入输出反馈线性化技术，采用重定义输出变量思想，提出了一种状态反馈控制律。该控制律克服了转首角速度不能为零以及重定义输出变量中组成元素的收敛性不能保证的局限，使得欠驱动船舶能够渐近镇定于直线参考航迹，缺点是重定义输出表达为偏航距离和航向角的线性形式，会引起船舶“旋转”，并且偏航距离和航向角只能局部渐近稳定 [3] 。 a coordinate transformation was made to transform the original model into a triangular like structure, then a backstepping controller was designed for the transformed system. The control objective is to make the system output track the desired trajectorywhere is a known bound of . Clearly, the relationship betweenthe applied control and the control input has a sharp cornerwhen . Thus backstepping technique cannot be directlyapplied. In order to use this technique, the saturation is approximated by a smooth function defifined as RISE: This is the nonlinear robust controller that utilizesfull-state measurements, including a model-based feedforwardcontrol term but without disturbance estimation, and a lin\u0002ear feedback control and a nonlinear integral signum feedbackcontrol mechanism. To make comparisons fair, the correspond\u0002ing control gains are chosen the same with the proposed RISE\u0002ESO controller. 在这些研究成果中，根据平面参考轨迹生成方式的不同，主要分为两类: 轨迹跟踪和航迹跟踪。在轨迹跟踪问题中，参考轨迹由“虚拟模型”产生，该模型具有和真实的 AUV 相同的动力学特性，可以同时实现 AUV 位置和方向角的跟踪，但参考轨迹的形式存在很多限制，且难以提前设定，因此在实际应用时存在很大的局限性。与之不同，在航迹跟踪问题中，仅要求 AUV 实现位置跟踪，使得参考轨迹可以是提前设定的任意平面曲线或一系列航迹点，因此其更能体现实际中 AUV 的跟踪需求。 通过引入一种 Nussbaum 型偶函数，设计了欠驱动 AUV 的航迹 跟踪饱和控制器，使得 AUV 的控制输入能够在不触发饱和情况下，实现对参考航迹的跟踪。通过设计 τu和 τr，使得跟踪误差变量( e，ψe) 收敛到原点附近的有界邻域内","categories":[],"tags":[{"name":"科研","slug":"科研","permalink":"https://lijiale96.github.io/tags/%E7%A7%91%E7%A0%94/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-02-16T08:56:35.772Z","updated":"2020-02-16T08:56:35.772Z","comments":true,"path":"2020/02/16/hello-world/","link":"","permalink":"https://lijiale96.github.io/2020/02/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}